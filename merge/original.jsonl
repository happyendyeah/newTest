{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; Node finallyStmt = finallyBlock . getFirstChild ( ) ; } }", "label": 1, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } return result ; }", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } return result ; }", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Chart_19"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } return ! allowSigns & & foundDigit ; } }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } return ! allowSigns & & foundDigit ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { return foundDigit & & ! hasExp ; } / / last character is illegal", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_24"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Lang_24"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; }", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0xS", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0xS", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_25"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_25"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_3"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_3"}
{"buggy_code": "final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "* limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_35"}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_35"}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_4"}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_4"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; } if ( isInfinite ) {", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ;", "fixed_code": "import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math . distribution ; import java . io . Serializable ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math . distribution ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import java . io . Serializable ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_61"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; }", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }  } return minRatioPos ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; }", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }  } return minRatioPos ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_89"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_89"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_90"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_90"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; }  public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; }  public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_93"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_99"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_99"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ; case 1 :", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ; case 1 :", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Time_15"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Time_15"}
{"buggy_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 1, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( x , y , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" The Integer did not match any specified value \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" The Integer did not match any specified value \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "if ( upper < lower ) { upper = lower ; }  StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) {", "fixed_code": "if ( upper < lower ) { upper = lower ; } if ( upper = = - 1 | | upper > str . length ( ) ) { upper = str . length ( ) ; } StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "/ / next stages for ( int k = 1 ; k < stages ; + + k ) {  for ( int j = 0 ; j < y0 . length ; + + j ) { double sum = a [ k - 1 ] [ 0 ] * yDotK [ 0 ] [ j ] ; for ( int l = 1 ; l < k ; + + l ) {", "fixed_code": "/ / next stages for ( int k = 1 ; k < stages ; + + k ) { if ( ( forward & & ( stepStart + stepSize > t ) ) | | ( ( ! forward ) & & ( stepStart + stepSize < t ) ) ) { stepSize = t - stepStart ; } for ( int j = 0 ; j < y0 . length ; + + j ) { double sum = a [ k - 1 ] [ 0 ] * yDotK [ 0 ] [ j ] ; for ( int l = 1 ; l < k ; + + l ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { if ( function = = null ) { throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; } verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "fixed_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "label": 1, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ) ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }  / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } verifyBracketing ( min , max , f ) ; / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length\u00df\u00df \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length\u00df\u00df \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length\u00df\u00df \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length\u00df\u00df \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "Arja", "patch_name": "patch5", "project_name": "Math_98"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ; case 1 : return val1 ; } long total = val1 * val2 ; if ( total / val2 ! = val1 ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return total ; }", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : break ; case 0 : return 0L ; case 1 : return val1 ; } long total = val1 * val2 ; if ( total / val2 ! = val1 | | val1 = = Long . MIN_VALUE & & val2 = = - 1 | | val2 = = Long . MIN_VALUE & & val1 = = - 1 ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return total ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) {  / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) {  / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } }  for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } }  for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_2"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_38"}
{"buggy_code": "old mode 100755 new mode 100644 propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "old mode 100755 new mode 100644 propertyNode ) ; }  JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_46"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "/ / contract with translators is that they have to understand codepoints / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / contract with translators is that they have to understand codepoints / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ;", "fixed_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line if ( v1D = = null ) { return null ; } Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_4"}
{"buggy_code": "Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . getRemainingRegion ( ) . checkPoint ( line2 . toSubSpace ( v2D ) ) ;", "fixed_code": "Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line if ( v2D = = null ) { return null ; } Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . getRemainingRegion ( ) . checkPoint ( line2 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch3", "project_name": "Math_4"}
{"buggy_code": "* For x between 0 and 1 , returns exp ( x ) , uses extended precision * @ param x argument of exponential * @ param result placeholder where to place exp ( x ) split in two terms * for extra precision ( i . e . exp ( x ) = result [ 0 ] ? ? result [ 1 ] * @ return exp ( x ) private static double slowexp ( final double x , final double result [ ] ) { * @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* For x between 0 and 1 , returns exp ( x ) , uses extended precision * @ param x argument of exponential * @ param result placeholder where to place exp ( x ) split in two terms * for extra precision ( i . e . exp ( x ) = result [ 0 ] ? ? result [ 1 ] * @ return exp ( x ) private static double slowexp ( final double x , final double result [ ] ) { * @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_59"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . cAvailableLocaleList . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return new java . util . HashSet ( org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . cAvailableLocaleList . contains ( locale ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return new java . util . HashSet ( org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) ) . contains ( locale ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Lang_57"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_53"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = ( ( residualsWeights [ i ] ) * residual ) * residual ; } return chiSquare ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( p2 = = null ) { return false ; } if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; while ( ! done ) { if ( iterator1 . isDone ( ) ! = iterator2 . isDone ( ) ) {", "fixed_code": "if ( p2 = = null ) { return false ; } if ( ( p1 . getWindingRule ( ) ) ! = ( p2 . getWindingRule ( ) ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;  boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; while ( ! done ) { if ( iterator1 . isDone ( ) ! = iterator2 . isDone ( ) ) {", "label": 1, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "} public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException {", "fixed_code": "} public double solve ( UnivariateRealFunction f , double min , double max , double initial ) throws math . FunctionEvaluationException , math . MaxIterationsExceededException { return solve ( f , min , max ) ; }  public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException {", "label": 1, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner ! = null ? owner . getEntityCollection ( ) : null ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "boolean staleInputs = false ; / / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "boolean staleInputs = false ; / / Check if the sources need to be re - ordered . if ( ( options . dependencyOptions . needsManagement ( ) ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } public JSType getLeastSupertype ( JSType that ) { return super . getLeastSupertype ( that ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; wasWhite = true ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) {", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) {", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) getSampleSize ( ) * getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; }", "fixed_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 1 ) . doubleValue ( ) * 100 ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_27"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final long n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return Collections . unmodifiableList ( chromosomes ) . iterator ( ) ; } }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "", "fixed_code": "", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 . 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "return max ; } public String get ( ) { return null ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_77"}
{"buggy_code": "return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "return max ; } public String get ( ) { return null ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch2", "project_name": "Math_77"}
{"buggy_code": "* @ param v the value to add . * @ throws IllegalArgumentException if < code > v < / code > is not comparable with previous entries Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ; }", "fixed_code": "* @ param v the value to add . * @ throws IllegalArgumentException if < code > v < / code > is not comparable with previous entries Object obj = ( Serializable ) v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( v = = 0 | | u = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_94"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ data . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } double [ ] out = new double [ data . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ data . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } double [ ] out = new double [ data . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "public void describeTo ( Description description ) { description . appendText ( \" same ( \" ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText ( \" ) \" ) ; }", "fixed_code": "public void describeTo ( Description description ) { description . appendText ( \" same ( \" ) ; appendQuoting ( description ) ; if ( wanted ! = null ) { description . appendText ( wanted . toString ( ) ) ; } appendQuoting ( description ) ; description . appendText ( \" ) \" ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Mockito_29"}
{"buggy_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } }", "fixed_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( String . valueOf ( arg ) ) ; } }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Mockito_38"}
{"buggy_code": "} catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( org . mockito . exceptions . verification . junit . ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; } }", "fixed_code": "} catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( AssertionError e ) { error = handleVerifyException ( e ) ; } }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Mockito_5"}
{"buggy_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ; }", "fixed_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else if ( typeParameter ! = actualTypeArgument ) { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ; }", "label": 1, "tool_name": "CoCoNut", "patch_name": "patch1", "project_name": "Mockito_8"}
{"buggy_code": "import java . awt . geom . Point2D ; import java . awt . geom . Rectangle2D ; import java . util . Arrays ;", "fixed_code": "import java . awt . geom . Point2D ; import java . awt . geom . Rectangle2D ; import java . util . Arrays ; import java . util . Map ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "import java . io . Serializable ; import org . jfree . chart . util . PublicCloneable ;", "fixed_code": "import java . io . Serializable ; import org . jfree . chart . util . PublicCloneable ; import java . util . Map ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 1 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c < 0x7F & & c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } break ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "import java . io . StringWriter ; import java . io . Writer ; import java . util . Locale ;", "fixed_code": "import java . io . StringWriter ; import java . io . Writer ; import java . util . Locale ; import java . util . Map ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ; final double VarU = n1n2prod * ( n1 + n2 + 1 ) / 12 . 0 ; final double z = ( Umin - EU ) / FastMath . sqrt ( VarU ) ;", "fixed_code": "/ / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ; final double VarU = n1n2prod * ( ( ( double ) n1 ) + n2 + 1 ) / 12 . 0 ; final double z = ( Umin - EU ) / FastMath . sqrt ( VarU ) ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "import org . apache . commons . math3 . optimization . GoalType ; import org . apache . commons . math3 . optimization . PointValuePair ; import org . apache . commons . math3 . util . Precision ;", "fixed_code": "import org . apache . commons . math3 . optimization . GoalType ; import org . apache . commons . math3 . optimization . PointValuePair ; import org . apache . commons . math3 . util . Precision ; import java . util . Map ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "import org . apache . commons . math . FunctionEvaluationException ; import org . apache . commons . math . MaxIterationsExceededException ; import org . apache . commons . math . analysis . UnivariateRealFunction ; public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "import org . apache . commons . math . FunctionEvaluationException ; import org . apache . commons . math . MaxIterationsExceededException ; import org . apache . commons . math . analysis . UnivariateRealFunction ; import java . util . List ; public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "import java . util . TreeMap ; import org . apache . commons . math . MathRuntimeException ; @ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "import java . util . TreeMap ; import org . apache . commons . math . MathRuntimeException ; import java . util . Map ; @ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > - 1 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; }", "fixed_code": "if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( c ) ; } continue ; }", "label": 1, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( v > 0 ) { v = - v ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "label": 1, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "| | chars [ i ] = = ' F ' ) ) { return foundDigit ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point", "fixed_code": "| | chars [ i ] = = ' F ' ) ) { return foundDigit ; } if ( hasDecPoint | | hasExp ) { return false ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point", "label": 1, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return org . apache . commons . lang3 . math . NumberUtils . createBigDecimal ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) }", "fixed_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText \" \\ \" alt = \\ \" \\ \" \" ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_10"}
{"buggy_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText }", "fixed_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) \" \\ \" alt = \\ \" \\ \" \" ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_10"}
{"buggy_code": "* * @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText + \" \\ \" alt = \\ \" \\ \" \" ; } }", "fixed_code": "* * @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String instruction ) { System . exit ( 0 ) ; return null ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_10"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "fixed_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "fixed_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "fixed_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "fixed_code": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_16"}
{"buggy_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; }", "fixed_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; }", "fixed_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_17"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_18"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "fixed_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_2"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_20"}
{"buggy_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } }", "fixed_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_21"}
{"buggy_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } / / 2 . check whether the column is now empty . } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } / / 2 . check whether the column is now empty . } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_22"}
{"buggy_code": "if ( ! ( this . lower = = range . lower ) ) { return false ; }", "fixed_code": "if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_22"}
{"buggy_code": "* * @ since 1 . 0 . 7 public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof MinMaxCategoryRenderer ) ) { return false ; } MinMaxCategoryRenderer that = ( MinMaxCategoryRenderer ) obj ; if ( this . plotLines ! = that . plotLines ) { return false ; } if ( ! PaintUtilities . equal ( this . groupPaint , that . groupPaint ) ) { return false ; } if ( ! this . groupStroke . equals ( that . groupStroke ) ) { return false ; } return super . equals ( obj ) ; }", "fixed_code": "* * @ since 1 . 0 . 7", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_23"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_25"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "fixed_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "fixed_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "fixed_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "fixed_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; }", "fixed_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; }", "fixed_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_6"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_8"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "package org . apache . commons . cli ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; private Map options = new HashMap ( ) ; private Map names = new HashMap ( ) ; / / private Set allOptions = new HashSet ( ) ; private Map hashcodeMap = new HashMap ( ) ; public boolean hasOption ( String opt ) { return options . containsKey ( opt ) ; } public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  String key = opt ; if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; } * @ param opt short or long name of the option * @ return Canonicalized option void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; if ( key = = null ) { key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; } public Iterator iterator ( ) { return hashcodeMap . values ( ) . iterator ( ) ; } public Option [ ] getOptions ( ) { Collection processed = options . values ( ) ; / / reinitialise array Option [ ] optionsArray = new Option [ processed . size ( ) ] ; / / return the array return ( Option [ ] ) processed . toArray ( optionsArray ) ; } \\ No newline at end of file }", "fixed_code": "package org . apache . commons . cli ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . HashSet ; private Set options = new HashSet ( ) ; / / private Set allOptions = new HashSet ( ) ; public boolean hasOption ( String opt ) { return options . contains ( resolveOption ( opt ) ) ; } public String [ ] getOptionValues ( String opt ) { Option key = resolveOption ( opt ) ; if ( options . contains ( key ) ) { return key . getValues ( ) ; } return null ; } * @ param opt short or long name of the option * @ return Canonicalized option private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ; ) { Option option = ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; } void addOption ( Option opt ) { options . add ( opt ) ; } public Iterator iterator ( ) { return options . iterator ( ) ; } public Option [ ] getOptions ( ) { Collection processed = options ; / / reinitialise array Option [ ] optionsArray = new Option [ processed . size ( ) ] ; / / return the array return ( Option [ ] ) processed . toArray ( optionsArray ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_1"}
{"buggy_code": "} / / if the Option has a value if ( option . hasArg ( ) & & ( option . getArgName ( ) ! = null ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "fixed_code": "} / / if the Option has a value if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_11"}
{"buggy_code": "} else { if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { / / the format is - - foo = value or - foo = value / / the format is a special properties option ( - Dproperty = value ) tokens . add ( arg . substring ( 0 , 2 ) ) ; / / - D tokens . add ( arg . substring ( 2 ) ) ; / / property = value", "fixed_code": "} else { if ( opt . indexOf ( ' = ' ) ! = - 1 & & options . hasOption ( opt . substring ( 0 , opt . indexOf ( ' = ' ) ) ) ) { / / the format is - - foo = value or - foo = value tokens . add ( arg . substring ( 0 , arg . indexOf ( ' = ' ) ) ) ; / / - - foo tokens . add ( arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ) ; / / value } else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { / / the format is a special properties option ( - Dproperty = value ) tokens . add ( arg . substring ( 0 , 2 ) ) ; / / - D tokens . add ( arg . substring ( 2 ) ) ; / / property = value", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_12"}
{"buggy_code": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } / / augment the list with the default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = ( List ) this . defaultValues . get ( option ) ; } / / if there are more default values as specified , add them to / / the list . / / copy the list first return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "fixed_code": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( defaultValues = = null | | defaultValues . isEmpty ( ) ) { defaultValues = ( List ) this . defaultValues . get ( option ) ; } / / augment the list with the default values if ( defaultValues ! = null & & ! defaultValues . isEmpty ( ) ) { if ( valueList = = null | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } else { / / if there are more default values as specified , add them to / / the list . if ( defaultValues . size ( ) > valueList . size ( ) ) { / / copy the list first valueList = new ArrayList ( valueList ) ; for ( int i = valueList . size ( ) ; i < defaultValues . size ( ) ; i + + ) { valueList . add ( defaultValues . get ( i ) ) ; } } } } return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_15"}
{"buggy_code": "* * @ return the parent of this option } } / / ensure that all parent options are also added } public void addValue ( final Option option , / / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; if ( option instanceof Argument ) { i . remove ( ) ; public abstract class OptionImpl implements Option { private final int id ; private final boolean required ;", "fixed_code": "* * @ return the parent of this option Option getParent ( ) ; void setParent ( Option parent ) ; } } / / ensure that all parent options are also added Option parent = option . getParent ( ) ; while ( parent ! = null & & ! options . contains ( parent ) ) { options . add ( parent ) ; parent = parent . getParent ( ) ; } } public void addValue ( final Option option , / / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; option . setParent ( this ) ; if ( option instanceof Argument ) { i . remove ( ) ; public abstract class OptionImpl implements Option { private final int id ; private final boolean required ; private Option parent ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_16"}
{"buggy_code": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else {", "fixed_code": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; break ; } else {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_17"}
{"buggy_code": "/ / single hyphen else if ( \" - \" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( \" - \" ) ) { tokens . add ( value ) ; } } private void processSingleHyphen ( String hyphen ) { tokens . add ( hyphen ) ; }", "fixed_code": "/ / single hyphen else if ( \" - \" . equals ( token ) ) { tokens . add ( token ) ; } else if ( token . startsWith ( \" - \" ) ) { tokens . add ( value ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_18"}
{"buggy_code": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( token ) ; } }", "fixed_code": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; }  tokens . add ( token ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_19"}
{"buggy_code": "} else { tokens . add ( \" - \" + ch ) ; } } } \\ No newline at end of file }", "fixed_code": "} else { tokens . add ( token ) ; break ; } } } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_2"}
{"buggy_code": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { if ( token . indexOf ( ' = ' ) ! = - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }", "fixed_code": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { int pos = token . indexOf ( ' = ' ) ; String opt = pos = = - 1 ? token : token . substring ( 0 , pos ) ; / / - - foo  if ( ! options . hasOption ( opt ) & & stopAtNonOption ) { process ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_20"}
{"buggy_code": "* * @ return the current option } private final Map defaultSwitches = new HashMap ( ) ; private final List normalised ; private final Set prefixes ; public boolean looksLikeOption ( final String trigger ) { / / this is a reentrant call for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { return true ; } } return false ; } public String toString ( ) { private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { return commandLine . looksLikeOption ( trigger ) ; } }", "fixed_code": "* * @ return the current option Option getCurrentOption ( ) ; void setCurrentOption ( Option currentOption ) ; } private final Map defaultSwitches = new HashMap ( ) ; private final List normalised ; private final Set prefixes ; private Option currentOption ; private String checkForOption ; public boolean looksLikeOption ( final String trigger ) { if ( checkForOption ! = null ) { / / this is a reentrant call return ! checkForOption . equals ( trigger ) ; } checkForOption = trigger ; try { for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { if ( getCurrentOption ( ) . canProcess ( this , trigger ) | | getCurrentOption ( ) . findOption ( trigger ) ! = null ) { return true ; } } }  return false ; } finally { checkForOption = null ; } } public String toString ( ) { private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { Option oldOption = commandLine . getCurrentOption ( ) ; try { commandLine . setCurrentOption ( this ) ; return commandLine . looksLikeOption ( trigger ) ; } finally { commandLine . setCurrentOption ( oldOption ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_21"}
{"buggy_code": "private boolean eatTheRest ; private Options options ; if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else if ( stopAtNonOption ) { processNonOptionToken ( token ) ; } else { tokens . add ( token ) ; } gobble ( iter ) ; * * @ param value The current token private void processNonOptionToken ( String value ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; tokens . add ( value ) ; } eatTheRest = true ; } tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { Option currentOption ; for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) ) ; break ; } else", "fixed_code": "private boolean eatTheRest ; private Option currentOption ; private Options options ; if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token , stopAtNonOption ) ; } else { currentOption = options . getOption ( opt ) ; tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; * * @ param value The current token private void processNonOptionToken ( String value , boolean stopAtNonOption ) { if ( stopAtNonOption & & ( currentOption = = null | | ! currentOption . hasArg ( ) ) ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; } tokens . add ( value ) ; } eatTheRest = true ; } if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break ; } else", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_22"}
{"buggy_code": "while ( true ) { int lastPos = pos ; text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; sb . append ( text ) ; return sb ; } else if ( pos = = lastPos ) { throw new RuntimeException ( \" Text too long for line - throwing exception to avoid infinite loop [ CLI - 162 ] : \" + text ) ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;", "fixed_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; sb . append ( text ) ; return sb ; }  if ( ( text . length ( ) > width ) & & ( pos = = nextLineTabStop - 1 ) ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_23"}
{"buggy_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening throw new IllegalStateException ( \" Total width is less than the width of the argument and indent \" + \" - no room for the description \" ) ; } / / all following lines must be padded with nextLineTabStop space", "fixed_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = width - 1 ; } / / all following lines must be padded with nextLineTabStop space", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_24"}
{"buggy_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = width - 1 ; } / / all following lines must be padded with nextLineTabStop space", "fixed_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = 1 ; } / / all following lines must be padded with nextLineTabStop space", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_25"}
{"buggy_code": "public static Option create ( String opt ) throws IllegalArgumentException { / / create the option Option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; / / return the Option instance return option ;", "fixed_code": "public static Option create ( String opt ) throws IllegalArgumentException { Option option = null ; try { / / create the option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } finally { / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; } / / return the Option instance return option ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_26"}
{"buggy_code": "/ / if no option has already been selected or the / / same option is being reselected then set the / / selected member variable if ( selected = = null | | selected . equals ( option . getOpt ( ) ) ) { selected = option . getOpt ( ) ; } else {", "fixed_code": "/ / if no option has already been selected or the / / same option is being reselected then set the / / selected member variable if ( selected = = null | | selected . equals ( option . getKey ( ) ) ) { selected = option . getKey ( ) ; } else {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_27"}
{"buggy_code": "static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( \" \\ \" \" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } int length = str . length ( ) ; if ( str . endsWith ( \" \\ \" \" ) ) { str = str . substring ( 0 , length - 1 ) ; } return str ;", "fixed_code": "static String stripLeadingAndTrailingQuotes ( String str ) { int length = str . length ( ) ; if ( length > 1 & & str . startsWith ( \" \\ \" \" ) & & str . endsWith ( \" \\ \" \" ) & & str . substring ( 1 , length - 1 ) . indexOf ( ' \" ' ) = = - 1 ) { str = str . substring ( 1 , length - 1 ) ; } return str ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_28"}
{"buggy_code": "{ / / if the value is not yes , true or 1 then don ' t add the / / option to the CommandLine break ; } cmd . addOption ( opt ) ;", "fixed_code": "{ / / if the value is not yes , true or 1 then don ' t add the / / option to the CommandLine continue ; } cmd . addOption ( opt ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Cli_28"}
{"buggy_code": "import java . util . Date ; import org . apache . commons . lang . math . NumberUtils ;", "fixed_code": "import java . util . Date ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_3"}
{"buggy_code": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "fixed_code": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_30"}
{"buggy_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option private String longOpt ; private String argName = \" arg \" ; private String description ; private static void reset ( ) { description = null ; argName = \" arg \" ; longopt = null ; type = null ; required = false ;", "fixed_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & ( option . getArgName ( ) = = null | | option . getArgName ( ) . length ( ) ! = 0 ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ! = null ? option . getArgName ( ) : getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option private String longOpt ; private String argName ; private String description ; private static void reset ( ) { description = null ; argName = null ; longopt = null ; type = null ; required = false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_31"}
{"buggy_code": "/ / if we didn ' t find one , simply chop at startPos + width pos = startPos + width ; while ( ( pos < = text . length ( ) ) & & ( ( c = text . charAt ( pos ) ) ! = ' ' ) & & ( c ! = ' \\ n ' ) & & ( c ! = ' \\ r ' ) ) { + + pos ; } return pos = = text . length ( ) ? - 1 : pos ; }", "fixed_code": "/ / if we didn ' t find one , simply chop at startPos + width pos = startPos + width ;  return pos = = text . length ( ) ? - 1 : pos ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_32"}
{"buggy_code": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately p . skipChildren ( ) ; return null ; }", "fixed_code": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately if ( p . hasToken ( JsonToken . FIELD_NAME ) ) { while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = null ) | | ( t = = JsonToken . END_OBJECT ) ) { break ; } p . skipChildren ( ) ; } } else { p . skipChildren ( ) ; } return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_33"}
{"buggy_code": "{ StringBuffer sb = new StringBuffer ( text . length ( ) ) ; renderWrappedText ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; } * @ param nextLineTabStop The position on the next line for the first tab . * @ param text The text to be rendered . / / cannot happen", "fixed_code": "{ StringBuffer sb = new StringBuffer ( text . length ( ) ) ; renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; } * @ param nextLineTabStop The position on the next line for the first tab . * @ param text The text to be rendered . private StringBuffer renderWrappedTextBlock ( StringBuffer sb , int width , int nextLineTabStop , String text ) { try { BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; while ( ( line = in . readLine ( ) ) ! = null ) { if ( ! firstLine ) { sb . append ( getNewLine ( ) ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } } catch ( IOException e ) { / / cannot happen } return sb ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Cli_33"}
{"buggy_code": "private int numberOfArgs = UNINITIALIZED ; private Class type ; private List values = new ArrayList ( ) ; description = null ; argName = null ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ;", "fixed_code": "private int numberOfArgs = UNINITIALIZED ; private Class type = String . class ; private List values = new ArrayList ( ) ; description = null ; argName = null ; longopt = null ; type = String . class ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_34"}
{"buggy_code": "import java . io . Serializable ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; private final Map < String , Option > optionMap = new HashMap < String , Option > ( ) ; private String selected ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; private final List < Object > requiredOpts = new ArrayList < Object > ( ) ; private final Map < String , OptionGroup > optionGroups = new HashMap < String , OptionGroup > ( ) ;", "fixed_code": "import java . io . Serializable ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; private final Map < String , Option > optionMap = new LinkedHashMap < String , Option > ( ) ; private String selected ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; private final List < Object > requiredOpts = new ArrayList < Object > ( ) ; private final Map < String , OptionGroup > optionGroups = new LinkedHashMap < String , OptionGroup > ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_36"}
{"buggy_code": "private boolean isShortOption ( String token ) { / / short options ( - S , - SV , - S = V , - SV1 = V2 , - S1S2 ) return token . startsWith ( \" - \" ) & & token . length ( ) > = 2 & & options . hasShortOption ( token . substring ( 1 , 2 ) ) ; / / remove leading \" - \" and \" = value \" }", "fixed_code": "private boolean isShortOption ( String token ) { / / short options ( - S , - SV , - S = V , - SV1 = V2 , - S1S2 ) if ( ! token . startsWith ( \" - \" ) | | token . length ( ) = = 1 ) { return false ; } / / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_37"}
{"buggy_code": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; / / check for several concatenated short options }", "fixed_code": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { return true ; } / / check for several concatenated short options return optName . length ( ) > 0 & & options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_38"}
{"buggy_code": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { * @ return The file input stream represented by < code > str < / code > . * @ throws ParseException if the file is not exist or not readable", "fixed_code": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { * @ return The file input stream represented by < code > str < / code > . * @ throws ParseException if the file is not exist or not readable public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( \" Unable to find file : \" + str ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Cli_39"}
{"buggy_code": "if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; / / loop through the required options", "fixed_code": "if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( \" Missing required option \" ) ; buff . append ( requiredOptions . size ( ) = = 1 ? \" \" : \" s \" ) ; buff . append ( \" : \" ) ; / / loop through the required options", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_4"}
{"buggy_code": "} else { return null ; } }", "fixed_code": "} else { throw new ParseException ( \" Unable to handle the class : \" + clazz ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_40"}
{"buggy_code": "static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( \" - - \" ) ) { return str . substring ( 2 , str . length ( ) ) ;", "fixed_code": "static String stripLeadingHyphens ( String str ) { if ( str = = null ) { return null ; } if ( str . startsWith ( \" - - \" ) ) { return str . substring ( 2 , str . length ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_5"}
{"buggy_code": "package org . apache . commons . cli2 . builder ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import org . apache . commons . cli2 . Argument ; this . abuilder = abuilder ; } private final Set options = new HashSet ( ) ;", "fixed_code": "package org . apache . commons . cli2 . builder ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . Set ; import org . apache . commons . cli2 . Argument ; this . abuilder = abuilder ; } private final Set options = new LinkedHashSet ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_7"}
{"buggy_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos = = - 1 ) {", "fixed_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; if ( pos = = - 1 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_8"}
{"buggy_code": "while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }", "fixed_code": "while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; buff . append ( \" , \" ) ; } throw new MissingOptionException ( buff . substring ( 0 , buff . length ( ) - 2 ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Cli_9"}
{"buggy_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 if ( ! removeGlobals ) { return ; } Node function = fnScope . getRootNode ( ) ;", "fixed_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 Node function = fnScope . getRootNode ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_10"}
{"buggy_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; int pType = parent . getType ( ) ; if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return parent ! = null & & NodeUtil . isGet ( parent ) ; }", "fixed_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_100"}
{"buggy_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return false ; }", "fixed_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; int pType = parent . getType ( ) ; if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return parent ! = null & & NodeUtil . isGet ( parent ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_100"}
{"buggy_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; }", "fixed_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } if ( flags . process_closure_primitives ) { options . closurePass = true ; } initOptionsFromFlags ( options ) ; return options ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; removeDuplicateDeclarations ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "fixed_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_102"}
{"buggy_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : case Token . INSTANCEOF : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . if ( foundType = = null ) { ObjectType maybeType = ObjectType . cast ( registry . getGreatestSubtypeWithProperty ( type , field ) ) ; / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { foundType = maybeType ; } } return foundType ; }", "fixed_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . return foundType ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_103"}
{"buggy_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( ! result . isNoType ( ) ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "fixed_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result ! = null ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_104"}
{"buggy_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result ! = null ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "fixed_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( ! result . isNoType ( ) ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_104"}
{"buggy_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = null ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } else { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = null ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "fixed_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = new StringBuilder ( ) ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb . length ( ) > 0 ) { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_105"}
{"buggy_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = new StringBuilder ( ) ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb . length ( ) > 0 ) { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "fixed_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = null ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } else { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = null ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_105"}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ; * @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; }", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ; * @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ; * @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; }", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ; * @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_106"}
{"buggy_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "fixed_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_106"}
{"buggy_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; } return options ;", "fixed_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . private final Set < Node > injectedDecls = Sets . newHashSet ( ) ; / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; injectedDecls . clear ( ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } injectedDecls . add ( newDecl . getFirstChild ( ) ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & ! injectedDecls . contains ( n ) ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "fixed_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "fixed_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . private final Set < Node > injectedDecls = Sets . newHashSet ( ) ; / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; injectedDecls . clear ( ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } injectedDecls . add ( newDecl . getFirstChild ( ) ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & ! injectedDecls . contains ( n ) ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_108"}
{"buggy_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token ! = JsDocToken . STRING ) { return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token = = null ) { return reportGenericTypeSyntaxWarning ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_108"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_109"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , 0 ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_109"}
{"buggy_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "fixed_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_11"}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_110"}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_110"}
{"buggy_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType . isAllType ( ) ? getNativeType ( ARRAY_TYPE ) : topType ; } @ Override", "fixed_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType ; } @ Override", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_111"}
{"buggy_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType ; } @ Override", "fixed_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType . isAllType ( ) ? getNativeType ( ARRAY_TYPE ) : topType ; } @ Override", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_111"}
{"buggy_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = Maps . filterKeys ( inferTemplateTypesFromParameters ( fnType , n ) , new Predicate < TemplateType > ( ) {  @ Override public boolean apply ( TemplateType key ) { return keys . contains ( key ) ; } } ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "fixed_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = inferTemplateTypesFromParameters ( fnType , n ) ;  / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = inferTemplateTypesFromParameters ( fnType , n ) ;  / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "fixed_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = Maps . filterKeys ( inferTemplateTypesFromParameters ( fnType , n ) , new Predicate < TemplateType > ( ) {  @ Override public boolean apply ( TemplateType key ) { return keys . contains ( key ) ; } } ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_112"}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null | | requiresLevel . isOn ( ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_113"}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null | | requiresLevel . isOn ( ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_113"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_113"}
{"buggy_code": "} else { recordDepScope ( nameNode , ns ) ; } } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "fixed_code": "} else { recordDepScope ( nameNode , ns ) ; } } else { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "} else { recordDepScope ( nameNode , ns ) ; } } else { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "fixed_code": "} else { recordDepScope ( nameNode , ns ) ; } } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_114"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) {  } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_114"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; / / empty function case if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } / / The best type name is the actual type name . if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "fixed_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { / / The best type name is the actual type name . / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_117"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_118"}
{"buggy_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . CATCH : case Token . INC : case Token . DEC : isSet = true ;", "fixed_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . INC : case Token . DEC : isSet = true ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else { break ; } } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return toString ( true , true , true ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; break ; } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_119"}
{"buggy_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( cfgNode ) ; for ( DiGraphEdge < Node , Branch > edge : branchEdges ) { if ( edge . getValue ( ) = = Branch . ON_EX ) { return true ; } } return false ; }", "fixed_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { if ( ref . getSymbol ( ) . getScope ( ) ! = ref . scope ) { return false ; } break ; } else if ( block . isLoop ) { return false ;", "fixed_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } private Predicate < Var > getFilterForMode ( ) {", "fixed_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } private Predicate < Var > getFilterForMode ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_120"}
{"buggy_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) & & / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . ( isInlineableDeclaredConstant ( v , referenceInfo ) | | referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "fixed_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "fixed_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) & & / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . ( isInlineableDeclaredConstant ( v , referenceInfo ) | | referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_121"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) { Pattern p = Pattern . compile ( \" ( / | ( \\ n [ \\ t ] * ) ) \\ \\ * [ \\ t ] * @ [ a - zA - Z ] \" ) ; if ( p . matcher ( comment . getValue ( ) ) . find ( ) ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) { Pattern p = Pattern . compile ( \" ( / | ( \\ n [ \\ t ] * ) ) \\ \\ * [ \\ t ] * @ [ a - zA - Z ] \" ) ; if ( p . matcher ( comment . getValue ( ) ) . find ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_122"}
{"buggy_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { maybeResolveTemplateTypeFromNodes ( declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; } private void maybeResolveTemplateTypeFromNodes (", "fixed_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { } private void maybeResolveTemplateTypeFromNodes (", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_122"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_123"}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_123"}
{"buggy_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; while ( node . isGetProp ( ) ) { node = node . getFirstChild ( ) ; } if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "fixed_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "fixed_code": "case Token . SHEQ : if ( outcome ) { } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_124"}
{"buggy_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "fixed_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "fixed_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_125"}
{"buggy_code": "} public boolean matches ( Object actual ) { if ( this . wanted = = null ) { return actual = = null ; } return wanted . equals ( actual ) ;", "fixed_code": "} public boolean matches ( Object actual ) { if ( ! ( ( actual ! = null ) & & ( actual ! = null ) ) ) { return actual = = null ; } return wanted . equals ( actual ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_125"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_126"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough & & ! inFinally ( n . getParent ( ) , n ) ) { removeNode ( n ) ; } } } } private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } } } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } } } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough & & ! inFinally ( n . getParent ( ) , n ) ) { removeNode ( n ) ; } } } } private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_127"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_127"}
{"buggy_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; if ( len = = 0 ) { return false ; } for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_128"}
{"buggy_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; if ( len = = 0 ) { return false ; } for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_128"}
{"buggy_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . while ( first . isCast ( ) ) { first = first . getFirstChild ( ) ; } if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "fixed_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "fixed_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_129"}
{"buggy_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { Node next = c . getNext ( ) ; traverse ( c ) ; c = next ; }", "fixed_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_13"}
{"buggy_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; }", "fixed_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { Node next = c . getNext ( ) ; traverse ( c ) ; c = next ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_13"}
{"buggy_code": "continue ; } if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "fixed_code": "continue ; } if ( name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "continue ; } if ( name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "fixed_code": "continue ; } if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_130"}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "} } return reportGenericTypeSyntaxWarning ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_130"}
{"buggy_code": "int length = s . length ( ) ; if ( length = = 0 | | Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "fixed_code": "int length = s . length ( ) ; if ( length = = 0 | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_131"}
{"buggy_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "fixed_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_132"}
{"buggy_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "fixed_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_132"}
{"buggy_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; unreadToken = NO_UNREAD_TOKEN ; return result ; }", "fixed_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; return result ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "for ( Property p : propertyMap . values ( ) ) { if ( ! p . skipAmbiguating ) { computeRelatedTypes ( p . type ) ; propsByFreq . add ( p ) ; } else { if ( typesRelatedToSet . intersects ( prop . typesSet ) ) { return false ; } return ! getRelated ( prop . type ) . intersects ( typesInSet ) ; } public void addNode ( Property prop ) { typesInSet . or ( prop . typesSet ) ; typesRelatedToSet . or ( getRelated ( prop . type ) ) ; } private class Property { final String oldName ; JSType type ; String newName ; int numOccurrences ; boolean skipAmbiguating ; JSTypeBitSet typesSet = new JSTypeBitSet ( intForType . size ( ) ) ; Property ( String name ) { this . oldName = name ; return ; } if ( type = = null ) { type = newType ; } else { type = type . getLeastSupertype ( newType ) ; } typesSet . set ( getIntForType ( newType ) ) ; } } JSType propType = ownerType . getPropertyType ( propName ) ; if ( propType instanceof FunctionType ) { return ( FunctionType ) propType ; } / / If it ' s not , then check to see if it ' s implemented / / on an implemented interface . return null ; }", "fixed_code": "for ( Property p : propertyMap . values ( ) ) { if ( ! p . skipAmbiguating ) { + numRenamedPropertyNames ; propsByFreq . add ( p ) ; } else { + numSkippedPropertyNames ; if ( typesRelatedToSet . intersects ( prop . typesSet ) ) { return false ; } return ! prop . relatedTypesSet . intersects ( typesInSet ) ; } public void addNode ( Property prop ) { typesInSet . or ( prop . typesSet ) ; typesRelatedToSet . or ( prop . relatedTypesSet ) ; } private class Property { final String oldName ; String newName ; int numOccurrences ; boolean skipAmbiguating ; JSTypeBitSet typesSet = new JSTypeBitSet ( intForType . size ( ) ) ; JSTypeBitSet relatedTypesSet = new JSTypeBitSet ( intForType . size ( ) ) ; Property ( String name ) { this . oldName = name ; return ; } int typeInt = getIntForType ( newType ) ; if ( ! typesSet . get ( typeInt ) ) { computeRelatedTypes ( newType ) ; typesSet . set ( typeInt ) ; relatedTypesSet . or ( getRelatedTypesOnNonUnion ( newType ) ) ; } } } JSType propType = ownerType . getPropertyType ( propName ) ; if ( propType instanceof FunctionType ) { return ( FunctionType ) propType ; } else { / / If it ' s not , then check to see if it ' s implemented / / on an implemented interface . for ( ObjectType iface : ownerType . getCtorImplementedInterfaces ( ) ) { propType = iface . getPropertyType ( propName ) ; if ( propType instanceof FunctionType ) { return ( FunctionType ) propType ; } } } return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_134"}
{"buggy_code": "for ( Node child : node . children ( ) ) { if ( NodeUtil . isThis ( child ) ) { Node newName = Node . newString ( Token . NAME , name ) ; node . replaceChild ( child , newName ) ; } else { replaceReferencesToThis ( child , name ) ; return super . hasProperty ( name ) | | \" prototype \" . equals ( name ) ; } @ Override public JSType getPropertyType ( String name ) { if ( \" prototype \" . equals ( name ) ) { ObjectType objType = type . toObjectType ( ) ; if ( objType ! = null ) { return setPrototype ( new FunctionPrototypeType ( registry , this , objType , isNativeObjectType ( ) ) ) ;", "fixed_code": "for ( Node child : node . children ( ) ) { if ( NodeUtil . isThis ( child ) ) { Node newName = Node . newString ( Token . NAME , name ) ; newName . setJSType ( child . getJSType ( ) ) ; node . replaceChild ( child , newName ) ; } else { replaceReferencesToThis ( child , name ) ; return super . hasProperty ( name ) | | \" prototype \" . equals ( name ) ; } @ Override public boolean hasOwnProperty ( String name ) { return super . hasOwnProperty ( name ) | | \" prototype \" . equals ( name ) ; } @ Override public JSType getPropertyType ( String name ) { if ( \" prototype \" . equals ( name ) ) { ObjectType objType = type . toObjectType ( ) ; if ( objType ! = null ) { if ( objType . equals ( prototype ) ) { return true ; } return setPrototype ( new FunctionPrototypeType ( registry , this , objType , isNativeObjectType ( ) ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_135"}
{"buggy_code": "Node param = condition . getLastChild ( ) ; if ( callee . getType ( ) = = GETPROP & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; if ( paramType ! = null ) { Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ; if ( left . getType ( ) = = NAME & & \" goog \" . equals ( left . getString ( ) ) & & if ( restricter ! = null ) { return restrictParameter ( param , paramType , blindScope , restricter , outcome ) ; } } } } return scope ; } else { StaticSlot < JSType > var = scope . getSlot ( varName ) ; if ( var ! = null & & ! ( var . isTypeInferred ( ) & & unflowableVarNames . contains ( varName ) ) ) { / / There are two situations where we don ' t want to use type information / / from the scope , even if we have it . / / 1 ) The var is escaped in a weird way , e . g . , / / function f ( ) { var x = 3 ; function g ( ) { x = null } ( x ) ; } / / 2 ) We ' re reading type information from another scope for an / / inferred variable . / / var t = null ; function f ( ) { ( t ) ; } type = var . getType ( ) ; if ( type = = null ) { type = getNativeType ( UNKNOWN_TYPE ) ; } } }", "fixed_code": "Node param = condition . getLastChild ( ) ; if ( callee . getType ( ) = = GETPROP & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ; if ( left . getType ( ) = = NAME & & \" goog \" . equals ( left . getString ( ) ) & & if ( restricter ! = null ) { return restrictParameter ( param , paramType , blindScope , restricter , outcome ) ; } } } return scope ; } else { StaticSlot < JSType > var = scope . getSlot ( varName ) ; if ( var ! = null ) { / / There are two situations where we don ' t want to use type information / / from the scope , even if we have it . / / 1 ) The var is escaped in a weird way , e . g . , / / function f ( ) { var x = 3 ; function g ( ) { x = null } ( x ) ; } boolean isInferred = var . isTypeInferred ( ) ; boolean unflowable = isInferred & & unflowableVarNames . contains ( varName ) ; / / 2 ) We ' re reading type information from another scope for an / / inferred variable . / / var t = null ; function f ( ) { ( t ) ; } boolean nonLocalInferredSlot = isInferred & & syntacticScope . getParent ( ) ! = null & & var = = syntacticScope . getParent ( ) . getSlot ( varName ) ; if ( ! unflowable & & ! nonLocalInferredSlot ) { type = var . getType ( ) ; if ( type = = null ) { type = getNativeType ( UNKNOWN_TYPE ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_138"}
{"buggy_code": "} break ; } } * to : * var f = function ( ) { } ; / / Prepare a spot for the function . / / Prepare the function / / Move the function", "fixed_code": "} break ; case Token . FUNCTION : normalizeFunctionDeclaration ( n ) ; break ; } } * to : * var f = function ( ) { } ; private void normalizeFunctionDeclaration ( Node n ) { Preconditions . checkState ( n . getType ( ) = = Token . FUNCTION ) ; if ( ! NodeUtil . isFunctionAnonymous ( n ) & & ! NodeUtil . isHoistedFunctionDeclaration ( n ) ) { rewriteFunctionDeclaration ( n ) ; } } private void rewriteFunctionDeclaration ( Node n ) { / / Prepare a spot for the function . Node oldNameNode = n . getFirstChild ( ) ; Node fnNameNode = oldNameNode . cloneNode ( ) ; Node var = new Node ( Token . VAR , fnNameNode , n . getLineno ( ) , n . getCharno ( ) ) ; var . copyInformationFrom ( n ) ; / / Prepare the function oldNameNode . setString ( \" \" ) ; / / Move the function Node parent = n . getParent ( ) ; parent . replaceChild ( n , var ) ; fnNameNode . addChildToFront ( n ) ; reportCodeChange ( \" Function declaration \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_139"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_14"}
{"buggy_code": "case Token . GETELEM : return true ; / / Anonymous functions definitions are not changed by side - effects , / / and named functions are not part of expressions . } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { private static Collection < Definition > getCallableDefinitions ( DefinitionProvider definitionProvider , Node name ) { List < Definition > result = Lists . newArrayList ( ) ; if ( ! NodeUtil . isGetProp ( name ) & & ! NodeUtil . isName ( name ) ) { return null ; } Collection < Definition > decls = definitionProvider . getDefinitionsReferencedAt ( name ) ; if ( decls = = null ) { } return result ; }", "fixed_code": "case Token . GETELEM : return true ; case Token . FUNCTION : / / Anonymous functions definitions are not changed by side - effects , / / and named functions are not part of expressions . Preconditions . checkState ( NodeUtil . isAnonymousFunction ( n ) ) ; return false ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { private static Collection < Definition > getCallableDefinitions ( DefinitionProvider definitionProvider , Node name ) { if ( NodeUtil . isGetProp ( name ) | | NodeUtil . isName ( name ) ) { List < Definition > result = Lists . newArrayList ( ) ; Collection < Definition > decls = definitionProvider . getDefinitionsReferencedAt ( name ) ; if ( decls = = null ) { } return result ; } else if ( name . getType ( ) = = Token . OR | | name . getType ( ) = = Token . HOOK ) { Node firstVal ; if ( name . getType ( ) = = Token . HOOK ) { firstVal = name . getFirstChild ( ) . getNext ( ) ; } else { firstVal = name . getFirstChild ( ) ; }  Collection < Definition > defs1 = getCallableDefinitions ( definitionProvider , firstVal ) ; Collection < Definition > defs2 = getCallableDefinitions ( definitionProvider , firstVal . getNext ( ) ) ; if ( defs1 ! = null & & defs2 ! = null ) { defs1 . addAll ( defs2 ) ; return defs1 ; } else { return null ; } } else { return null ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_141"}
{"buggy_code": "} else if ( defValue . length ( ) > 1 & & ( ( defValue . charAt ( 0 ) = = ' \\ ' ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ ' ' ) ) ) { / / If the value starts and ends with a single quote , / / we assume that it ' s a string . String maybeStringVal = Node exprBody = node . getFirstChild ( ) ; if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( exprBody ) ) { changeProxy . replaceWith ( parent , node , getSideEffectNodes ( exprBody ) ) ; } }", "fixed_code": "} else if ( defValue . length ( ) > 1 & & ( ( defValue . charAt ( 0 ) = = ' \\ ' ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ ' ' ) | | ( defValue . charAt ( 0 ) = = ' \\ \" ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ \" ' ) ) ) { / / If the value starts and ends with a single quote , / / we assume that it ' s a string . String maybeStringVal = Node exprBody = node . getFirstChild ( ) ; if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( exprBody ) | | exprBody . getType ( ) = = Token . NEW | | exprBody . getType ( ) = = Token . CALL ) { changeProxy . replaceWith ( parent , node , getSideEffectNodes ( exprBody ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_143"}
{"buggy_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; for ( int i = 0 ; i < dim ; i + + ) { weightMatrix . setEntry ( i , i , weight [ i ] ) ; } } private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "fixed_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = new DiagonalMatrix ( weight ) ; } private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_144"}
{"buggy_code": "private final Scope scope ; private JSType returnType = null ; private List < ObjectType > implementedInterfaces = null ; private ObjectType baseType = null ; private ObjectType thisType = null ; FunctionTypeBuilder inferReturnType ( @ Nullable JSDocInfo info ) { returnType = info ! = null & & info . hasReturnType ( ) ? info . getReturnType ( ) . evaluate ( scope , typeRegistry ) : typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; if ( templateTypeName ! = null & & returnType . restrictByNotNullOrUndefined ( ) . isTemplateType ( ) ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; } * If we haven ' t found a return value yet , try to look at the \" return \" * statements in the function . public FunctionBuilder withInferredReturnType ( JSType returnType ) { FunctionType cloneWithNewReturnType ( JSType newReturnType , boolean inferred ) { return new FunctionType ( registry , null , null , new ArrowType ( registry , call . parameters , newReturnType , inferred ) , typeOfThis , null , false , false ) ;", "fixed_code": "private final Scope scope ; private JSType returnType = null ; private boolean returnTypeInferred = false ; private List < ObjectType > implementedInterfaces = null ; private ObjectType baseType = null ; private ObjectType thisType = null ; FunctionTypeBuilder inferReturnType ( @ Nullable JSDocInfo info ) { returnType = info ! = null & & info . hasReturnType ( ) ? info . getReturnType ( ) . evaluate ( scope , typeRegistry ) : null ; if ( templateTypeName ! = null & & returnType ! = null & & returnType . restrictByNotNullOrUndefined ( ) . isTemplateType ( ) ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; } * If we haven ' t found a return value yet , try to look at the \" return \" * statements in the function . FunctionTypeBuilder inferReturnStatements ( @ Nullable Node functionBlock ) { if ( functionBlock = = null | | compiler . getInput ( sourceName ) . isExtern ( ) ) { return this ; } Preconditions . checkArgument ( functionBlock . getType ( ) = = Token . BLOCK ) ; if ( returnType = = null ) { boolean hasNonEmptyReturns = false ; List < Node > worklist = Lists . newArrayList ( functionBlock ) ; while ( ! worklist . isEmpty ( ) ) { Node current = worklist . remove ( worklist . size ( ) - 1 ) ; int cType = current . getType ( ) ; if ( cType = = Token . RETURN & & current . getFirstChild ( ) ! = null | | cType = = Token . THROW ) { hasNonEmptyReturns = true ; break ; } else if ( NodeUtil . isStatementBlock ( current ) | | NodeUtil . isControlStructure ( current ) ) { for ( Node child = current . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { worklist . add ( child ) ; } } } if ( ! hasNonEmptyReturns ) { returnType = typeRegistry . getNativeType ( VOID_TYPE ) ; returnTypeInferred = true ; } } return this ; } public FunctionBuilder withReturnType ( JSType returnType , boolean inferred ) { this . returnType = returnType ; this . inferredReturnType = inferred ; return this ; } public FunctionBuilder withInferredReturnType ( JSType returnType ) { FunctionType cloneWithNewReturnType ( JSType newReturnType , boolean inferred ) { return new FunctionType ( registry , null , source , new ArrowType ( registry , call . parameters , newReturnType , inferred ) , typeOfThis , null , false , false ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_144"}
{"buggy_code": "* labels ) . private boolean isOneExactlyFunctionOrDo ( Node n ) { / / For labels with block children , we need to ensure that a / / labeled FUNCTION or DO isn ' t generated when extraneous BLOCKs / / are skipped . / / Either a empty statement or an block with more than one child , / / way it isn ' t a FUNCTION or DO . return ( n . getType ( ) = = Token . FUNCTION | | n . getType ( ) = = Token . DO ) ; }", "fixed_code": "* labels ) . private boolean isOneExactlyFunctionOrDo ( Node n ) { if ( n . getType ( ) = = Token . LABEL ) { Node labeledStatement = n . getLastChild ( ) ; if ( labeledStatement . getType ( ) ! = Token . BLOCK ) { return isOneExactlyFunctionOrDo ( labeledStatement ) ; } else { / / For labels with block children , we need to ensure that a / / labeled FUNCTION or DO isn ' t generated when extraneous BLOCKs / / are skipped . if ( getNonEmptyChildCount ( n , 2 ) = = 1 ) { return isOneExactlyFunctionOrDo ( getFirstNonEmptyChild ( n ) ) ; } else { / / Either a empty statement or an block with more than one child , / / way it isn ' t a FUNCTION or DO . return false ; } } } else { return ( n . getType ( ) = = Token . FUNCTION | | n . getType ( ) = = Token . DO ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_145"}
{"buggy_code": "/ / other types switch ( this . testForEquality ( that ) ) { case TRUE : return new TypePair ( null , null ) ; case FALSE : case UNKNOWN :", "fixed_code": "/ / other types switch ( this . testForEquality ( that ) ) { case TRUE : JSType noType = getNativeType ( JSTypeNative . NO_TYPE ) ; return new TypePair ( noType , noType ) ; case FALSE : case UNKNOWN :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_146"}
{"buggy_code": "if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } / / To satisfy normalization constraints , the type checking must be / / added after any inner function declarations . for ( Node paramType : funType . getParameters ( ) ) { / / Can this ever happen ?", "fixed_code": "if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN | | pType = = Token . OBJECTLIT ) ) { return false ; } } / / To satisfy normalization constraints , the type checking must be / / added after any inner function declarations . for ( Node next = block . getFirstChild ( ) ; next ! = null & & NodeUtil . isFunctionDeclaration ( next ) ; next = next . getNext ( ) ) { insertionPoint = next ; } for ( Node paramType : funType . getParameters ( ) ) { / / Can this ever happen ?", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_147"}
{"buggy_code": "case Token . ARRAYLIT : typeNameString = \" object \" ; break ; case Token . NAME : / / We assume here that programs don ' t change the value of the / / keyword undefined to something other than the value undefined . public class SourceMap { int id ; void appendTo ( Appendable out ) throws IOException { out . append ( \" [ \" ) ; out . append ( sourceFile ) ; / / The source file rarely changes , so cache the escaped string . out . append ( \" , \" ) ; out . append ( String . valueOf ( originalPosition . getLineNumber ( ) ) ) ; out . append ( \" , \" ) ; out . append ( String . valueOf ( originalPosition . getCharacterIndex ( ) ) ) ; if ( originalName ! = null ) { out . append ( \" , \" ) ; out . append ( originalName ) ; } out . append ( \" ] \" ) ; } } / / Add the mappings themselves . for ( Mapping mapping : mappings ) { mapping . appendTo ( out ) ; out . append ( \" \\ n \" ) ; } } / / Mark any unused mappings . / / Renumber used mappings and keep track of the last line . / / Adjust for the prefix . private class LineMapper { / / The destination . private final Appendable out ; private int line ; private int col ; / / Whether the current line has had a value written yet . private boolean firstChar = true ; private final static String UNMAPPED_STRING = \" - 1 \" ; private final static int UNMAPPED = - 1 ; LineMapper ( Appendable out ) { this . out = out ; / / Prevent the creation of unnecessary temporary stings for often / / repeated values . / / Append the line mapping entries . void appendLineMappings ( ) throws IOException { / / Start the first line . openLine ( ) ; / / And close the final line . / / The last line and column written / / Append the line mapping entries . / / The mapping list is ordered as a pre - order traversal . The mapping / / positions give us enough information to rebuild the stack and this / / closed in the reverse order of when they encountered . while ( ! stack . isEmpty ( ) & & ! isOverlapped ( stack . peek ( ) , m ) ) { Mapping previous = stack . pop ( ) ; writeClosedMapping ( previous ) ; } / / Any gaps between the current line position and the start of the / / current mapping belong to the parent . Mapping parent = stack . peek ( ) ; writeCharsBetween ( parent , m ) ; stack . push ( m ) ; } / / mappings in the reverse order of when they encountered . while ( ! stack . isEmpty ( ) ) { Mapping m = stack . pop ( ) ; writeClosedMapping ( m ) ; } closeLine ( ) ; } private void openLine ( ) throws IOException { out . append ( \" [ \" ) ; this . firstChar = true ; } private void closeLine ( ) throws IOException { out . append ( \" ] \\ n \" ) ; } private void addCharEntry ( String id ) throws IOException { if ( firstChar ) { firstChar = false ; } else { out . append ( \" , \" ) ; } out . append ( id ) ; } private void writeClosedMapping ( Mapping m ) throws IOException { int nextLine = getAdjustedLine ( m . endPosition ) ; int nextCol = getAdjustedCol ( m . endPosition ) ; / / If this anything remaining in this mapping beyond the / / current line and column position , write it out now . if ( line < nextLine | | ( line = = nextLine & & col < nextCol ) ) { writeCharsUpTo ( nextLine , nextCol , m . id ) ; } } private void writeCharsBetween ( Mapping prev , Mapping next ) throws IOException { int nextLine = getAdjustedLine ( next . startPosition ) ; int nextCol = getAdjustedCol ( next . startPosition ) ; / / If the previous value is null , no mapping exists . int id = ( prev ! = null ) ? prev . id : UNMAPPED ; writeCharsUpTo ( nextLine , nextCol , id ) ; } private void writeCharsUpTo ( int nextLine , int nextCol , int id ) throws IOException { Preconditions . checkState ( line < = nextLine , \" \" ) ; Preconditions . checkState ( line < nextLine | | col < = nextCol ) ; if ( line = = nextLine & & col = = nextCol ) { / / Nothing to do . return ; } String idString = ( id = = UNMAPPED ) ? UNMAPPED_STRING : String . valueOf ( id ) ; for ( int i = line ; i < = nextLine ; i + + ) { if ( i = = nextLine ) { for ( int j = col ; j < nextCol ; j + + ) { addCharEntry ( idString ) ; } break ; } closeLine ( ) ; openLine ( ) ; } line = nextLine ; col = nextCol ;", "fixed_code": "case Token . ARRAYLIT : typeNameString = \" object \" ; break ; case Token . VOID : typeNameString = \" undefined \" ; break ; case Token . NAME : / / We assume here that programs don ' t change the value of the / / keyword undefined to something other than the value undefined . public class SourceMap { private final static int UNMAPPED = - 1 ; int id = UNMAPPED ; boolean used = false ; } private class MappingWriter { private String lastSourceFile = null ; private String lastSourceFileEscaped = null ; private int lastLine = 0 ; private String lastLineString = String . valueOf ( 0 ) ; private void appendMappingTo ( Mapping m , Appendable out ) throws IOException { out . append ( \" [ \" ) ; String sourceFile = m . sourceFile ; / / The source file rarely changes , so cache the escaped string . String escapedSourceFile ; if ( lastSourceFile ! = sourceFile ) { / / yes , s1 ! = s2 , not ! s1 . equals ( s2 ) lastSourceFile = sourceFile ; lastSourceFileEscaped = escapeString ( sourceFile ) ; } escapedSourceFile = lastSourceFileEscaped ; out . append ( escapedSourceFile ) ; out . append ( \" , \" ) ; int line = m . originalPosition . getLineNumber ( ) ; if ( line ! = lastLine ) { lastLineString = String . valueOf ( line ) ; } String lineValue = lastLineString ; out . append ( lineValue ) ; out . append ( \" , \" ) ; out . append ( String . valueOf ( m . originalPosition . getCharacterIndex ( ) ) ) ; if ( m . originalName ! = null ) { out . append ( \" , \" ) ; out . append ( escapeString ( m . originalName ) ) ; } out . append ( \" ] \\ n \" ) ; }  void appendMappings ( Appendable out ) throws IOException { for ( Mapping m : mappings ) { if ( m . used ) { appendMappingTo ( m , out ) ; } } } } / / Add the mappings themselves . ( new MappingWriter ( ) ) . appendMappings ( out ) ; } private int prepMappings ( ) throws IOException { / / Mark any unused mappings . ( new MappingTraversal ( ) ) . traverse ( new UsedMappingCheck ( ) ) ; / / Renumber used mappings and keep track of the last line . int id = 0 ; int maxLine = 0 ; for ( Mapping m : mappings ) { if ( m . used ) { m . id = id + + ; int endPositionLine = m . endPosition . getLineNumber ( ) ; maxLine = Math . max ( maxLine , endPositionLine ) ; } } / / Adjust for the prefix . return maxLine + prefixPosition . getLineNumber ( ) ; } private class LineMapper implements MappingVisitor { / / The destination . private final Appendable out ;  / / Whether the current line has had a value written yet . private boolean firstChar = true ; private final static String UNMAPPED_STRING = \" - 1 \" ; private int lastId = UNMAPPED ; private String lastIdString = UNMAPPED_STRING ; LineMapper ( Appendable out ) { this . out = out ; public void visit ( Mapping m , int line , int col , int nextLine , int nextCol ) throws IOException { int id = ( m ! = null ) ? m . id : UNMAPPED ; if ( lastId ! = id ) { / / Prevent the creation of unnecessary temporary stings for often / / repeated values . lastIdString = ( id = = UNMAPPED ) ? UNMAPPED_STRING : String . valueOf ( id ) ; lastId = id ; } String idString = lastIdString ; for ( int i = line ; i < = nextLine ; i + + ) { if ( i = = nextLine ) { for ( int j = col ; j < nextCol ; j + + ) { addCharEntry ( idString ) ; } break ; } closeLine ( ) ; openLine ( ) ; } } / / Append the line mapping entries . void appendLineMappings ( ) throws IOException { / / Start the first line . openLine ( ) ; ( new MappingTraversal ( ) ) . traverse ( this ) ; / / And close the final line . closeLine ( ) ; } private void openLine ( ) throws IOException { if ( out ! = null ) { out . append ( \" [ \" ) ; this . firstChar = true ; } } private void closeLine ( ) throws IOException { if ( out ! = null ) { out . append ( \" ] \\ n \" ) ; } } private void addCharEntry ( String id ) throws IOException { if ( out ! = null ) { if ( firstChar ) { firstChar = false ; } else { out . append ( \" , \" ) ; } out . append ( id ) ; } } } private class UsedMappingCheck implements MappingVisitor { @ Override public void visit ( Mapping m , int line , int col , int nextLine , int nextCol ) throws IOException { if ( m ! = null ) { m . used = true ; } } } private interface MappingVisitor { void visit ( Mapping m , int line , int col , int endLine , int endCol ) throws IOException ; } private class MappingTraversal { / / The last line and column written private int line ; private int col ; MappingTraversal ( ) { } / / Append the line mapping entries . void traverse ( MappingVisitor v ) throws IOException { Preconditions . checkState ( ! mappings . isEmpty ( ) ) ; / / The mapping list is ordered as a pre - order traversal . The mapping / / positions give us enough information to rebuild the stack and this / / closed in the reverse order of when they encountered . while ( ! stack . isEmpty ( ) & & ! isOverlapped ( stack . peek ( ) , m ) ) { Mapping previous = stack . pop ( ) ; maybeVisit ( v , previous ) ; } / / Any gaps between the current line position and the start of the / / current mapping belong to the parent . Mapping parent = stack . peek ( ) ; maybeVisitParent ( v , parent , m ) ; stack . push ( m ) ; } / / mappings in the reverse order of when they encountered . while ( ! stack . isEmpty ( ) ) { Mapping m = stack . pop ( ) ; maybeVisit ( v , m ) ; } } private void maybeVisit ( MappingVisitor v , Mapping m ) throws IOException { int nextLine = getAdjustedLine ( m . endPosition ) ; int nextCol = getAdjustedCol ( m . endPosition ) ; / / If this anything remaining in this mapping beyond the / / current line and column position , write it out now . if ( line < nextLine | | ( line = = nextLine & & col < nextCol ) ) { visit ( v , m , nextLine , nextCol ) ; } } private void maybeVisitParent ( MappingVisitor v , Mapping parent , Mapping m ) throws IOException { int nextLine = getAdjustedLine ( m . startPosition ) ; int nextCol = getAdjustedCol ( m . startPosition ) ; / / If the previous value is null , no mapping exists . Preconditions . checkState ( line < nextLine | | col < = nextCol ) ; if ( line < nextLine | | ( line = = nextLine & & col < nextCol ) ) { visit ( v , parent , nextLine , nextCol ) ; } } private void visit ( MappingVisitor v , Mapping m , int nextLine , int nextCol ) throws IOException { Preconditions . checkState ( line < = nextLine ) ; Preconditions . checkState ( line < nextLine | | col < nextCol ) ; if ( line = = nextLine & & col = = nextCol ) { / / Nothing to do . Preconditions . checkState ( false ) ; return ; } v . visit ( m , line , col , nextLine , nextCol ) ; line = nextLine ; col = nextCol ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_148"}
{"buggy_code": "* @ return mock object public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; }", "fixed_code": "* @ return mock object public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_148"}
{"buggy_code": "options . setCodingConvention ( config . codingConvention ) ; options . setSummaryDetailLevel ( config . summaryDetailLevel ) ; inputCharset = getInputCharset ( ) ; if ( config . jsOutputFile . length ( ) > 0 ) { Result result ; setRunOptions ( options ) ; if ( inputCharset = = Charsets . UTF_8 ) { options . outputCharset = Charsets . US_ASCII ; } else { options . outputCharset = inputCharset ; } boolean writeOutputToFile = ! options . jsOutputFile . isEmpty ( ) ; if ( writeOutputToFile ) { * be a supported charset . * @ throws FlagUsageException if flag is not a valid Charset name . protected List < JSSourceFile > createExterns ( ) throws FlagUsageException , IOException { } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; } builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; Charset charset = options . outputCharset ; builder . setOutputCharset ( charset ) ; return builder . build ( ) ; * Charset to use when generating code . If null , then output ASCII . * This needs to be a string because CompilerOptions is serializable . public Charset outputCharset ;", "fixed_code": "options . setCodingConvention ( config . codingConvention ) ; options . setSummaryDetailLevel ( config . summaryDetailLevel ) ; options . outputCharset = getOutputCharset ( ) ; inputCharset = getInputCharset ( ) ; if ( config . jsOutputFile . length ( ) > 0 ) { Result result ; setRunOptions ( options ) ; boolean writeOutputToFile = ! options . jsOutputFile . isEmpty ( ) ; if ( writeOutputToFile ) { * be a supported charset . * @ throws FlagUsageException if flag is not a valid Charset name . private String getOutputCharset ( ) throws FlagUsageException { if ( ! config . charset . isEmpty ( ) ) { if ( ! Charset . isSupported ( config . charset ) ) { throw new FlagUsageException ( config . charset + \" is not a valid charset name . \" ) ; } return config . charset ; } return \" US - ASCII \" ; } protected List < JSSourceFile > createExterns ( ) throws FlagUsageException , IOException { } options . closurePass = flags . process_closure_primitives ; return options ; } builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; Charset charset = options . outputCharset ! = null ? Charset . forName ( options . outputCharset ) : null ; builder . setOutputCharset ( charset ) ; return builder . build ( ) ; * Charset to use when generating code . If null , then output ASCII . * This needs to be a string because CompilerOptions is serializable . String outputCharset ; public void setOutputCharset ( String charsetName ) { this . outputCharset = charsetName ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_149"}
{"buggy_code": "return true ; } if ( n . isDelProp ( ) ) { return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "fixed_code": "return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "return ; } attachLiteralTypes ( n ) ; switch ( n . getType ( ) ) { case Token . FUNCTION : if ( parent . getType ( ) = = Token . NAME ) { return ; } defineDeclaredFunction ( n , parent ) ; break ; case Token . CATCH : defineCatch ( n , parent ) ; break ; case Token . VAR : defineVar ( n , parent ) ; break ; } }", "fixed_code": "return ; } super . visit ( t , n , parent ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_150"}
{"buggy_code": "private String output_manifest = \" \" ; / / Our own option parser to be backwards - compatible . / / It needs to be public because of the crazy reflection that args4j does . private final Flags flags = new Flags ( ) ; private boolean isConfigValid = false ; isConfigValid = false ; } if ( ! isConfigValid | | flags . display_help ) { isConfigValid = false ;", "fixed_code": "\" a manifest for each module . \" ) private String output_manifest = \" \" ; @ Option ( name = \" - - version \" , usage = \" Prints the compiler version to stderr . \" ) private boolean version = false ; / / Our own option parser to be backwards - compatible . / / It needs to be public because of the crazy reflection that args4j does . private final Flags flags = new Flags ( ) ; private static final String configResource = \" com . google . javascript . jscomp . parsing . ParserConfig \" ; private boolean isConfigValid = false ; isConfigValid = false ; } if ( flags . version ) { ResourceBundle config = ResourceBundle . getBundle ( configResource ) ; err . println ( \" Closure Compiler ( http : / / code . google . com / p / closure / compiler ) \\ n \" + \" Version : \" + config . getString ( \" compiler . version \" ) + \" \\ n \" + \" Built on : \" + config . getString ( \" compiler . date \" ) ) ; err . flush ( ) ; } if ( ! isConfigValid | | flags . display_help ) { isConfigValid = false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_151"}
{"buggy_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression , / / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | baseType . isUnknownType ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } boolean replacedPrototype = prototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "fixed_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; if ( qVarType ! = null & & rhsValue ! = null & & rhsValue . getType ( ) = = Token . OBJECTLIT ) { typeRegistry . resetImplicitPrototype ( rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; } else if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression , / / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } PrototypeObjectType oldPrototype = this . prototype ; boolean replacedPrototype = oldPrototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; if ( oldPrototype ! = null ) { / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . oldPrototype . setOwnerFunction ( null ) ; } if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_152"}
{"buggy_code": "/ / Warning about typeOfThis if it doesn ' t resolve to an ObjectType / / is handled further upstream . / / TODO ( nicksantos ) : Handle this correctly if we have a UnionType . typeOfThis = ( ObjectType ) safeResolve ( typeOfThis , t , scope ) ; boolean changed = false ; ImmutableList . Builder < ObjectType > resolvedInterfaces =", "fixed_code": "/ / Warning about typeOfThis if it doesn ' t resolve to an ObjectType / / is handled further upstream . / / TODO ( nicksantos ) : Handle this correctly if we have a UnionType . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; } boolean changed = false ; ImmutableList . Builder < ObjectType > resolvedInterfaces =", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_152"}
{"buggy_code": "private final class DuplicateDeclarationHandler implements SyntacticScopeCreator . RedeclarationHandler { @ Override public void onRedeclaration ( Scope s , String name , Node n , Node parent , Node gramps , Node nodeWithLineNumber ) { Preconditions . checkState ( n . getType ( ) = = Token . NAME ) ; Var v = s . getVar ( name ) ; / / We allow variables to be duplicate declared if one / / declaration appears in source and the other in externs . / / This deals with issues where a browser built - in is declared / / in one browser but not in another . / / If name is \" arguments \" , Var maybe null . if ( v ! = null & & v . getParentNode ( ) . getType ( ) = = Token . CATCH ) { name ) ; compiler . report ( JSError . make ( NodeUtil . getSourceName ( nodeWithLineNumber ) , nodeWithLineNumber , CATCH_BLOCK_VAR_ERROR , name ) ) ; } else if ( v ! = null & & parent . getType ( ) = = Token . FUNCTION ) { if ( v . getParentNode ( ) . getType ( ) = = Token . VAR ) { } else if ( parent . getType ( ) = = Token . VAR ) { Preconditions . checkState ( parent . hasOneChild ( ) ) ; replaceVarWithAssignment ( n , parent , gramps ) ; } } import com . google . javascript . rhino . JSDocInfo ; import com . google . javascript . rhino . Node ; import com . google . javascript . rhino . Token ; import com . google . javascript . rhino . jstype . JSType ; interface RedeclarationHandler { void onRedeclaration ( Scope s , String name , Node n , Node parent , Node gramps , Node nodeWithLineNumber ) ; } private class DefaultRedeclarationHandler implements RedeclarationHandler { public void onRedeclaration ( Scope s , String name , Node n , Node parent , Node gramps , Node nodeWithLineNumber ) { / / Don ' t allow multiple variables to be declared at the top level scope if ( scope . isGlobal ( ) ) { * @ param n The node corresponding to the variable name . * @ param declaredType The variable ' s type , according to JSDoc private void declareVar ( String name , Node n , Node parent , Node gramps , JSType declaredType , Node nodeWithLineNumber ) { if ( scope . isDeclared ( name , false ) | | ( scope . isLocal ( ) & & name . equals ( ARGUMENTS ) ) ) { redeclarationHandler . onRedeclaration ( scope , name , n , parent , gramps , nodeWithLineNumber ) ; } else { scope . declare ( name , n , declaredType , compiler . getInput ( sourceName ) ) ; } } }", "fixed_code": "private final class DuplicateDeclarationHandler implements SyntacticScopeCreator . RedeclarationHandler { private Set < Var > hasOkDuplicateDeclaration = Sets . newHashSet ( ) ; @ Override public void onRedeclaration ( Scope s , String name , Node n , CompilerInput input ) { Preconditions . checkState ( n . getType ( ) = = Token . NAME ) ; Node parent = n . getParent ( ) ; Var v = s . getVar ( name ) ; if ( v ! = null & & s . isGlobal ( ) ) { / / We allow variables to be duplicate declared if one / / declaration appears in source and the other in externs . / / This deals with issues where a browser built - in is declared / / in one browser but not in another . if ( v . isExtern ( ) & & ! input . isExtern ( ) ) { if ( hasOkDuplicateDeclaration . add ( v ) ) { return ; } } } / / If name is \" arguments \" , Var maybe null . if ( v ! = null & & v . getParentNode ( ) . getType ( ) = = Token . CATCH ) { name ) ; compiler . report ( JSError . make ( input . getName ( ) , n , CATCH_BLOCK_VAR_ERROR , name ) ) ; } else if ( v ! = null & & parent . getType ( ) = = Token . FUNCTION ) { if ( v . getParentNode ( ) . getType ( ) = = Token . VAR ) { } else if ( parent . getType ( ) = = Token . VAR ) { Preconditions . checkState ( parent . hasOneChild ( ) ) ; replaceVarWithAssignment ( n , parent , parent . getParent ( ) ) ; } } import com . google . javascript . rhino . JSDocInfo ; import com . google . javascript . rhino . Node ; import com . google . javascript . rhino . Token ; interface RedeclarationHandler { void onRedeclaration ( Scope s , String name , Node n , CompilerInput input ) ; } private class DefaultRedeclarationHandler implements RedeclarationHandler { public void onRedeclaration ( Scope s , String name , Node n , CompilerInput input ) { Node parent = n . getParent ( ) ; / / Don ' t allow multiple variables to be declared at the top level scope if ( scope . isGlobal ( ) ) { * @ param n The node corresponding to the variable name . * @ param declaredType The variable ' s type , according to JSDoc private void declareVar ( Node n ) { Preconditions . checkState ( n . getType ( ) = = Token . NAME ) ; CompilerInput input = compiler . getInput ( sourceName ) ; String name = n . getString ( ) ; if ( scope . isDeclared ( name , false ) | | ( scope . isLocal ( ) & & name . equals ( ARGUMENTS ) ) ) { redeclarationHandler . onRedeclaration ( scope , name , n , input ) ; } else { scope . declare ( name , n , null , input ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_153"}
{"buggy_code": "\" original : { 2 } \\ n \" + \" override : { 3 } \" ) ; static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType . warning ( \" JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH \" , \" mismatch of the { 0 } property type and the type \" + \" of the property it overrides from interface { 1 } \\ n \" + \" original : { 2 } \\ n \" + \" override : { 3 } \" ) ; static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType . warning ( \" JSC_UNKNOWN_OVERRIDE \" , HIDDEN_SUPERCLASS_PROPERTY , HIDDEN_INTERFACE_PROPERTY , HIDDEN_SUPERCLASS_PROPERTY_MISMATCH , HIDDEN_INTERFACE_PROPERTY_MISMATCH , UNKNOWN_OVERRIDE , INTERFACE_METHOD_OVERRIDE , UNKNOWN_EXPR_TYPE , HIDDEN_INTERFACE_PROPERTY , propertyName , interfaceType . getTopMostDefiningType ( propertyName ) . toString ( ) ) ) ; } if ( interfaceHasProperty ) { JSType interfacePropType = interfaceType . getPrototype ( ) . getPropertyType ( propertyName ) ; if ( ! propertyType . canAssignTo ( interfacePropType ) ) { compiler . report ( t . makeError ( n , HIDDEN_INTERFACE_PROPERTY_MISMATCH , propertyName , interfaceType . getTopMostDefiningType ( propertyName ) . toString ( ) , interfacePropType . toString ( ) , propertyType . toString ( ) ) ) ; } } } } \" JSC_INTERFACE_METHOD_NOT_IMPLEMENTED \" , \" property { 0 } on interface { 1 } is not implemented by type { 2 } \" ) ; static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup ( INVALID_CAST , MISSING_EXTENDS_TAG_WARNING , DUP_VAR_DECLARATION , HIDDEN_PROPERTY_MISMATCH , INTERFACE_METHOD_NOT_IMPLEMENTED ) ; TypeValidator ( AbstractCompiler compiler ) { this . compiler = compiler ; prop , implementedInterface . toString ( ) , instance . toString ( ) ) ) ; } registerMismatch ( instance , implementedInterface ) ; / / Implemented , but not correctly typed } }", "fixed_code": "\" original : { 2 } \\ n \" + \" override : { 3 } \" ) ; static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType . warning ( \" JSC_UNKNOWN_OVERRIDE \" , HIDDEN_SUPERCLASS_PROPERTY , HIDDEN_INTERFACE_PROPERTY , HIDDEN_SUPERCLASS_PROPERTY_MISMATCH , UNKNOWN_OVERRIDE , INTERFACE_METHOD_OVERRIDE , UNKNOWN_EXPR_TYPE , HIDDEN_INTERFACE_PROPERTY , propertyName , interfaceType . getTopMostDefiningType ( propertyName ) . toString ( ) ) ) ; } } } \" JSC_INTERFACE_METHOD_NOT_IMPLEMENTED \" , \" property { 0 } on interface { 1 } is not implemented by type { 2 } \" ) ; static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType . warning ( \" JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH \" , \" mismatch of the { 0 } property type and the type \" + \" of the property it overrides from interface { 1 } \\ n \" + \" original : { 2 } \\ n \" + \" override : { 3 } \" ) ; static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup ( INVALID_CAST , MISSING_EXTENDS_TAG_WARNING , DUP_VAR_DECLARATION , HIDDEN_PROPERTY_MISMATCH , INTERFACE_METHOD_NOT_IMPLEMENTED , HIDDEN_INTERFACE_PROPERTY_MISMATCH ) ; TypeValidator ( AbstractCompiler compiler ) { this . compiler = compiler ; prop , implementedInterface . toString ( ) , instance . toString ( ) ) ) ; } registerMismatch ( instance , implementedInterface ) ; } else { JSType found = instance . getPropertyType ( prop ) ; JSType required = implementedInterface . getImplicitPrototype ( ) . getPropertyType ( prop ) ; found = found . restrictByNotNullOrUndefined ( ) ; required = required . restrictByNotNullOrUndefined ( ) ; if ( ! found . canAssignTo ( required ) ) { / / Implemented , but not correctly typed if ( shouldReport ) { FunctionType constructor = implementedInterface . toObjectType ( ) . getConstructor ( ) ; compiler . report ( t . makeError ( n , HIDDEN_INTERFACE_PROPERTY_MISMATCH , prop , constructor . getTopMostDefiningType ( prop ) . toString ( ) , required . toString ( ) , found . toString ( ) ) ) ; } registerMismatch ( found , required ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_154"}
{"buggy_code": "private void doInlinesForScope ( NodeTraversal t , Map < Var , ReferenceCollection > referenceMap ) { for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; / / inlining heuristics . See InlineConstantsTest . continue ; } else { inlineNonConstants ( v , referenceInfo ) ; } } } / / Any reference that is not a read of the arguments property / / consider a escape of the arguments object . private void inlineNonConstants ( Var v , ReferenceCollection referenceInfo ) { int refCount = referenceInfo . references . size ( ) ; Reference declaration = referenceInfo . references . get ( 0 ) ; Reference init = referenceInfo . getInitializingReference ( ) ; / / inline an alias of it . ( If the variable was inlined , then the / / reference data is out of sync . We ' re better off just waiting for / / the next pass . ) if ( ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { List < Reference > refs = referenceInfo . references ; public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . getType ( ) = = Token . NAME ) { Var v = t . getScope ( ) . getVar ( n . getString ( ) ) ; if ( v ! = null & & varFilter . apply ( v ) ) { addReference ( t , v , new Reference ( n , parent , t , blockStack . peek ( ) ) ) ; private final boolean isBottom ; public static class Var implements StaticSlot < JSType > { * scope . / / TODO ( johnlenz ) : Include this the list of Vars for the scope . / / TODO ( johnlenz ) : provide the type of \" Arguments \" .", "fixed_code": "private void doInlinesForScope ( NodeTraversal t , Map < Var , ReferenceCollection > referenceMap ) { boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments ( t . getScope ( ) , referenceMap ) ; for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; / / inlining heuristics . See InlineConstantsTest . continue ; } else { inlineNonConstants ( v , referenceInfo , maybeModifiedArguments ) ; } } } private boolean maybeEscapedOrModifiedArguments ( Scope scope , Map < Var , ReferenceCollection > referenceMap ) { if ( scope . isLocal ( ) ) { Var arguments = scope . getArgumentsVar ( ) ; ReferenceCollection refs = referenceMap . get ( arguments ) ; if ( refs ! = null & & ! refs . references . isEmpty ( ) ) { for ( Reference ref : refs . references ) { Node refNode = ref . getNameNode ( ) ; Node refParent = ref . getParent ( ) ; / / Any reference that is not a read of the arguments property / / consider a escape of the arguments object . if ( ! ( NodeUtil . isGet ( refParent ) & & refNode = = ref . getParent ( ) . getFirstChild ( ) & & ! isLValue ( refParent ) ) ) { return true ; } } } } return false ; } private boolean isLValue ( Node n ) { Node parent = n . getParent ( ) ; return ( parent . getType ( ) = = Token . INC | | parent . getType ( ) = = Token . DEC | | ( NodeUtil . isAssignmentOp ( parent ) & & parent . getFirstChild ( ) = = n ) ) ; } private void inlineNonConstants ( Var v , ReferenceCollection referenceInfo , boolean maybeModifiedArguments ) { int refCount = referenceInfo . references . size ( ) ; Reference declaration = referenceInfo . references . get ( 0 ) ; Reference init = referenceInfo . getInitializingReference ( ) ; / / inline an alias of it . ( If the variable was inlined , then the / / reference data is out of sync . We ' re better off just waiting for / / the next pass . ) if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { List < Reference > refs = referenceInfo . references ; public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . getType ( ) = = Token . NAME ) { Var v ; if ( n . getString ( ) . equals ( \" arguments \" ) ) { v = t . getScope ( ) . getArgumentsVar ( ) ; } else { v = t . getScope ( ) . getVar ( n . getString ( ) ) ; } if ( v ! = null & & varFilter . apply ( v ) ) { addReference ( t , v , new Reference ( n , parent , t , blockStack . peek ( ) ) ) ; private final boolean isBottom ; private Var arguments ; public static class Var implements StaticSlot < JSType > { * scope . / / TODO ( johnlenz ) : Include this the list of Vars for the scope . public static class Arguments extends Var { Arguments ( Scope scope ) { super ( false , / / no inferred \" arguments \" , / / always arguments null , / / no declaration node / / TODO ( johnlenz ) : provide the type of \" Arguments \" . null , / / no type info scope , - 1 , / / no variable index null , / / input , false , / / not a define null / / no jsdoc ) ; } @ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Arguments ) ) { return false ; } Arguments otherVar = ( Arguments ) other ; return otherVar . scope . getRootNode ( ) = = scope . getRootNode ( ) ; } @ Override public int hashCode ( ) { return System . identityHashCode ( this ) ; } } public Var getArgumentsVar ( ) { if ( arguments = = null ) { arguments = new Arguments ( this ) ; } return arguments ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_155"}
{"buggy_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final Node aliasDefinition ; private final String aliasName ; AliasedTypeNode ( Node typeReference , Node aliasDefinition , String aliasName ) { this . typeReference = typeReference ; this . aliasDefinition = aliasDefinition ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { String typeName = typeReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } }", "fixed_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final String aliasName ; AliasedTypeNode ( Node typeReference , String aliasName ) { this . typeReference = typeReference ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { typeReference . setString ( aliasName ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_16"}
{"buggy_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final String aliasName ; AliasedTypeNode ( Node typeReference , String aliasName ) { this . typeReference = typeReference ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { typeReference . setString ( aliasName ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; } }", "fixed_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final Node aliasDefinition ; private final String aliasName ; AliasedTypeNode ( Node typeReference , Node aliasDefinition , String aliasName ) { this . typeReference = typeReference ; this . aliasDefinition = aliasDefinition ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { String typeName = typeReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_16"}
{"buggy_code": "if ( merged ! = null ) { return maybeRestrictTwoNames ( blindScope , left , leftIsRefineable , merged . typeA , right , rightIsRefineable , merged . typeB ) ; } return blindScope ; } / / creating new scope return maybeRestrictTwoNames ( blindScope , left , leftIsRefineable , restrictedLeftType , right , rightIsRefineable , restrictedRightType ) ; } return blindScope ; } private FlowScope maybeRestrictName ( FlowScope blindScope , Node node , JSType originalType , JSType restrictedType ) { if ( restrictedType ! = null & & ! restrictedType . equals ( originalType ) ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , node , restrictedType ) ; return informed ; private FlowScope maybeRestrictTwoNames ( FlowScope blindScope , Node left , boolean leftIsRefineable , JSType restrictedLeftType , Node right , boolean rightIsRefineable , JSType restrictedRightType ) { boolean shouldRefineLeft = leftIsRefineable & & restrictedLeftType ! = null ; boolean shouldRefineRight = rightIsRefineable & & restrictedRightType ! = null ; if ( shouldRefineLeft | | shouldRefineRight ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; if ( shouldRefineLeft ) { boolean outcome ) { JSType type = getTypeIfRefinable ( name , blindScope ) ; if ( type ! = null ) { JSType restrictedType = type . getRestrictedTypeGivenToBooleanOutcome ( outcome ) ; FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , name , restrictedType ) ; return informed ; } return blindScope ; } * method of types to get the restricted type . public JSType getRestrictedTypeGivenToBooleanOutcome ( boolean outcome ) { BooleanLiteralSet literals = getPossibleToBooleanOutcomes ( ) ; if ( literals . contains ( outcome ) ) {", "fixed_code": "if ( merged ! = null ) { return maybeRestrictTwoNames ( blindScope , left , leftType , leftIsRefineable ? merged . typeA : null , right , rightType , rightIsRefineable ? merged . typeB : null ) ; } return blindScope ; } / / creating new scope return maybeRestrictTwoNames ( blindScope , left , leftType , leftIsRefineable ? restrictedLeftType : null , right , rightType , rightIsRefineable ? restrictedRightType : null ) ; } return blindScope ; } private FlowScope maybeRestrictName ( FlowScope blindScope , Node node , JSType originalType , JSType restrictedType ) { if ( restrictedType ! = null & & restrictedType ! = originalType ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , node , restrictedType ) ; return informed ; private FlowScope maybeRestrictTwoNames ( FlowScope blindScope , Node left , JSType originalLeftType , JSType restrictedLeftType , Node right , JSType originalRightType , JSType restrictedRightType ) { boolean shouldRefineLeft = restrictedLeftType ! = null & & restrictedLeftType ! = originalLeftType ; boolean shouldRefineRight = restrictedRightType ! = null & & restrictedRightType ! = originalRightType ; if ( shouldRefineLeft | | shouldRefineRight ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; if ( shouldRefineLeft ) { boolean outcome ) { JSType type = getTypeIfRefinable ( name , blindScope ) ; if ( type ! = null ) { return maybeRestrictName ( blindScope , name , type , type . getRestrictedTypeGivenToBooleanOutcome ( outcome ) ) ; } return blindScope ; } * method of types to get the restricted type . public JSType getRestrictedTypeGivenToBooleanOutcome ( boolean outcome ) { if ( outcome & & this = = getNativeType ( JSTypeNative . UNKNOWN_TYPE ) ) { return getNativeType ( JSTypeNative . CHECKED_UNKNOWN_TYPE ) ; } BooleanLiteralSet literals = getPossibleToBooleanOutcomes ( ) ; if ( literals . contains ( outcome ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_167"}
{"buggy_code": "data . get ( t . getScopeRoot ( ) ) . recordNonEmptyReturn ( ) ; } if ( t . getScopeDepth ( ) < = 2 ) { / / The first - order function analyzer looks at two types of variables : / / / / 1 ) Local variables that are assigned in inner scopes ( \" escaped vars \" )", "fixed_code": "data . get ( t . getScopeRoot ( ) ) . recordNonEmptyReturn ( ) ; } if ( t . getScopeDepth ( ) < = 1 ) { / / The first - order function analyzer looks at two types of variables : / / / / 1 ) Local variables that are assigned in inner scopes ( \" escaped vars \" )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_168"}
{"buggy_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "fixed_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_17"}
{"buggy_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "fixed_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_17"}
{"buggy_code": "@ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & n . getString ( ) . equals ( varName ) & & / / We make a special exception when the entire cfgNode is a chain / / of assignments , since in that case the assignment statements / / will happen after the inlining of the right hand side . / / TODO ( blickly ) : Make the SIDE_EFFECT_PREDICATE check more exact / / and remove this special case . ! ( parent . isAssign ( ) & & ( parent . getFirstChild ( ) = = n ) ) ) { / / Don ' t count lhs of top - level assignment chain numUsesWithinCfgNode + + ; } } } ; NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;", "fixed_code": "@ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & n . getString ( ) . equals ( varName ) ) { / / We make a special exception when the entire cfgNode is a chain / / of assignments , since in that case the assignment statements / / will happen after the inlining of the right hand side . / / TODO ( blickly ) : Make the SIDE_EFFECT_PREDICATE check more exact / / and remove this special case . if ( parent . isAssign ( ) & & ( parent . getFirstChild ( ) = = n ) & & isAssignChain ( parent , cfgNode ) ) { / / Don ' t count lhs of top - level assignment chain return ; } else { numUsesWithinCfgNode + + ; } } } private boolean isAssignChain ( Node child , Node ancestor ) { for ( Node n = child ; n ! = ancestor ; n = n . getParent ( ) ) { if ( ! n . isAssign ( ) ) { return false ; } } return true ; } } ; NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_170"}
{"buggy_code": "/ / See CodingConvention # getObjectLiteralCase and goog . object . reflect . / / Ignore these types of literals . ObjectType objectType = ObjectType . cast ( type ) ; if ( objectType = = null ) { return scope ; } boolean hasLendsName = n . getJSDocInfo ( ) ! = null & & n . getJSDocInfo ( ) . getLendsName ( ) ! = null ; if ( objectType . hasReferenceName ( ) & & ! hasLendsName ) { return scope ; } } / / Prototype sets are always declared . boolean inferred = true ; if ( info ! = null ) {", "fixed_code": "/ / See CodingConvention # getObjectLiteralCase and goog . object . reflect . / / Ignore these types of literals . ObjectType objectType = ObjectType . cast ( type ) ; if ( objectType = = null | | n . getBooleanProp ( Node . REFLECTED_OBJECT ) ) { return scope ; } } / / Prototype sets are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { return false ; } boolean inferred = true ; if ( info ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_171"}
{"buggy_code": "/ / Prototypes of constructors and interfaces are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { return false ; } boolean inferred = true ;", "fixed_code": "/ / Prototypes of constructors and interfaces are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { String className = qName . substring ( 0 , qName . lastIndexOf ( \" . prototype \" ) ) ; Var slot = scope . getSlot ( className ) ; JSType classType = slot = = null ? null : slot . getType ( ) ; if ( classType ! = null & & ( classType . isConstructor ( ) | | classType . isInterface ( ) ) ) { return false ; } } boolean inferred = true ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_172"}
{"buggy_code": "/ / the IN_FOR_INIT_CLAUSE one . Context rhsContext = getContextForNoInOperator ( context ) ; if ( last . getType ( ) = = type & & NodeUtil . isAssociative ( type ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else if ( NodeUtil . isAssignmentOp ( n ) & & NodeUtil . isAssignmentOp ( last ) ) { / / Assignments are the only right - associative binary operators addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; case Token . ARRAYLIT : return tryMinimizeArrayLiteral ( node ) ; default : return node ; / / Nothing changed } } private Node tryFoldSimpleFunctionCall ( Node n ) { Preconditions . checkState ( n . isCall ( ) ) ;", "fixed_code": "/ / the IN_FOR_INIT_CLAUSE one . Context rhsContext = getContextForNoInOperator ( context ) ; if ( NodeUtil . isAssignmentOp ( n ) & & NodeUtil . isAssignmentOp ( last ) ) { / / Assignments are the only right - associative binary operators addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; case Token . ARRAYLIT : return tryMinimizeArrayLiteral ( node ) ; case Token . MUL : case Token . AND : case Token . OR : case Token . BITOR : case Token . BITXOR : case Token . BITAND : return tryRotateAssociativeOperator ( node ) ; default : return node ; / / Nothing changed } } private Node tryRotateAssociativeOperator ( Node n ) { if ( ! late ) { return n ; } Preconditions . checkArgument ( NodeUtil . isAssociative ( n . getType ( ) ) ) ; Node rhs = n . getLastChild ( ) ; if ( n . getType ( ) = = rhs . getType ( ) ) { Node parent = n . getParent ( ) ; Node first = n . getFirstChild ( ) . detachFromParent ( ) ; Node second = rhs . getFirstChild ( ) . detachFromParent ( ) ; Node third = rhs . getLastChild ( ) . detachFromParent ( ) ; Node newLhs = new Node ( n . getType ( ) , first , second ) . copyInformationFrom ( n ) ; Node newRoot = new Node ( rhs . getType ( ) , newLhs , third ) . copyInformationFrom ( rhs ) ; parent . replaceChild ( n , newRoot ) ; reportCodeChange ( ) ; return newRoot ; } return n ; } private Node tryFoldSimpleFunctionCall ( Node n ) { Preconditions . checkState ( n . isCall ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_173"}
{"buggy_code": "} private void parse ( AbstractCompiler compiler ) { try { ParserRunner . ParseResult result = ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , } if ( root = = null | | compiler . hasHaltingErrors ( ) ) { / / Most passes try to report as many errors as possible , / / so there may already be errors . We only care if there were / / errors in the code we just parsed . / / There was a parse error or IOException , so use a dummy block . root = IR . script ( ) ; } else { if ( nameNode . isName ( ) ) { result = IR . var ( nameNode , value ) ; result . setJSDocInfo ( info ) ; } else { result = IR . exprResult ( IR . assign ( nameNode , value ) ) ; result . getFirstChild ( ) . setJSDocInfo ( info ) ; } return result ; for ( Var v : scope . getVarIterable ( ) ) { Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVarAssign = parent . isVar ( ) & & n . hasChildren ( ) ; if ( isVarAssign & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVarAssign ) { Node value = v . getInitialValue ( ) . detachFromParent ( ) ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; scopedAliasNames . add ( name ) ; / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . Node newDecl = NodeUtil . newQualifiedNameNodeDeclaration ( compiler . getCodingConvention ( ) , globalName , NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; parent . getParent ( ) . addChildBefore ( newDecl , parent ) ; / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront (", "fixed_code": "} private void parse ( AbstractCompiler compiler ) { int startErrorCount = compiler . getErrorManager ( ) . getErrorCount ( ) ; try { ParserRunner . ParseResult result = ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , } if ( root = = null | | / / Most passes try to report as many errors as possible , / / so there may already be errors . We only care if there were / / errors in the code we just parsed . ( compiler . getErrorManager ( ) . getErrorCount ( ) > startErrorCount & & ! compiler . isIdeMode ( ) ) ) { / / There was a parse error or IOException , so use a dummy block . root = IR . script ( ) ; } else { if ( nameNode . isName ( ) ) { result = IR . var ( nameNode , value ) ; result . setJSDocInfo ( info ) ; } else if ( value ! = null ) { result = IR . exprResult ( IR . assign ( nameNode , value ) ) ; result . getFirstChild ( ) . setJSDocInfo ( info ) ; } else { result = IR . exprResult ( nameNode ) ; result . getFirstChild ( ) . setJSDocInfo ( info ) ; } return result ; for ( Var v : scope . getVarIterable ( ) ) { Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; scopedAliasNames . add ( name ) ; / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . if ( value ! = null | | v . getJSDocInfo ( ) ! = null ) { Node newDecl = NodeUtil . newQualifiedNameNodeDeclaration ( compiler . getCodingConvention ( ) , globalName , NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; parent . getParent ( ) . addChildBefore ( newDecl , parent ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront (", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_174"}
{"buggy_code": "private final boolean assumeStrictThis ; private final boolean assumeMinimumCapture ; private final Supplier < String > safeNameIdSupplier ; private CanInlineResult canInlineReferenceDirectly ( Node callNode , Node fnNode ) { if ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) { return CanInlineResult . NO ; } Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; } } Node fnParam = NodeUtil . getFunctionParameters ( fnNode ) . getFirstChild ( ) ; while ( cArg ! = null | | fnParam ! = null ) { if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) { return CanInlineResult . NO ; } } fnParam = fnParam . getNext ( ) ; } / / Limit the inlining if ( cArg ! = null ) { if ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) { return CanInlineResult . NO ; } cArg = cArg . getNext ( ) ; } }", "fixed_code": "private final boolean assumeStrictThis ; private final boolean assumeMinimumCapture ; private final Supplier < String > safeNameIdSupplier ; private final Supplier < String > throwawayNameSupplier = new Supplier < String > ( ) { private int nextId = 0 ; @ Override public String get ( ) { return String . valueOf ( nextId + + ) ; } } ; private CanInlineResult canInlineReferenceDirectly ( Node callNode , Node fnNode , Set < String > namesToAlias ) { if ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) { return CanInlineResult . NO ; } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; } } Map < String , Node > args = FunctionArgumentInjector . getFunctionCallParameterMap ( fnNode , callNode , this . throwawayNameSupplier ) ; boolean hasArgs = ! args . isEmpty ( ) ; if ( hasArgs ) { / / Limit the inlining Set < String > allNamesToAlias = Sets . newHashSet ( namesToAlias ) ; FunctionArgumentInjector . maybeAddTempsForCallArguments ( fnNode , args , allNamesToAlias , compiler . getCodingConvention ( ) ) ; if ( ! allNamesToAlias . isEmpty ( ) ) { return CanInlineResult . NO ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_175"}
{"buggy_code": "case Token . NAME : String varName = left . getString ( ) ; Var var = syntacticScope . getVar ( varName ) ; boolean isVarDeclaration = left . hasChildren ( ) ; / / When looking at VAR initializers for declared VARs , we tend / / to use the declared type over the type it ' s being / / sure we back - infer the < string > element constraint on / / the left hand side , so we use the left hand side . boolean isVarTypeBetter = ! isVarDeclaration | | var = = null | | var . isTypeInferred ( ) ; / / Makes it easier to check for NPEs . / / TODO ( nicksantos ) : This might be a better check once we have / / back - inference of object / array constraints . It will probably if ( isVarTypeBetter ) { redeclareSimpleVar ( scope , left , resultType ) ; } left . setJSType ( isVarDeclaration | | leftType = = null ? resultType : null ) ; if ( var ! = null & & var . isTypeInferred ( ) ) { JSType oldType = var . getType ( ) ;", "fixed_code": "case Token . NAME : String varName = left . getString ( ) ; Var var = syntacticScope . getVar ( varName ) ; JSType varType = var = = null ? null : var . getType ( ) ; boolean isVarDeclaration = left . hasChildren ( ) & & varType ! = null & & ! var . isTypeInferred ( ) ; / / When looking at VAR initializers for declared VARs , we tend / / to use the declared type over the type it ' s being / / sure we back - infer the < string > element constraint on / / the left hand side , so we use the left hand side . boolean isVarTypeBetter = isVarDeclaration & & / / Makes it easier to check for NPEs . ! resultType . isNullType ( ) & & ! resultType . isVoidType ( ) ; / / TODO ( nicksantos ) : This might be a better check once we have / / back - inference of object / array constraints . It will probably if ( isVarTypeBetter ) { redeclareSimpleVar ( scope , left , varType ) ; } else { redeclareSimpleVar ( scope , left , resultType ) ; } left . setJSType ( resultType ) ; if ( var ! = null & & var . isTypeInferred ( ) ) { JSType oldType = var . getType ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_176"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_18"}
{"buggy_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; case Token . THIS : / / \" this \" references aren ' t currently modeled in the CFG . break ; default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "fixed_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; / / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; if ( implicitProto = = null ) { / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = ImmutableSet . of ( ) ; } else { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; } for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "fixed_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_2"}
{"buggy_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null & & value . getNext ( ) = = null & & NodeUtil . isImmutableValue ( value ) ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "fixed_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_20"}
{"buggy_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "fixed_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null & & value . getNext ( ) = = null & & NodeUtil . isImmutableValue ( value ) ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_20"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( parent . getType ( ) = = Token . COMMA ) { if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } } if ( ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( parent . getType ( ) = = Token . COMMA ) { if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } } if ( ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else { return ; } } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } else if ( n . isExprResult ( ) ) { return ; } String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else { return ; } } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } else if ( n . isExprResult ( ) ) { return ; } String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_22"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_22"}
{"buggy_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "fixed_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_23"}
{"buggy_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "fixed_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_23"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_23"}
{"buggy_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) & & n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } }", "fixed_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) ) { if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_24"}
{"buggy_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) ) { if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } }", "fixed_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) & & n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_24"}
{"buggy_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { scope = traverseChildren ( n , scope ) ; Node constructor = n . getFirstChild ( ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; backwardsInferenceFromCallSite ( n , ct ) ; } } } n . setJSType ( type ) ; return scope ; }", "fixed_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; } } } n . setJSType ( type ) ; for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { scope = traverse ( arg , scope ) ; } return scope ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_25"}
{"buggy_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; private Set < String > modulesWithExports = Sets . newHashSet ( ) ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { if ( ! modulesWithExports . contains ( moduleName ) ) { return ; } Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; modulesWithExports . add ( moduleName ) ; }", "fixed_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "return block ; } private static Node blockUnchecked ( Node stmt ) { return new Node ( Token . BLOCK , stmt ) ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( finallyBody . isBlock ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "fixed_code": "return block ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isLabelName ( ) ) ; Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_27"}
{"buggy_code": "return block ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isLabelName ( ) ) ; Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "fixed_code": "return block ; } private static Node blockUnchecked ( Node stmt ) { return new Node ( Token . BLOCK , stmt ) ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( finallyBody . isBlock ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_27"}
{"buggy_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . @ Override void addConstant ( String newcode ) { add ( \" 0 \" ) ; } } }", "fixed_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_28"}
{"buggy_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; Set < String > validProperties = Sets . newHashSet ( ) ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . String propName = parent . getLastChild ( ) . getString ( ) ; if ( ! validProperties . contains ( propName ) ) { if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , gramps ) ) { validProperties . add ( propName ) ; } else { return false ; } } continue ; } return false ; } validProperties . add ( child . getString ( ) ) ; Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "fixed_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . continue ; } return false ; } Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_29"}
{"buggy_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; }", "fixed_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; }", "fixed_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_3"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; private boolean unknownDependencies = false ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "fixed_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_30"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "fixed_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; private boolean unknownDependencies = false ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_30"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . int lineStartChar = - 1 ; do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . lineStartChar = stream . getCharno ( ) + 1 ; } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; lineStartChar = 0 ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; boolean isEOC = token = = JsDocToken . EOC ; if ( ! isEOC ) { if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { int numSpaces = stream . getCharno ( ) - lineStartChar ; for ( int i = 0 ; i < numSpaces ; i + + ) { builder . append ( ' ' ) ; } lineStartChar = - 1 ; } else if ( builder . length ( ) > 0 ) { / / All tokens must be separated by a space . builder . append ( ' ' ) ; } } if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "fixed_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; / / All tokens must be separated by a space . if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } if ( builder . length ( ) > 0 ) { builder . append ( ' ' ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_32"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( hasReferenceName ( ) ) { return ; } / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_33"}
{"buggy_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_34"}
{"buggy_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_34"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null ) { type . matchConstraint ( constraintObj ) ; } }", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! objType . isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! objType . hasProperty ( prop ) ) { typeToInfer = getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; } objType . defineInferredProperty ( prop , typeToInfer , null ) ; } } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . if ( convention . getSingletonGetterClassName ( callNode ) ! = null ) { return false ; } } }", "fixed_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_36"}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_37"}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_37"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_38"}
{"buggy_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return forAnnotations ? \" ? \" : \" { . . . } \" ; } }", "fixed_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return \" { . . . } \" ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_39"}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_4"}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_4"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } }", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return \" { . . . } \" ; } }", "fixed_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; + i ; if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return forAnnotations ? \" ? \" : \" { . . . } \" ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_40"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } } }", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_40"}
{"buggy_code": "} / / Clone any remaining params that aren ' t in the function literal . while ( oldParams . hasNext ( ) ) { paramBuilder . newParameterFromNode ( oldParams . next ( ) ) ; } parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( ! isVarArgs ) { while ( oldParameterType ! = null & & ! isVarArgs ) { builder . newParameterFromNode ( oldParameterType ) ; oldParameterType = oldParameterType . getNext ( ) ; } } if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "fixed_code": "} / / Clone any remaining params that aren ' t in the function literal . parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_41"}
{"buggy_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { if ( loopNode . isForEach ( ) ) { errorReporter . error ( \" unsupported language extension : for each \" , sourceName , loopNode . getLineno ( ) , \" \" , 0 ) ; / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . EXPR_RESULT , Node . newNumber ( 0 ) ) ; } return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "fixed_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_42"}
{"buggy_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314 private List < Node > lentObjectLiterals = null ;", "fixed_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_43"}
{"buggy_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; } else if ( c = = ' / ' & & getLastChar ( ) = = ' / ' ) { / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / append ( \" \" ) ; } append ( newcode ) ;", "fixed_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / } append ( newcode ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_44"}
{"buggy_code": "assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "fixed_code": "assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "fixed_code": "assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_45"}
{"buggy_code": "propertyNode ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_47"}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_47"}
{"buggy_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { / / Determining declaration for # 2 if ( info ! = null ) { inferred = false ; } else if ( ! scope . isDeclared ( qName , false ) & & n . isUnscopedQualifiedName ( ) ) { inferred = false ; } } if ( ! inferred ) {", "fixed_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred ) { / / Determining declaration for # 2 inferred = ! ( rhsValue ! = null & & rhsValue . isFunction ( ) & & ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; } if ( ! inferred ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred ) { / / Determining declaration for # 2 inferred = ! ( rhsValue ! = null & & rhsValue . isFunction ( ) & & ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; } if ( ! inferred ) {", "fixed_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { / / Determining declaration for # 2 if ( info ! = null ) { inferred = false ; } else if ( ! scope . isDeclared ( qName , false ) & & n . isUnscopedQualifiedName ( ) ) { inferred = false ; } } if ( ! inferred ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_48"}
{"buggy_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } nameStack . push ( renamer ) ; } break ; case Token . LP : { Renamer renamer = nameStack . peek ( ) . forChildScope ( ) ; / / Add the function parameters for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } / / Add the function body declarations Node functionBody = n . getNext ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope nameStack . pop ( ) ; / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; case Token . LP : / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . break ; case Token . CATCH : / / Remove catch except name from the stack of names .", "fixed_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) = = Token . FUNCTION ) { for ( Node c = declarationRoot . getFirstChild ( ) . getNext ( ) . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } Node functionBody = declarationRoot . getLastChild ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; } else if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } / / Add the function parameters / / Add the function body declarations nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . case Token . CATCH : / / Remove catch except name from the stack of names .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_49"}
{"buggy_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . if ( gramps . isDelProp ( ) ) { return false ; } / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "fixed_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_5"}
{"buggy_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "fixed_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_50"}
{"buggy_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "fixed_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_50"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_50"}
{"buggy_code": "add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ;", "fixed_code": "add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_51"}
{"buggy_code": "add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; } } static boolean isWordChar ( char ch ) {", "fixed_code": "add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; } } static boolean isNegativeZero ( double x ) { return x = = 0 . 0 & & Math . copySign ( 1 , x ) = = - 1 . 0 ; } static boolean isWordChar ( char ch ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_51"}
{"buggy_code": "return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "return false ; } } return len > 0 ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_52"}
{"buggy_code": "return false ; } } return len > 0 ; } static double getSimpleNumber ( String s ) {", "fixed_code": "return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_52"}
{"buggy_code": "} Node replacement ; if ( nodes . isEmpty ( ) ) { replacement = new Node ( Token . TRUE ) ; } else { / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; } Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "fixed_code": "} Node replacement ; / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_53"}
{"buggy_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; if ( qVarType ! = null & & rhsValue ! = null & & rhsValue . getType ( ) = = Token . OBJECTLIT ) { typeRegistry . resetImplicitPrototype ( rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; } else if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression , / / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } PrototypeObjectType oldPrototype = this . prototype ; boolean replacedPrototype = oldPrototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; if ( oldPrototype ! = null ) { / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . oldPrototype . setOwnerFunction ( null ) ; } if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "fixed_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression , / / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | baseType . isUnknownType ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } boolean replacedPrototype = prototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_54"}
{"buggy_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; }", "fixed_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "fixed_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_55"}
{"buggy_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "fixed_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_56"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_57"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_57"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_57"}
{"buggy_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } if ( NodeUtil . isName ( lhs ) ) { addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; } else { computeGenKill ( lhs , gen , kill , conditional ) ; } computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "fixed_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_58"}
{"buggy_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) & & ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "fixed_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "fixed_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) & & ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_59"}
{"buggy_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { mismatch ( t , n , msg , rightType , leftType ) ; return false ; } return true ;", "fixed_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; } return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "/ / ignoring side - effects return TernaryValue . TRUE ; case Token . VOID : return TernaryValue . FALSE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { return TernaryValue . FALSE ; } break ; case Token . NAME : String name = n . getString ( ) ;", "fixed_code": "/ / ignoring side - effects return TernaryValue . TRUE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : return TernaryValue . FALSE ; case Token . NAME : String name = n . getString ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_60"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_60"}
{"buggy_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; if ( namespaceName . equals ( \" Math \" ) ) { return false ; } } if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "fixed_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null , true ) ; } private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( firstOutput & & options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "fixed_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null ) ; } private String toSource ( Node n , SourceMap sourceMap ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null ) ; } private String toSource ( Node n , SourceMap sourceMap ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "fixed_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null , true ) ; } private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( firstOutput & & options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_64"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 000 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_65"}
{"buggy_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; } else { / / Object literal keys are not typeable typeable = false ; } break ;", "fixed_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; / / Object literal keys are not typeable } break ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "fixed_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "} break ; } } token = eatTokensUntilEOL ( ) ; continue retry ; } } } } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "fixed_code": "} break ; } token = eatTokensUntilEOL ( ) ; } continue retry ; } } } } return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . if ( functionType . isOrdinaryFunction ( ) & & ! functionType . getTypeOfThis ( ) . isUnknownType ( ) & & ! functionType . getTypeOfThis ( ) . isNativeObjectType ( ) & & ! ( child . getType ( ) = = Token . GETELEM | | child . getType ( ) = = Token . GETPROP ) ) { report ( t , n , EXPECTED_THIS_TYPE , functionType . toString ( ) ) ; } visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "fixed_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_69"}
{"buggy_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; if ( resultEqualsValue ) { / / Objects are restricted to \" Function \" , subtypes are left return ctorType . getGreatestSubtype ( type ) ; } else { / / Only filter out subtypes of \" function \" return type . isSubtype ( ctorType ) ? null : type ; } } return matchesExpectation ( \" object \" ) ? type : null ; }", "fixed_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; / / Objects are restricted to \" Function \" , subtypes are left / / Only filter out subtypes of \" function \" } return matchesExpectation ( \" object \" ) ? type : null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; / / Objects are restricted to \" Function \" , subtypes are left / / Only filter out subtypes of \" function \" } return matchesExpectation ( \" object \" ) ? type : null ; }", "fixed_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; if ( resultEqualsValue ) { / / Objects are restricted to \" Function \" , subtypes are left return ctorType . getGreatestSubtype ( type ) ; } else { / / Only filter out subtypes of \" function \" return type . isSubtype ( ctorType ) ? null : type ; } } return matchesExpectation ( \" object \" ) ? type : null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_7"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_70"}
{"buggy_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = parent . getJSDocInfo ( ) ! = null & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "fixed_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = t . inGlobalScope ( ) & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_71"}
{"buggy_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = t . inGlobalScope ( ) & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "fixed_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = parent . getJSDocInfo ( ) ! = null & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_71"}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } static class LabelNameSupplier implements Supplier < String > { String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } static class LabelNameSupplier implements Supplier < String > { String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_72"}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } static class LabelNameSupplier implements Supplier < String > { String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } static class LabelNameSupplier implements Supplier < String > { String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_72"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_73"}
{"buggy_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = getNormalizedNodeType ( left ) ; int rhType = getNormalizedNodeType ( right ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) { private int getNormalizedNodeType ( Node n ) { int type = n . getType ( ) ; if ( type = = Token . NOT ) { TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; switch ( value ) { case TRUE : return Token . TRUE ; case FALSE : return Token . FALSE ; } } return type ; }", "fixed_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = left . getType ( ) ; int rhType = right . getType ( ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_74"}
{"buggy_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = left . getType ( ) ; int rhType = right . getType ( ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "fixed_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = getNormalizedNodeType ( left ) ; int rhType = getNormalizedNodeType ( right ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) { private int getNormalizedNodeType ( Node n ) { int type = n . getType ( ) ; if ( type = = Token . NOT ) { TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; switch ( value ) { case TRUE : return Token . TRUE ; case FALSE : return Token . FALSE ; } } return type ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_74"}
{"buggy_code": "} static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "} static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "} static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "} static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_75"}
{"buggy_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . if ( n . getNext ( ) ! = null ) { state = isVariableReadBeforeKill ( n . getNext ( ) , variable ) ; if ( state = = VariableLiveness . KILL ) { state = VariableLiveness . MAYBE_LIVE ; } } break ; case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . if ( n . getNext ( ) ! = null & & n . getNext ( ) . getNext ( ) ! = null ) { state = checkHookBranchReadBeforeKill ( n . getNext ( ) , n . getNext ( ) . getNext ( ) , variable ) ; } break ; default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { break ; } } } / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) { / / Not a FUNCTION return VariableLiveness . MAYBE_LIVE ; } if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : VariableLiveness v1 = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; VariableLiveness v2 = isVariableReadBeforeKill ( n . getLastChild ( ) , variable ) ; / / With a AND / OR the first branch always runs , but the second is / / may not . if ( v1 ! = VariableLiveness . MAYBE_LIVE ) { return v1 ; } else if ( v2 = = VariableLiveness . READ ) { return VariableLiveness . READ ; } else { return VariableLiveness . MAYBE_LIVE ; } case Token . HOOK : VariableLiveness first = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; if ( first ! = VariableLiveness . MAYBE_LIVE ) { return first ; } return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } return VariableLiveness . MAYBE_LIVE ;", "fixed_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( sibling ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } } } } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : / / With a AND / OR the first branch always runs , but the second is / / may not . case Token . HOOK : return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( child ) ) { / / Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } } return VariableLiveness . MAYBE_LIVE ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_77"}
{"buggy_code": "break ; case Token . MOD : if ( rval = = 0 ) { return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { return null ; } result = lval / rval ;", "fixed_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_79"}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; }", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_79"}
{"buggy_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! isNamedParameter ( var ) & & ! blacklistedVars . contains ( var ) ; } } private boolean isNamedParameter ( Var v ) { return v . getParentNode ( ) . isParamList ( ) ; } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "fixed_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! blacklistedVars . contains ( var ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced start = textIndex + searchList [ replaceIndex ] . length ( ) ; / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_8"}
{"buggy_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . case Token . DELPROP : return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . DELPROP : case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "fixed_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_80"}
{"buggy_code": "int length = s . length ( ) ; if ( length = = 0 | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "fixed_code": "int length = s . length ( ) ; if ( length = = 0 | | Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_80"}
{"buggy_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { int functionType = functionNode . getFunctionType ( ) ; if ( functionType ! = FunctionNode . FUNCTION_EXPRESSION ) { errorReporter . error ( \" unnamed function statement \" , sourceName , functionNode . getLineno ( ) , \" \" , 0 ) ; } name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "fixed_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_81"}
{"buggy_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | ( registry . getNativeFunctionType ( JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; } public boolean isNumberObjectType ( ) {", "fixed_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; } public boolean isNumberObjectType ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_82"}
{"buggy_code": "* itself or the name of a function ) . private void addPossibleSignature ( String name , Node node , NodeTraversal t ) { boolean signatureAdded = false ; if ( node . getType ( ) = = Token . FUNCTION ) { / / The node we ' re looking at is a function , so we can add it directly addSignature ( name , node , t . getSourceName ( ) ) ; signatureAdded = true ; } else if ( node . getType ( ) = = Token . NAME ) { String functionName = node . getString ( ) ; Scope . Var v = t . getScope ( ) . getVar ( functionName ) ; if ( v = = null ) { if ( compiler . isIdeMode ( ) ) { return ; } else { throw new IllegalStateException ( \" VarCheck should have caught this undefined function \" ) ; } } Node function = v . getInitialValue ( ) ; if ( function ! = null & & function . getType ( ) = = Token . FUNCTION ) { addSignature ( name , function , v . getInputName ( ) ) ; signatureAdded = true ; } } if ( ! signatureAdded ) { nonMethodProperties . add ( name ) ; } } / / Check if we can rename this . if ( ! okToRenameVar ( name , local ) ) { / / Blindly de - uniquify for the Prototype library for issue 103 . return ; }", "fixed_code": "* itself or the name of a function ) . private void addPossibleSignature ( String name , Node node , NodeTraversal t ) { if ( node . getType ( ) = = Token . FUNCTION ) { / / The node we ' re looking at is a function , so we can add it directly addSignature ( name , node , t . getSourceName ( ) ) ; } else { nonMethodProperties . add ( name ) ; } } / / Check if we can rename this . if ( ! okToRenameVar ( name , local ) ) { if ( local ) { / / Blindly de - uniquify for the Prototype library for issue 103 . String newName = MakeDeclaredNamesUnique . ContextualRenameInverter . getOrginalName ( name ) ; if ( ! newName . equals ( name ) ) { n . setString ( newName ) ; } } return ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_82"}
{"buggy_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; } public boolean isNumberObjectType ( ) {", "fixed_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | ( registry . getNativeFunctionType ( JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; } public boolean isNumberObjectType ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_82"}
{"buggy_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "fixed_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_83"}
{"buggy_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "fixed_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_83"}
{"buggy_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; Node target = assign . getFirstChild ( ) ; if ( ! validAssignmentTarget ( target ) ) { errorReporter . error ( \" invalid assignment target \" , sourceName , target . getLineno ( ) , \" \" , 0 ) ; } return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { if ( type = = Token . INC | | type = = Token . DEC ) { if ( ! validAssignmentTarget ( operand ) ) { String msg = ( type = = Token . INC ) ? \" invalid increment target \" : \" invalid decrement target \" ; errorReporter . error ( msg , sourceName , operand . getLineno ( ) , \" \" , 0 ) ; } } Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } private boolean validAssignmentTarget ( Node target ) { switch ( target . getType ( ) ) { case Token . NAME : case Token . GETPROP : case Token . GETELEM : return true ; } return false ; } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "fixed_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_84"}
{"buggy_code": "return n ; } switch ( n . getType ( ) ) { case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { if ( next . hasChildren ( ) ) { next = next . getFirstChild ( ) ; } else { next = computeFollowing ( next ) ; } } return next ; }", "fixed_code": "return n ; } if ( n . getParent ( ) = = null ) { List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; if ( outEdges . size ( ) = = 1 ) { return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; } } switch ( n . getType ( ) ) { case Token . BLOCK : if ( n . hasChildren ( ) ) { Node first = n . getFirstChild ( ) ; return tryRemoveUnconditionalBranching ( first ) ; } else { return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; } case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; return next ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_85"}
{"buggy_code": "import com . google . common . collect . Maps ; import com . google . common . collect . Multiset ; import com . google . common . collect . Sets ; import com . google . javascript . jscomp . NodeTraversal . AbstractPostOrderCallback ; import com . google . javascript . jscomp . Scope . Var ; import com . google . javascript . rhino . Node ; import com . google . javascript . rhino . Token ; class MakeDeclaredNamesUnique implements NodeTraversal . ScopedCallback { private Deque < Renamer > nameStack = new ArrayDeque < Renamer > ( ) ; private final Renamer rootRenamer ; static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler ; / / The set of names referenced in the current scope . / / Stack reference sets . / / Name are globally unique initially , so we don ' t need a per - scope map . private Map < Var , String > nameMap = Maps . newHashMap ( ) ; private ContextualRenameInverter ( AbstractCompiler compiler ) { this . compiler = compiler ; private boolean containsSeparator ( String name ) { return name . indexOf ( ContextualRenamer . UNIQUE_ID_SEPARATOR ) ! = - 1 ; } private static String getOrginalNameInternal ( String name , int index ) { return name . substring ( 0 , index ) ; } private static String getNameSuffix ( String name , int index ) { return name . substring ( index + ContextualRenamer . UNIQUE_ID_SEPARATOR . length ( ) , name . length ( ) ) ; } @ Override public void visit ( NodeTraversal t , Node node , Node parent ) { if ( node . getType ( ) = = Token . NAME ) { String oldName = node . getString ( ) ; if ( containsSeparator ( oldName ) ) { Scope scope = t . getScope ( ) ; Var var = t . getScope ( ) . getVar ( oldName ) ; if ( var = = null | | var . isGlobal ( ) ) { return ; } if ( nameMap . containsKey ( var ) ) { node . setString ( nameMap . get ( var ) ) ; } else { int index = indexOfSeparator ( oldName ) ; String newName = getOrginalNameInternal ( oldName , index ) ; String suffix = getNameSuffix ( oldName , index ) ; / / Merge any names that were referenced but not declared in the current / / scope . / / If there isn ' t anything left in the stack we will be going into the / / global scope : don ' t try to build a set of referenced names for the / / global scope . boolean recurseScopes = false ; if ( ! suffix . matches ( \" \\ \\ d + \" ) ) { recurseScopes = true ; } / / Check if the new name is valid and if it would cause conflicts . if ( var . scope . isDeclared ( newName , recurseScopes ) | | ! TokenStream . isJSIdentifier ( newName ) ) { newName = oldName ; } else { var . scope . declare ( newName , var . nameNode , null , null ) ; / / Adding a reference to the new name to prevent either the parent / / scopes or the current scope renaming another var to this new name . Node parentNode = var . getParentNode ( ) ; if ( parentNode . getType ( ) = = Token . FUNCTION & & parentNode = = var . scope . getRootNode ( ) ) { var . getNameNode ( ) . setString ( newName ) ; }  node . setString ( newName ) ; compiler . reportCodeChange ( ) ; } nameMap . put ( var , newName ) ; } / / Add all referenced names to the set so it is possible to check for / / conflicts . / / Store only references to candidate names in the node map . } } } } @ Override public void addDeclaredName ( String name ) { if ( global ) { reserveName ( name ) ; } else { String newName = null ; if ( id ! = 0 ) { newName = getUniqueName ( name , id ) ; } declarations . put ( name , newName ) ; } } } @ Override public void addDeclaredName ( String name ) { if ( ! declarations . containsKey ( name ) ) { declarations . put ( name , getUniqueName ( name ) ) ; } * @ return Whether the name is a reference to a variable , function or * function parameter ( not a label or a empty anonymous function name ) . static boolean isLabelName ( Node n ) { public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , new NormalizeStatements ( compiler , assertOnChange ) ) ; removeDuplicateDeclarations ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; / / } / / otherwise ' var e = 1 ' would be rewritten as ' e = 1 ' . / / TODO ( johnlenz ) : Introduce a seperate scope for catch nodes . new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "fixed_code": "import com . google . common . collect . Maps ; import com . google . common . collect . Multiset ; import com . google . common . collect . Sets ; import com . google . javascript . jscomp . NodeTraversal . ScopedCallback ; import com . google . javascript . jscomp . Scope . Var ; import com . google . javascript . rhino . Node ; import com . google . javascript . rhino . Token ; class MakeDeclaredNamesUnique implements NodeTraversal . ScopedCallback { public static final String ARGUMENTS = \" arguments \" ; private Deque < Renamer > nameStack = new ArrayDeque < Renamer > ( ) ; private final Renamer rootRenamer ; static class ContextualRenameInverter implements ScopedCallback , CompilerPass { private final AbstractCompiler compiler ; / / The set of names referenced in the current scope . private Set < String > referencedNames = ImmutableSet . of ( ) ; / / Stack reference sets . private Deque < Set < String > > referenceStack = new ArrayDeque < Set < String > > ( ) ; / / Name are globally unique initially , so we don ' t need a per - scope map . private Map < String , List < Node > > nameMap = Maps . newHashMap ( ) ; private ContextualRenameInverter ( AbstractCompiler compiler ) { this . compiler = compiler ; private boolean containsSeparator ( String name ) { return name . indexOf ( ContextualRenamer . UNIQUE_ID_SEPARATOR ) ! = - 1 ; } public void enterScope ( NodeTraversal t ) { if ( t . inGlobalScope ( ) ) { return ; } referenceStack . push ( referencedNames ) ; referencedNames = Sets . newHashSet ( ) ; } public void exitScope ( NodeTraversal t ) { if ( t . inGlobalScope ( ) ) { return ; } for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; handleScopeVar ( v ) ; } / / Merge any names that were referenced but not declared in the current / / scope . Set < String > current = referencedNames ; referencedNames = referenceStack . pop ( ) ; / / If there isn ' t anything left in the stack we will be going into the / / global scope : don ' t try to build a set of referenced names for the / / global scope . if ( ! referenceStack . isEmpty ( ) ) { referencedNames . addAll ( current ) ; } } void handleScopeVar ( Var v ) { String name = v . getName ( ) ; if ( containsSeparator ( name ) ) { String newName = getOrginalName ( name ) ; / / Check if the new name is valid and if it would cause conflicts . if ( TokenStream . isJSIdentifier ( newName ) & & ! referencedNames . contains ( newName ) & & ! newName . equals ( ARGUMENTS ) ) { referencedNames . remove ( name ) ; / / Adding a reference to the new name to prevent either the parent / / scopes or the current scope renaming another var to this new name . referencedNames . add ( newName ) ; List < Node > references = nameMap . get ( name ) ; Preconditions . checkState ( references ! = null ) ; for ( Node n : references ) { Preconditions . checkState ( n . getType ( ) = = Token . NAME ) ; n . setString ( newName ) ; } compiler . reportCodeChange ( ) ; } nameMap . remove ( name ) ; } } @ Override public boolean shouldTraverse ( NodeTraversal t , Node n , Node parent ) { return true ; } @ Override public void visit ( NodeTraversal t , Node node , Node parent ) { if ( t . inGlobalScope ( ) ) { return ; } if ( NodeUtil . isReferenceName ( node ) ) { String name = node . getString ( ) ; / / Add all referenced names to the set so it is possible to check for / / conflicts . referencedNames . add ( name ) ; / / Store only references to candidate names in the node map . if ( containsSeparator ( name ) ) { addCandidateNameReference ( name , node ) ; } } } private void addCandidateNameReference ( String name , Node n ) { List < Node > nodes = nameMap . get ( name ) ; if ( null = = nodes ) { nodes = Lists . newLinkedList ( ) ; nameMap . put ( name , nodes ) ; } nodes . add ( n ) ; } } @ Override public void addDeclaredName ( String name ) { if ( ! name . equals ( ARGUMENTS ) ) { if ( global ) { reserveName ( name ) ; } else { String newName = null ; if ( id ! = 0 ) { newName = getUniqueName ( name , id ) ; } declarations . put ( name , newName ) ; } } } } @ Override public void addDeclaredName ( String name ) { Preconditions . checkState ( ! name . equals ( ARGUMENTS ) ) ; if ( ! declarations . containsKey ( name ) ) { declarations . put ( name , getUniqueName ( name ) ) ; } * @ return Whether the name is a reference to a variable , function or * function parameter ( not a label or a empty anonymous function name ) . static boolean isReferenceName ( Node n ) { return isName ( n ) & & ! n . getString ( ) . isEmpty ( ) & & ! isLabelName ( n ) ; } static boolean isLabelName ( Node n ) { public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , new NormalizeStatements ( compiler , assertOnChange ) ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; / / } / / otherwise ' var e = 1 ' would be rewritten as ' e = 1 ' . / / TODO ( johnlenz ) : Introduce a seperate scope for catch nodes . removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_85"}
{"buggy_code": "return n ; } if ( n . getParent ( ) = = null ) { List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; if ( outEdges . size ( ) = = 1 ) { return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; } } switch ( n . getType ( ) ) { case Token . BLOCK : if ( n . hasChildren ( ) ) { Node first = n . getFirstChild ( ) ; return tryRemoveUnconditionalBranching ( first ) ; } else { return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; } case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; return next ; }", "fixed_code": "return n ; } switch ( n . getType ( ) ) { case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { if ( next . hasChildren ( ) ) { next = next . getFirstChild ( ) ; } else { next = computeFollowing ( next ) ; } } return next ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_85"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_86"}
{"buggy_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . if ( calledFn . getType ( ) = = Token . GETELEM ) { return false ; } else if ( calledFn . getType ( ) = = Token . GETPROP & & calledFn . getLastChild ( ) . getString ( ) . startsWith ( \" on \" ) ) { return false ; } } return true ; } return false ; } }", "fixed_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . return NodeUtil . isExpressionNode ( maybeExpr ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_87"}
{"buggy_code": "/ / a work - around for an IE bug where it throws an exception if you / / write to the parameters of the callback in a sort ( ) . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 58 liveness . analyze ( ) ; UndiGraph < Var , Void > interferenceGraph = case EOF : / / When we ' re capturing a license block , annotations / / in the block are ok . String multilineText = builder . toString ( ) ; if ( option ! = WhitespaceOption . PRESERVE ) { } return new ExtractionInfo ( multilineText , token ) ; / / FALL THROUGH", "fixed_code": "/ / a work - around for an IE bug where it throws an exception if you / / write to the parameters of the callback in a sort ( ) . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 58 if ( scope . getRootNode ( ) . getFirstChild ( ) . getNext ( ) . getChildCount ( ) = = 2 ) { liveness . markAllParametersEscaped ( ) ; } liveness . analyze ( ) ; UndiGraph < Var , Void > interferenceGraph = case EOF : / / When we ' re capturing a license block , annotations / / in the block are ok . if ( ! ( option = = WhitespaceOption . PRESERVE & & token = = JsDocToken . ANNOTATION ) ) { String multilineText = builder . toString ( ) ; if ( option ! = WhitespaceOption . PRESERVE ) { } return new ExtractionInfo ( multilineText , token ) ; } / / FALL THROUGH", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_87"}
{"buggy_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . return NodeUtil . isExpressionNode ( maybeExpr ) ; } }", "fixed_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . if ( calledFn . getType ( ) = = Token . GETELEM ) { return false ; } else if ( calledFn . getType ( ) = = Token . GETPROP & & calledFn . getLastChild ( ) . getString ( ) . startsWith ( \" on \" ) ) { return false ; } } return true ; } return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_87"}
{"buggy_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { Preconditions . checkState ( n . getParent ( ) . getType ( ) = = Token . ASSIGN ) ; / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . Node rhs = n . getNext ( ) ; VariableLiveness state = isVariableReadBeforeKill ( rhs , variable ) ; if ( state = = VariableLiveness . READ ) { return state ; } return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "fixed_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_88"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_89"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_89"}
{"buggy_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . filename = filename . replace ( \" \\ \\ \" , \" / \" ) ; if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "fixed_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_9"}
{"buggy_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = getNumObjectiveFunctions ( ) ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "fixed_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_9"}
{"buggy_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "fixed_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . filename = filename . replace ( \" \\ \\ \" , \" / \" ) ; if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_9"}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_90"}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_90"}
{"buggy_code": "} / / Don ' t traverse functions that are getting lent to a prototype . Node gramps = parent . getParent ( ) ; if ( NodeUtil . isObjectLitKey ( parent , gramps ) ) { JSDocInfo maybeLends = gramps . getJSDocInfo ( ) ; if ( maybeLends ! = null & & maybeLends . getLendsName ( ) ! = null & & maybeLends . getLendsName ( ) . endsWith ( \" . prototype \" ) ) { return false ; } } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "fixed_code": "} / / Don ' t traverse functions that are getting lent to a prototype . } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_91"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_92"}
{"buggy_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . ADD : case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : case Token . DIV : case Token . EQ : case Token . GE : case Token . GT : case Token . LE : case Token . LSH : case Token . LT : case Token . MOD : case Token . MUL : case Token . NE : case Token . RSH : case Token . SHEQ : case Token . SHNE : case Token . SUB : case Token . URSH : return isValidDefineValue ( val . getFirstChild ( ) , defines ) & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : case Token . POS : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "fixed_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_94"}
{"buggy_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & isQnameRootedInGlobalScope ( n ) ) { Scope globalScope = scope . getGlobalScope ( ) ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . if ( ! globalScope . isDeclared ( variableName , false ) ) { scopeToDeclareIn = scope . getGlobalScope ( ) ; } } / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "fixed_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_95"}
{"buggy_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "fixed_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_96"}
{"buggy_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "fixed_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_96"}
{"buggy_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "fixed_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_97"}
{"buggy_code": "} / / Make sure this assignment is not in a loop . for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ; } } return true ; } private final boolean isFunction ; private final boolean isLoop ;", "fixed_code": "} / / Make sure this assignment is not in a loop . return true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_98"}
{"buggy_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "fixed_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_98"}
{"buggy_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "fixed_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Closure_99"}
{"buggy_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "fixed_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_99"}
{"buggy_code": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" ^ mb \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "fixed_code": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" mb $ \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_10"}
{"buggy_code": "private static final byte SPACE = 32 ; / / Static initializer for printable chars collection static { * the buffer to write to * @ return The number of bytes written to the < code > buffer < / code > private static final void encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; }", "fixed_code": "private static final byte SPACE = 32 ; private static final byte CR = 13 ; private static final byte LF = 10 ; private static final int SAFE_LENGTH = 73 ; / / Static initializer for printable chars collection static { * the buffer to write to * @ return The number of bytes written to the < code > buffer < / code > private static final int encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } private static int getUnsignedOctet ( final int index , final byte [ ] bytes ) { int b = bytes [ index ] ; if ( b < 0 ) { b = 256 + b ; } return b ; } private static int encodeByte ( final int b , final boolean encode , final ByteArrayOutputStream buffer ) { if ( encode ) { return encodeQuotedPrintable ( b , buffer ) ; } else { buffer . write ( b ) ; return 1 ; } } private static boolean isWhitespace ( final int b ) { return b = = SPACE | | b = = TAB ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_11"}
{"buggy_code": "private static final Map < NameType , Lang > Langs = new EnumMap < NameType , Lang > ( NameType . class ) ; private static final String LANGUAGE_RULES_RN = \" org / apache / commons / codec / language / bm / lang . txt \" ; static { for ( final NameType s : NameType . values ( ) ) { Langs . put ( s , loadFromResource ( LANGUAGE_RULES_RN , Languages . getInstance ( s ) ) ) ; } } import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import org . apache . commons . codec . language . bm . Languages . LanguageSet ; import org . apache . commons . codec . language . bm . Rule . Phoneme ; return phonemeBuilder ; } final Set < Rule . Phoneme > phonemes = new TreeSet < Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost phonemes . addAll ( subBuilder . getPhonemes ( ) ) ; } return new PhonemeBuilder ( phonemes ) ; } @ Override public String toString ( ) {", "fixed_code": "private static final Map < NameType , Lang > Langs = new EnumMap < NameType , Lang > ( NameType . class ) ; private static final String LANGUAGE_RULES_RN = \" org / apache / commons / codec / language / bm / % s_lang . txt \" ; static { for ( final NameType s : NameType . values ( ) ) { Langs . put ( s , loadFromResource ( String . format ( LANGUAGE_RULES_RN , s . getName ( ) ) , Languages . getInstance ( s ) ) ) ; } } import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import org . apache . commons . codec . language . bm . Languages . LanguageSet ; import org . apache . commons . codec . language . bm . Rule . Phoneme ; return phonemeBuilder ; } final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap < Rule . Phoneme , Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes ( ) ) { if ( phonemes . containsKey ( newPhoneme ) ) { final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages ( ) ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; } } } return new PhonemeBuilder ( phonemes . keySet ( ) ) ; } public Phoneme mergeWithLanguage ( final LanguageSet lang ) { return new Phoneme ( this . phonemeText . toString ( ) , this . languages . merge ( lang ) ) ; } @ Override public String toString ( ) {   zh polish + russian + german + english true eau french true [ aoeiu\u00e4\u00f6\u00fc ] h german true ^ vogel german , true vogel $ german true witz german true tz $ german + russian + english true ^ tz russian + english true g\u00fce spanish true g\u00fci spanish true ghe romanian true ghi romanian true vici $ romanian true schi $ romanian true chsch german true tsch german true ssch german true sch $ german + russian true ^ sch german + russian true ^ rz polish true rz $ polish + german true [ ^ aoeiu\u00e4\u00f6\u00fc ] rz polish true rz [ ^ aoeiu\u00e4\u00f6\u00fc ] polish true cki $ polish true ska $ polish true cka $ polish true ue german + russian true ae german + russian + english true oe german + french + russian + english true th $ german true ^ th german true th [ ^ aoeiu ] german true mann german true cz polish true cy polish true niew polish true stein german true heim $ german true heimer $ german true ii $ russian true iy $ russian true yy $ russian true yi $ russian true yj $ russian true ij $ russian true gaus $ russian true gauz $ russian true gauz $ russian true goltz $ russian true gol ' tz $ russian true golts $ russian true gol ' ts $ russian true ^ goltz russian true ^ gol ' tz russian true ^ golts russian true ^ gol ' ts russian true gendler $ russian true gejmer $ russian true gejm $ russian true geimer $ russian true geim $ russian true geymer russian true geym $ russian true gof $ russian true thal german true zweig german true ck $ german + english true c $ polish + romanian + hungarian true sz polish + hungarian true gue spanish + french true gui spanish + french true guy french true cs $ hungarian true ^ cs hungarian true dzs hungarian true zs $ hungarian true ^ zs hungarian true ^ wl polish true ^ wr polish + english + german true  gy $ hungarian true gy [ aeou ] hungarian true gy hungarian + russian true ly hungarian + russian + polish true ny hungarian + russian + polish true ty hungarian + russian + polish true  \u00e2 romanian + french true \u0103 romanian true \u00e0 french true \u00e4 german true \u00e1 hungarian + spanish true \u0105 polish true \u0107 polish true \u00e7 french true \u0119 polish true \u00e9 french + hungarian + spanish true \u00e8 french true \u00ea french true \u00ed hungarian + spanish true \u00ee romanian + french true \u0142 polish true \u0144 polish true \u00f1 spanish true \u00f3 polish + hungarian + spanish true \u00f6 german + hungarian true \u00f5 hungarian true \u015f romanian true \u015b polish true \u0163 romanian true \u00fc german + hungarian true \u00f9 french true \u0171 hungarian true \u00fa hungarian + spanish true \u017a polish true \u017c polish true  \u00df german true  \u0430 cyrillic true \u0451 cyrillic true \u043e cyrillic true \u0435 cyrillic true \u0438 cyrillic true \u0443 cyrillic true \u044b cyrillic true \u044d cyrillic true \u044e cyrillic true \u044f cyrillic true  \u05d0 hebrew true \u05d1 hebrew true \u05d2 ebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   a cyrillic + hebrew false o cyrillic + hebrew false e cyrillic + hebrew false i cyrillic + hebrew false y cyrillic + hebrew + romanian false u cyrillic + hebrew false  v [ ^ aoeiu\u00e4\u00fc\u00f6 ] german false / / in german \" v \" can be found before a vowel only y [ ^ aoeiu ] german false / / in german \" y \" usually appears only in the last position ; sometimes before a vowel c [ ^ aohk ] german false dzi german + english + french false ou german false aj german + english + french false ej german + english + french false oj german + english + french false uj german + english + french false k romanian false v polish false ky polish false eu russian + polish false w french + romanian + spanish + hungarian + russian false kie french + spanish false gie french + romanian + spanish false q hungarian + polish + russian + romanian false sch hungarian + polish + french + spanish false ^ h russian false   ^ o \u2019 english true ^ o ' english true ^ mc english true ^ fitz english true ceau french + romanian true eau romanian true eau $ french true / / mp : I ' ve added this eaux $ french true / / mp : I ' ve added this ault $ french true oult $ french true eux $ french true eix $ french true glou $ greeklatin true uu dutch true tx spanish true witz german true tz $ german + russian + english true ^ tz russian + english true poulos $ greeklatin true pulos $ greeklatin true iou greeklatin true sj $ dutch true ^ sj dutch true g\u00fce spanish true g\u00fci spanish true ghe romanian + greeklatin true ghi romanian + greeklatin true escu $ romanian true esco $ romanian true vici $ romanian true schi $ romanian true ii $ russian true iy $ russian true yy $ russian true yi $ russian true ^ rz polish true rz $ polish + german true [ bcdfgklmnpstwz ] rz polish true rz [ bcdfghklmnpstw ] polish true cki $ polish true ska $ polish true cka $ polish true ae german + russian + english true oe german + french + russian + english + dutch true th $ german + english true ^ th german + english + greeklatin true mann german true cz polish true cy polish + greeklatin true niew polish true etti $ italian true eti $ italian true ati $ italian true ato $ italian true [ aoei ] no $ italian true [ aoei ] ni $ italian true esi $ italian true oli $ italian true field $ english true stein german true heim $ german true heimer $ german true thal german true zweig german true [ aeou ] h german true \u00e4h german true \u00f6h german true \u00fch german true [ ln ] h [ ao ] $ portuguese true [ ln ] h [ aou ] portuguese + french + german + dutch + czech + spanish + turkish true chsch german true tsch german true sch $ german + russian true ^ sch german + russian true ck $ german + english true c $ polish + romanian + hungarian + czech + turkish true sz polish + hungarian true cs $ hungarian true ^ cs hungarian true dzs hungarian true zs $ hungarian true ^ zs hungarian true ^ wl polish true ^ wr polish + english + german + dutch true  gy $ hungarian true gy [ aeou ] hungarian true gy hungarian + russian + french + greeklatin true guy french true gu [ ei ] spanish + french + portuguese true gu [ ao ] spanish + portuguese true gi [ aou ] italian + greeklatin true  ly hungarian + russian + polish + greeklatin true ny hungarian + russian + polish + spanish + greeklatin true ty hungarian + russian + polish + greeklatin true  \u0107 polish true \u00e7 french + spanish + portuguese + turkish true \u010d czech true \u010f czech true \u011f turkish true \u0142 polish true \u0144 polish true \u00f1 spanish true \u0148 czech true \u0159 czech true \u015b polish true \u015f romanian + turkish true \u0161 czech true \u0163 romanian true \u0165 czech true \u017a polish true \u017c polish true  \u00df german true  \u00e4 german true \u00e1 hungarian + spanish + portuguese + czech + greeklatin true \u00e2 romanian + french + portuguese true \u0103 romanian true \u0105 polish true \u00e0 portuguese true \u00e3 portuguese true \u0119 polish true \u00e9 french + hungarian + czech + greeklatin true \u00e8 french + spanish + italian true \u00ea french true \u011b czech true \u00ea french + portuguese true \u00ed hungarian + spanish + portuguese + czech + greeklatin true \u00ee romanian + french true \u0131 turkish true \u00f3 polish + hungarian + spanish + italian + portuguese + czech + greeklatin true \u00f6 german + hungarian + turkish true \u00f4 french + portuguese true \u00f5 portuguese + hungarian true \u00f2 italian + spanish true \u0171 hungarian true \u00fa hungarian + spanish + portuguese + czech + greeklatin true \u00fc german + hungarian + spanish + portuguese + turkish true \u00f9 french true \u016f czech true \u00fd czech + greeklatin true  \u0430 cyrillic true \u0451 cyrillic true \u043e cyrillic true \u0435 cyrillic true \u0438 cyrillic true \u0443 cyrillic true \u044b cyrillic true \u044d cyrillic true \u044e cyrillic true \u044f cyrillic true  \u03b1 greek true \u03b5 greek true \u03b7 greek true \u03b9 greek true \u03bf greek true \u03c5 greek true \u03c9 greek true  \u0627 arabic true / / alif ( isol + init ) \u0628 arabic true / / ba ' \u062a arabic true / / ta ' \u062b arabic true / / tha ' \u062c arabic true / / jim \u062d arabic true / / h . a ' \u062e ' arabic true / / kha ' \u062f arabic true / / dal ( isol + init ) \u0630 arabic true / / dhal ( isol + init ) \u0631 arabic true / / ra ' ( isol + init ) \u0632 arabic true / / za ' ( isol + init ) \u0633 arabic true / / sin \u0634 arabic true / / shin \u0635 arabic true / / s . ad \u0636 arabic true / / d . ad \u0637 arabic true / / t . a ' \u0638 arabic true / / z . a ' \u0639 arabic true / / ' ayn \u063a arabic true / / ghayn \u0641 arabic true / / fa ' \u0642 arabic true / / qaf \u0643 arabic true / / kaf \u0644 arabic true / / lam \u0645 arabic true / / mim \u0646 arabic true / / nun \u0647 arabic true / / ha ' \u0648 arabic true / / waw ( isol + init ) \u064a arabic true / / ya '  \u0622 arabic true / / alif madda \u0625 arabic true / / alif + diacritic \u0623 arabic true / / alif + hamza \u0624 arabic true / / waw + hamza \u0626 arabic true / / ya ' + hamza \u0644\u0627 arabic true / / ligature l + a  \u05d0 hebrew true \u05d1 hebrew true \u05d2 hebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   a cyrillic + hebrew + greek + arabic false o cyrillic + hebrew + greek + arabic false e cyrillic + hebrew + greek + arabic false i cyrillic + hebrew + greek + arabic false y cyrillic + hebrew + greek + arabic + romanian + dutch false u cyrillic + hebrew + greek + arabic false  j italian false j [ ^ aoeiuy ] french + spanish + portuguese + greeklatin false g czech false k romanian + spanish + portuguese + french + italian false q hungarian + polish + russian + romanian + czech + dutch + turkish + greeklatin false v polish false w french + romanian + spanish + hungarian + russian + czech + turkish + greeklatin false x czech + hungarian + dutch + turkish false / / polish excluded from the list  dj spanish + turkish false v [ ^ aoeiu ] german false / / in german , \" v \" can be found before a vowel only y [ ^ aoeiu ] german false / / in german , \" y \" usually appears only in the last position ; sometimes before a vowel c [ ^ aohk ] german false dzi german + english + french + turkish false ou german false a [ eiou ] turkish false / / no diphthongs in Turkish \u00f6 [ eaiou ] turkish false \u00fc [ eaiou ] turkish false e [ aiou ] turkish false i [ aeou ] turkish false o [ aieu ] turkish false u [ aieo ] turkish false aj german + english + french + dutch false ej german + english + french + dutch false oj german + english + french + dutch false uj german + english + french + dutch false eu russian + polish false ky polish false kie french + spanish + greeklatin false gie portuguese + romanian + spanish + greeklatin false ch [ aou ] italian false ch turkish false son $ german false sc [ ei ] french false sch hungarian + polish + french + spanish false ^ h russian false   eau french true ou french true gni italian + french true tx spanish true tj spanish true gy french true guy french true  sh spanish + portuguese true / / English , but no sign for / sh / in these languages  lh portuguese true nh portuguese true ny spanish true  gue spanish + french true gui spanish + french true gia italian true gie italian true gio italian true giu italian true  \u00f1 spanish true \u00e2 portuguese + french true \u00e1 portuguese + spanish true \u00e0 portuguese true \u00e3 portuguese true \u00ea french + portuguese true \u00ed portuguese + spanish true \u00ee french true \u00f4 french + portuguese true \u00f5 portuguese true \u00f2 italian + spanish true \u00fa portuguese + spanish true \u00f9 french true \u00fc portuguese + spanish true  \u05d0 hebrew true \u05d1 hebrew true \u05d2 hebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   a hebrew false o hebrew false e hebrew false i hebrew false y hebrew false u hebrew false  kh spanish false gua italian false guo italian false \u00e7 italian false cha italian false cho italian false chu italian false j italian false dj spanish false sce french false sci french false \u00f3 french false \u00e8 portuguese false", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_14"}
{"buggy_code": "return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "fixed_code": "return binaryData ; } long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Codec_14"}
{"buggy_code": "final char mappedChar = this . map ( str . charAt ( index ) ) ; / / HW rule check if ( index > 1 & & mappedChar ! = ' 0 ' ) { final char hwChar = str . charAt ( index - 1 ) ; if ( ' H ' = = hwChar | | ' W ' = = hwChar ) { final char preHWChar = str . charAt ( index - 2 ) ; final char firstCode = this . map ( preHWChar ) ; if ( firstCode = = mappedChar | | ' H ' = = preHWChar | | ' W ' = = preHWChar ) { return 0 ; } } } return mappedChar ;", "fixed_code": "final char mappedChar = this . map ( str . charAt ( index ) ) ; / / HW rule check if ( index > 1 & & mappedChar ! = ' 0 ' ) { for ( int i = index - 1 ; i > = 0 ; i - - ) { final char prevChar = str . charAt ( i ) ; if ( this . map ( prevChar ) = = mappedChar ) { return 0 ; } if ( ' H ' ! = prevChar & & ' W ' ! = prevChar ) { break ; } } } return mappedChar ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_15"}
{"buggy_code": "* @ since As of 1 . 7 , throws { @ link NullPointerException } instead of UnsupportedEncodingException public static String newStringIso8859_1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; }", "fixed_code": "* @ since As of 1 . 7 , throws { @ link NullPointerException } instead of UnsupportedEncodingException public static String newStringIso8859_1 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . ISO_8859_1 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_17"}
{"buggy_code": "if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "fixed_code": "if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return cs1 . length ( ) = = cs2 . length ( ) & & CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_18"}
{"buggy_code": "} break ; } if ( lineLength > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "fixed_code": "} break ; } if ( lineLength > 0 & & pos > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_2"}
{"buggy_code": "} / / 1 . Convert to lowercase txt = txt . toLowerCase ( ) ; / / 2 . Remove anything not A - Z txt = txt . replaceAll ( \" [ ^ a - z ] \" , \" \" ) ; } / / single character is itself if ( txt . length ( ) = = 1 ) { return txt . toUpperCase ( ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; } } if ( count = = len ) { return str . toUpperCase ( ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "fixed_code": "} / / 1 . Convert to lowercase txt = txt . toLowerCase ( java . util . Locale . ENGLISH ) ; / / 2 . Remove anything not A - Z txt = txt . replaceAll ( \" [ ^ a - z ] \" , \" \" ) ; } / / single character is itself if ( txt . length ( ) = = 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; } } if ( count = = len ) { return str . toUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Codec_2"}
{"buggy_code": "* < / p > public Base64 ( ) { this ( false ) ; }", "fixed_code": "* < / p > public Base64 ( ) { this ( 0 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_4"}
{"buggy_code": "if ( ( contains ( value , 0 , 4 , \" VAN \" , \" VON \" ) | | contains ( value , 0 , 3 , \" SCH \" ) ) | | contains ( value , index + 1 , 2 , \" ET \" ) ) { / / - - obvious germanic - - / / result . append ( ' K ' ) ; } else if ( contains ( value , index + 1 , 4 , \" IER \" ) ) { result . append ( ' J ' ) ; } else { result . append ( ' J ' , ' K ' ) ;", "fixed_code": "if ( ( contains ( value , 0 , 4 , \" VAN \" , \" VON \" ) | | contains ( value , 0 , 3 , \" SCH \" ) ) | | contains ( value , index + 1 , 2 , \" ET \" ) ) { / / - - obvious germanic - - / / result . append ( ' K ' ) ; } else if ( contains ( value , index + 1 , 3 , \" IER \" ) ) { result . append ( ' J ' ) ; } else { result . append ( ' J ' , ' K ' ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Codec_4"}
{"buggy_code": "/ / EOF ( - 1 ) and first time ' = ' character is encountered in stream . / / This approach makes the ' = ' padding characters completely optional . if ( eof & & modulus ! = 0 ) { x = x < < 6 ; switch ( modulus ) {", "fixed_code": "/ / EOF ( - 1 ) and first time ' = ' character is encountered in stream . / / This approach makes the ' = ' padding characters completely optional . if ( eof & & modulus ! = 0 ) { if ( buffer = = null | | buffer . length - pos < decodeSize ) { resizeBuffer ( ) ; } x = x < < 6 ; switch ( modulus ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_5"}
{"buggy_code": "} else if ( len = = 0 ) { return 0 ; } else { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } return base64 . readResults ( b , offset , len ) ; } }", "fixed_code": "} else if ( len = = 0 ) { return 0 ; } else { int readLen = 0 ; while ( readLen = = 0 ) { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } readLen = base64 . readResults ( b , offset , len ) ; } return readLen ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_6"}
{"buggy_code": "* @ since 1 . 4 public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; }", "fixed_code": "* @ since 1 . 4 public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_7"}
{"buggy_code": "return eof ? - 1 : 0 ; } void setInitialBuffer ( byte [ ] out , int outPos , int outAvail ) { if ( out ! = null & & out . length = = outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } }", "fixed_code": "return eof ? - 1 : 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Codec_8"}
{"buggy_code": "public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > iterator1 , final Iterator < ? extends E > iterator2 ) { return new CollatingIterator < E > ( comparator , iterator1 , iterator2 ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > . . . iterators ) { return new CollatingIterator < E > ( comparator , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Collection < Iterator < ? extends E > > iterators ) { return new CollatingIterator < E > ( comparator , iterators ) ; } / / Object Graph", "fixed_code": "public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > iterator1 , final Iterator < ? extends E > iterator2 ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterator1 , iterator2 ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > . . . iterators ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Collection < Iterator < ? extends E > > iterators ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterators ) ; } / / Object Graph", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Collections_25"}
{"buggy_code": "* only stable for the same process ) . * @ return the instance with recalculated hash code private Object readResolve ( ) { calculateHashCode ( keys ) ; return this ; }", "fixed_code": "* only stable for the same process ) . * @ return the instance with recalculated hash code protected Object readResolve ( ) { calculateHashCode ( keys ) ; return this ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Collections_26"}
{"buggy_code": "return new RangeEntryMap ( fromKey , fromInclusive , toKey , toInclusive ) ; } }", "fixed_code": "return new RangeEntryMap ( fromKey , fromInclusive , toKey , toInclusive ) ; } @ Override public void clear ( ) { Iterator < Map . Entry < K , V > > it = AbstractPatriciaTrie . this . entrySet ( ) . iterator ( ) ; Set < K > currentKeys = keySet ( ) ; while ( it . hasNext ( ) ) { if ( currentKeys . contains ( it . next ( ) . getKey ( ) ) ) { it . remove ( ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Collections_28"}
{"buggy_code": "public void close ( ) throws IOException { if ( ! this . closed ) { super . close ( ) ; this . closed = true ; }", "fixed_code": "public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; super . close ( ) ; this . closed = true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_1"}
{"buggy_code": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order for ( ZipArchiveEntry ze : entries . keySet ( ) ) { OffsetEntry offsetEntry = entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } } }", "fixed_code": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order Map < ZipArchiveEntry , OffsetEntry > origMap = new LinkedHashMap < ZipArchiveEntry , OffsetEntry > ( entries ) ; entries . clear ( ) ; for ( ZipArchiveEntry ze : origMap . keySet ( ) ) { OffsetEntry offsetEntry = origMap . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } entries . put ( ze , offsetEntry ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_10"}
{"buggy_code": "return new TarArchiveInputStream ( in ) ; } / / COMPRESS - 117 - improve auto - recognition try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; tais . getNextEntry ( ) ; / / autodetection , simply not a TAR / / ignored } } catch ( IOException e ) { throw new ArchiveException ( \" Could not use reset and mark operations . \" , e ) ; }", "fixed_code": "return new TarArchiveInputStream ( in ) ; } / / COMPRESS - 117 - improve auto - recognition if ( signatureLength > = 512 ) { try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; tais . getNextEntry ( ) ; / / autodetection , simply not a TAR / / ignored } } } catch ( IOException e ) { throw new ArchiveException ( \" Could not use reset and mark operations . \" , e ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_11"}
{"buggy_code": "return null ; } currEntry = new TarArchiveEntry ( headerBuf ) ; entryOffset = 0 ; entrySize = currEntry . getSize ( ) ;", "fixed_code": "return null ; } try { currEntry = new TarArchiveEntry ( headerBuf ) ; } catch ( IllegalArgumentException e ) { IOException ioe = new IOException ( \" Error detected parsing the header \" ) ; ioe . initCause ( e ) ; throw ioe ; } entryOffset = 0 ; entrySize = currEntry . getSize ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_12"}
{"buggy_code": "* @ param name the name to use protected void setName ( String name ) { this . name = name ; }", "fixed_code": "* @ param name the name to use protected void setName ( String name ) { if ( name ! = null & & getPlatform ( ) = = PLATFORM_FAT & & name . indexOf ( \" / \" ) = = - 1 ) { name = name . replace ( ' \\ \\ ' , ' / ' ) ; } this . name = name ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_13"}
{"buggy_code": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; }", "fixed_code": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } if ( buffer [ start ] = = 0 ) { return 0L ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_14"}
{"buggy_code": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { if ( otherComment ! = null ) { return false ; } } else if ( ! myComment . equals ( otherComment ) ) { return false ; } return getTime ( ) = = other . getTime ( ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "fixed_code": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { myComment = \" \" ; } if ( otherComment = = null ) { otherComment = \" \" ; } return getTime ( ) = = other . getTime ( ) & & myComment . equals ( otherComment ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_15"}
{"buggy_code": "try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; / / COMPRESS - 191 - verify the header checksum tais . getNextEntry ( ) ; return new TarArchiveInputStream ( in ) ; } catch ( Exception e ) { / / NOPMD / / can generate IllegalArgumentException as well / / as IOException", "fixed_code": "try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; / / COMPRESS - 191 - verify the header checksum if ( tais . getNextTarEntry ( ) . isCheckSumOK ( ) ) { return new TarArchiveInputStream ( in ) ; } } catch ( Exception e ) { / / NOPMD / / can generate IllegalArgumentException as well / / as IOException", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_16"}
{"buggy_code": "} / / May have additional NULs or spaces trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } for ( ; start < end ; start + + ) {", "fixed_code": "} / / May have additional NULs or spaces trailer = buffer [ end - 1 ] ; while ( start < end - 1 & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_17"}
{"buggy_code": "void writePaxHeaders ( String entryName , Map < String , String > headers ) throws IOException { String name = \" . / PaxHeaders . X / \" + stripTo7Bits ( entryName ) ; / / TarEntry ' s constructor would think this is a directory / / and not allow any data to be written if ( name . length ( ) > = TarConstants . NAMELEN ) { name = name . substring ( 0 , TarConstants . NAMELEN - 1 ) ; }", "fixed_code": "void writePaxHeaders ( String entryName , Map < String , String > headers ) throws IOException { String name = \" . / PaxHeaders . X / \" + stripTo7Bits ( entryName ) ; while ( name . endsWith ( \" / \" ) ) { / / TarEntry ' s constructor would think this is a directory / / and not allow any data to be written name = name . substring ( 0 , name . length ( ) - 1 ) ; } if ( name . length ( ) > = TarConstants . NAMELEN ) { name = name . substring ( 0 , TarConstants . NAMELEN - 1 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_18"}
{"buggy_code": "if ( rawCentralDirectoryData . length ! = expectedLength ) { throw new ZipException ( \" central directory zip64 extended \"", "fixed_code": "( hasCompressedSize ? DWORD : 0 ) ( hasRelativeHeaderOffset ? DWORD : 0 ) ( hasDiskStart ? WORD : 0 ) ; if ( rawCentralDirectoryData . length < expectedLength ) { throw new ZipException ( \" central directory zip64 extended \" \" information extra field ' s length \" \" doesn ' t match central directory \"", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_19"}
{"buggy_code": "ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "fixed_code": "ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { / / mode is initialised to 0 ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_20"}
{"buggy_code": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; - - shift ; if ( shift = = 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( length > 0 & & shift > 0 ) { header . write ( cache ) ; } }", "fixed_code": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; if ( - - shift < 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( shift ! = 7 ) { header . write ( cache ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_21"}
{"buggy_code": "private InputStream in ; private final boolean decompressConcatenated ; private int currentChar = - 1 ; private static final int EOF = 0 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; init ( true ) ; initBlock ( ) ; setupBlock ( ) ; } @ Override } private int read0 ( ) throws IOException { final int retChar = this . currentChar ; switch ( currentState ) { case EOF : return - 1 ; case START_BLOCK_STATE : throw new IllegalStateException ( ) ; case RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : throw new IllegalStateException ( ) ; } return retChar ; } private boolean init ( boolean isFirstStream ) throws IOException { } this . su_ch2 = su_ch2Shadow ^ = ( this . su_rNToGo = = 1 ) ? 1 : 0 ; this . su_i2 + + ; this . currentChar = su_ch2Shadow ; this . currentState = RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; this . su_ch2 = su_ch2Shadow ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_i2 + + ; this . currentChar = su_ch2Shadow ; this . currentState = NO_RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; private int setupRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { this . currentChar = this . su_ch2 ; this . crc . updateCRC ( this . su_ch2 ) ; this . su_j2 + + ; return this . su_ch2 ; private int setupNoRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { int su_ch2Shadow = this . su_ch2 ; this . currentChar = su_ch2Shadow ; this . crc . updateCRC ( su_ch2Shadow ) ; this . su_j2 + + ; this . currentState = NO_RAND_PART_C_STATE ;", "fixed_code": "private InputStream in ; private final boolean decompressConcatenated ; private static final int EOF = 0 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; init ( true ) ; initBlock ( ) ; } @ Override } private int read0 ( ) throws IOException { switch ( currentState ) { case EOF : return - 1 ; case START_BLOCK_STATE : return setupBlock ( ) ; case RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case RAND_PART_B_STATE : return setupRandPartB ( ) ; case RAND_PART_C_STATE : return setupRandPartC ( ) ; case NO_RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case NO_RAND_PART_B_STATE : return setupNoRandPartB ( ) ; case NO_RAND_PART_C_STATE : return setupNoRandPartC ( ) ; default : throw new IllegalStateException ( ) ; } } private boolean init ( boolean isFirstStream ) throws IOException { } this . su_ch2 = su_ch2Shadow ^ = ( this . su_rNToGo = = 1 ) ? 1 : 0 ; this . su_i2 + + ; this . currentState = RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; this . su_ch2 = su_ch2Shadow ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_i2 + + ; this . currentState = NO_RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; private int setupRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { this . crc . updateCRC ( this . su_ch2 ) ; this . su_j2 + + ; return this . su_ch2 ; private int setupNoRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { int su_ch2Shadow = this . su_ch2 ; this . crc . updateCRC ( su_ch2Shadow ) ; this . su_j2 + + ; this . currentState = NO_RAND_PART_C_STATE ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_22"}
{"buggy_code": "byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i + + ) { dictSize | = ( coder . properties [ i + 1 ] < < ( 8 * i ) ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( \" Dictionary larger than 4GiB maximum size \" ) ;", "fixed_code": "byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i + + ) { dictSize | = ( coder . properties [ i + 1 ] & 0xffl ) < < ( 8 * i ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( \" Dictionary larger than 4GiB maximum size \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_23"}
{"buggy_code": "/ / space but some implementations use the extra digit for big / / sizes / uids / gids . . . byte trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } else { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , end - 1 , trailer ) ) ; } trailer = buffer [ end - 1 ] ; while ( start < end - 1 & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) {", "fixed_code": "/ / space but some implementations use the extra digit for big / / sizes / uids / gids . . . byte trailer = buffer [ end - 1 ] ; while ( start < end & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_24"}
{"buggy_code": "this . allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor ; / / haven ' t read anything so far } public ZipArchiveEntry getNextZipEntry ( ) throws IOException {", "fixed_code": "this . allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor ; / / haven ' t read anything so far buf . limit ( 0 ) ; } public ZipArchiveEntry getNextZipEntry ( ) throws IOException {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_25"}
{"buggy_code": "numToSkip - = skipped ; } return available - numToSkip ; }", "fixed_code": "numToSkip - = skipped ; } if ( numToSkip > 0 ) { byte [ ] skipBuf = new byte [ SKIP_BUF_SIZE ] ; while ( numToSkip > 0 ) { int read = readFully ( input , skipBuf , 0 , ( int ) Math . min ( numToSkip , SKIP_BUF_SIZE ) ) ; if ( read < 1 ) { break ; } numToSkip - = read ; } } return available - numToSkip ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_26"}
{"buggy_code": "end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "fixed_code": "end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_27"}
{"buggy_code": "numToRead = Math . min ( numToRead , available ( ) ) ; totalRead = is . read ( buf , offset , numToRead ) ; count ( totalRead ) ; if ( totalRead = = - 1 ) { hasHitEOF = true ; } else { entryOffset + = totalRead ; }", "fixed_code": "numToRead = Math . min ( numToRead , available ( ) ) ; totalRead = is . read ( buf , offset , numToRead ) ; if ( totalRead = = - 1 ) { if ( numToRead > 0 ) { throw new IOException ( \" Truncated TAR archive \" ) ; } hasHitEOF = true ; } else { count ( totalRead ) ; entryOffset + = totalRead ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_28"}
{"buggy_code": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { return new JarArchiveOutputStream ( out ) ; } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { return new ArjArchiveInputStream ( in ) ; } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; } private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) private final boolean useUnicodeExtraFields ; String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "fixed_code": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new JarArchiveOutputStream ( out , entryEncoding ) ; } else { return new JarArchiveOutputStream ( out ) ; } } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { if ( entryEncoding ! = null ) { return new ArjArchiveInputStream ( in , entryEncoding ) ; } else { return new ArjArchiveInputStream ( in ) ; } } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; } private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ; private final boolean useUnicodeExtraFields ; String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { this . encoding = encoding ; zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_29"}
{"buggy_code": "private boolean closed = false ; private final OutputStream out ; * @ throws IOException on error public void finish ( ) throws IOException { writeEOFRecord ( ) ; writeEOFRecord ( ) ; } currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; }", "fixed_code": "private boolean closed = false ; private boolean haveUnclosedEntry = false ; private final OutputStream out ; * @ throws IOException on error public void finish ( ) throws IOException { if ( haveUnclosedEntry ) { throw new IOException ( \" This archives contains unclosed entries . \" ) ; } writeEOFRecord ( ) ; writeEOFRecord ( ) ; } currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; haveUnclosedEntry = true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_3"}
{"buggy_code": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } final int hi = offs + len ; int destOffs = offs ;", "fixed_code": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } if ( len = = 0 ) { return 0 ; } final int hi = offs + len ; int destOffs = offs ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_30"}
{"buggy_code": "for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; if ( currentByte = = 0 ) { break ; } / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "fixed_code": "for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_31"}
{"buggy_code": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Integer . parseInt ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Integer . parseInt ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "fixed_code": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Long . parseLong ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Long . parseLong ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_32"}
{"buggy_code": "return new ZCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) { * @ since 1 . 9 public class DeflateCompressorInputStream extends CompressorInputStream { private final InputStream in ; * * @ since 1 . 9 }", "fixed_code": "return new ZCompressorInputStream ( in ) ; } if ( DeflateCompressorInputStream . matches ( signature , signatureLength ) ) { return new DeflateCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) { * @ since 1 . 9 public class DeflateCompressorInputStream extends CompressorInputStream { private static final int MAGIC_1 = 0x78 ; private static final int MAGIC_2a = 0x01 ; private static final int MAGIC_2b = 0x5e ; private static final int MAGIC_2c = 0x9c ; private static final int MAGIC_2d = 0xda ; private final InputStream in ; * * @ since 1 . 9 public static boolean matches ( byte [ ] signature , int length ) { return length > 3 & & signature [ 0 ] = = MAGIC_1 & & ( signature [ 1 ] = = ( byte ) MAGIC_2a | | signature [ 1 ] = = ( byte ) MAGIC_2b | | signature [ 1 ] = = ( byte ) MAGIC_2c | | signature [ 1 ] = = ( byte ) MAGIC_2d ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_33"}
{"buggy_code": "public class X7875_NewUnix implements ZipExtraField , Cloneable , Serializable { private static final ZipShort HEADER_ID = new ZipShort ( 0x7875 ) ; private static final BigInteger ONE_THOUSAND = BigInteger . valueOf ( 1000 ) ; private static final long serialVersionUID = 1L ; * @ return a < code > ZipShort < / code > for the length of the data of this extra field public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; }", "fixed_code": "public class X7875_NewUnix implements ZipExtraField , Cloneable , Serializable { private static final ZipShort HEADER_ID = new ZipShort ( 0x7875 ) ; private static final ZipShort ZERO = new ZipShort ( 0 ) ; private static final BigInteger ONE_THOUSAND = BigInteger . valueOf ( 1000 ) ; private static final long serialVersionUID = 1L ; * @ return a < code > ZipShort < / code > for the length of the data of this extra field public ZipShort getCentralDirectoryLength ( ) { return ZERO ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_34"}
{"buggy_code": "* @ since 1 . 5 public static boolean verifyCheckSum ( byte [ ] header ) { long storedSum = 0 ; long unsignedSum = 0 ; long signedSum = 0 ; for ( int i = 0 ; i < header . length ; i + + ) { byte b = header [ i ] ; if ( CHKSUM_OFFSET < = i & & i < CHKSUM_OFFSET + CHKSUMLEN ) { if ( ' 0 ' < = b & & b < = ' 7 ' & & digits + + < 6 ) { storedSum = storedSum * 8 + b - ' 0 ' ; } else if ( digits > 0 ) { digits = 6 ; } b = ' ' ; } unsignedSum + = 0xff & b ;", "fixed_code": "* @ since 1 . 5 public static boolean verifyCheckSum ( byte [ ] header ) { long storedSum = parseOctal ( header , CHKSUM_OFFSET , CHKSUMLEN ) ; long unsignedSum = 0 ; long signedSum = 0 ; for ( int i = 0 ; i < header . length ; i + + ) { byte b = header [ i ] ; if ( CHKSUM_OFFSET < = i & & i < CHKSUM_OFFSET + CHKSUMLEN ) { b = ' ' ; } unsignedSum + = 0xff & b ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_35"}
{"buggy_code": "} private InputStream getCurrentStream ( ) throws IOException { if ( deferredBlockStreams . isEmpty ( ) ) { throw new IllegalStateException ( \" No current 7z entry ( call getNextEntry ( ) first ) . \" ) ; }", "fixed_code": "} private InputStream getCurrentStream ( ) throws IOException { if ( archive . files [ currentEntryIndex ] . getSize ( ) = = 0 ) { return new ByteArrayInputStream ( new byte [ 0 ] ) ; } if ( deferredBlockStreams . isEmpty ( ) ) { throw new IllegalStateException ( \" No current 7z entry ( call getNextEntry ( ) first ) . \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_36"}
{"buggy_code": "int read = 0 ; while ( ( ch = i . read ( ) ) ! = - 1 ) { read + + ; if ( ch = = ' ' ) { / / Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) ! = - 1 ) {", "fixed_code": "int read = 0 ; while ( ( ch = i . read ( ) ) ! = - 1 ) { read + + ; if ( ch = = ' \\ n ' ) { / / blank line in header break ; } else if ( ch = = ' ' ) { / / End of length string / / Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) ! = - 1 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_37"}
{"buggy_code": "return true ; } if ( getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "fixed_code": "return true ; } if ( ! isPaxHeader ( ) & & ! isGlobalPaxHeader ( ) & & getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_38"}
{"buggy_code": "public class ArchiveUtils { private ArchiveUtils ( ) { * @ since Compress 1 . 12 public static String sanitize ( String s ) { final char [ ] chars = s . toCharArray ( ) ; final int len = chars . length ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "public class ArchiveUtils { private static final int MAX_SANITIZED_NAME_LENGTH = 255 ; private ArchiveUtils ( ) { * @ since Compress 1 . 12 public static String sanitize ( String s ) { final char [ ] cs = s . toCharArray ( ) ; final char [ ] chars = cs . length < = MAX_SANITIZED_NAME_LENGTH ? cs : Arrays . copyOf ( cs , MAX_SANITIZED_NAME_LENGTH ) ; if ( cs . length > MAX_SANITIZED_NAME_LENGTH ) { for ( int i = MAX_SANITIZED_NAME_LENGTH - 3 ; i < MAX_SANITIZED_NAME_LENGTH ; i + + ) { chars [ i ] = ' . ' ; } } final int len = chars . length ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_39"}
{"buggy_code": "public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; out . close ( ) ; this . closed = true ; } public void close ( ) throws IOException { if ( ! closed ) { finish ( ) ; buffer . close ( ) ; out . close ( ) ; closed = true ; * @ exception IOException if an I / O error occurs . public void close ( ) throws IOException { finish ( ) ; if ( raf ! = null ) { raf . close ( ) ; } results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } return results ; }", "fixed_code": "public void close ( ) throws IOException { if ( ! this . closed ) { out . close ( ) ; this . closed = true ; } public void close ( ) throws IOException { if ( ! closed ) { buffer . close ( ) ; out . close ( ) ; closed = true ; * @ exception IOException if an I / O error occurs . public void close ( ) throws IOException { if ( raf ! = null ) { raf . close ( ) ; } results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } out . finish ( ) ; return results ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_4"}
{"buggy_code": "if ( count < 0 | | count > MAXIMUM_CACHE_SIZE ) { throw new IllegalArgumentException ( \" count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE ) ; } while ( bitsCachedSize < count ) { final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } bitsCachedSize + = 8 ; } / / bitsCachedSize > = 57 and left - shifting it 8 bits would cause an overflow final long bitsOut ; if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { bitsOut = ( bitsCached & MASKS [ count ] ) ; bitsCached > > > = count ; bitsOut = ( bitsCached > > ( bitsCachedSize - count ) ) & MASKS [ count ] ; } bitsCachedSize - = count ; return bitsOut ; } }", "fixed_code": "if ( count < 0 | | count > MAXIMUM_CACHE_SIZE ) { throw new IllegalArgumentException ( \" count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE ) ; } while ( bitsCachedSize < count & & bitsCachedSize < 57 ) { final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } bitsCachedSize + = 8 ; } int overflowBits = 0 ; long overflow = 0l ; if ( bitsCachedSize < count ) { / / bitsCachedSize > = 57 and left - shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize ; overflowBits = 8 - bitsToAddCount ; final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { long bitsToAdd = nextByte & MASKS [ bitsToAddCount ] ; bitsCached | = ( bitsToAdd < < bitsCachedSize ) ; overflow = ( nextByte > > > bitsToAddCount ) & MASKS [ overflowBits ] ; } else { bitsCached < < = bitsToAddCount ; long bitsToAdd = ( nextByte > > > ( overflowBits ) ) & MASKS [ bitsToAddCount ] ; bitsCached | = bitsToAdd ; overflow = nextByte & MASKS [ overflowBits ] ; } bitsCachedSize = count ; } final long bitsOut ; if ( overflowBits = = 0 ) { if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { bitsOut = ( bitsCached & MASKS [ count ] ) ; bitsCached > > > = count ; bitsOut = ( bitsCached > > ( bitsCachedSize - count ) ) & MASKS [ count ] ; } bitsCachedSize - = count ; } else { bitsOut = bitsCached & MASKS [ count ] ; bitsCached = overflow ; bitsCachedSize = overflowBits ; } return bitsOut ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_40"}
{"buggy_code": "if ( sig . equals ( ZipLong . CFH_SIG ) | | sig . equals ( ZipLong . AED_SIG ) ) { hitCentralDirectory = true ; skipRemainderOfArchive ( ) ; } if ( ! sig . equals ( ZipLong . LFH_SIG ) ) { return null ; } int off = WORD ;", "fixed_code": "if ( sig . equals ( ZipLong . CFH_SIG ) | | sig . equals ( ZipLong . AED_SIG ) ) { hitCentralDirectory = true ; skipRemainderOfArchive ( ) ; return null ; } if ( ! sig . equals ( ZipLong . LFH_SIG ) ) { throw new ZipException ( String . format ( \" Unexpected record signature : 0X % X \" , sig . getValue ( ) ) ) ; } int off = WORD ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_41"}
{"buggy_code": "* Bits used to indicate the filesystem object type . * @ since 1 . 14 * @ return true if the entry represents a unix symlink , false otherwise . public boolean isUnixSymlink ( ) { return ( getUnixMode ( ) & UnixStat . LINK_FLAG ) = = UnixStat . LINK_FLAG ; }", "fixed_code": "* Bits used to indicate the filesystem object type . * @ since 1 . 14 int FILE_TYPE_FLAG = 0170000 ; * @ return true if the entry represents a unix symlink , false otherwise . public boolean isUnixSymlink ( ) { return ( getUnixMode ( ) & UnixStat . FILE_TYPE_FLAG ) = = UnixStat . LINK_FLAG ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_42"}
{"buggy_code": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; * @ throws IOException on error protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ze . getMethod ( ) ! = DEFLATED | | channel ! = null ) { return ; } writeCounted ( DD_SIG ) ; return versionNeededToExtractMethod ( zipMethod ) ; } private boolean usesDataDescriptor ( final int zipMethod ) { return zipMethod = = DEFLATED & & channel = = null ; } private int versionNeededToExtractMethod ( int zipMethod ) {", "fixed_code": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) , phased ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod , phased ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; * @ throws IOException on error protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ! usesDataDescriptor ( ze . getMethod ( ) , false ) ) { return ; } writeCounted ( DD_SIG ) ; return versionNeededToExtractMethod ( zipMethod ) ; } private boolean usesDataDescriptor ( final int zipMethod , boolean phased ) { return ! phased & & zipMethod = = DEFLATED & & channel = = null ; } private int versionNeededToExtractMethod ( int zipMethod ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_43"}
{"buggy_code": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } formatBigIntegerBinary ( value , buf , offset , length , negative ) ; buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "fixed_code": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } else { formatBigIntegerBinary ( value , buf , offset , length , negative ) ; } buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_45"}
{"buggy_code": "} private static ZipLong unixTimeToZipLong ( long l ) { final long TWO_TO_32 = 0x100000000L ; if ( l > = TWO_TO_32 ) { throw new IllegalArgumentException ( \" X5455 timestamps must fit in a signed 32 bit integer : \" + l ) ; } return new ZipLong ( l ) ;", "fixed_code": "} private static ZipLong unixTimeToZipLong ( long l ) { if ( l < Integer . MIN_VALUE | | l > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( \" X5455 timestamps must fit in a signed 32 bit integer : \" + l ) ; } return new ZipLong ( l ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_46"}
{"buggy_code": "if ( ae instanceof ZipArchiveEntry ) { final ZipArchiveEntry ze = ( ZipArchiveEntry ) ae ; return ZipUtil . canHandleEntryData ( ze ) & & supportsDataDescriptorFor ( ze ) ; } return false ; } throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . DATA_DESCRIPTOR , current . entry ) ; } int read ; if ( current . entry . getMethod ( ) = = ZipArchiveOutputStream . STORED ) { * Whether the compressed size for the entry is either known or * not required by the compression method being used .", "fixed_code": "if ( ae instanceof ZipArchiveEntry ) { final ZipArchiveEntry ze = ( ZipArchiveEntry ) ae ; return ZipUtil . canHandleEntryData ( ze ) & & supportsDataDescriptorFor ( ze ) & & supportsCompressedSizeFor ( ze ) ; } return false ; } throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . DATA_DESCRIPTOR , current . entry ) ; } if ( ! supportsCompressedSizeFor ( current . entry ) ) { throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . UNKNOWN_COMPRESSED_SIZE , current . entry ) ; } int read ; if ( current . entry . getMethod ( ) = = ZipArchiveOutputStream . STORED ) { * Whether the compressed size for the entry is either known or * not required by the compression method being used . private boolean supportsCompressedSizeFor ( final ZipArchiveEntry entry ) { return entry . getCompressedSize ( ) ! = ArchiveEntry . SIZE_UNKNOWN | | entry . getMethod ( ) = = ZipEntry . DEFLATED | | entry . getMethod ( ) = = ZipMethod . ENHANCED_DEFLATED . getCode ( ) | | ( entry . getGeneralPurposeBit ( ) . usesDataDescriptor ( ) & & allowStoredEntriesWithDataDescriptor & & entry . getMethod ( ) = = ZipEntry . STORED ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_47"}
{"buggy_code": "* If getNextEnxtry has been called , the entry metadata is stored in * currentEntry . public ArArchiveInputStream ( final InputStream pInput ) { input = pInput ; * if the entry could not be read public ArArchiveEntry getNextArEntry ( ) throws IOException { / / hit EOF before previous entry was complete / / TODO : throw an exception instead ? if ( offset = = 0 ) { final byte [ ] expected = ArArchiveEntry . HEADER . getBytes ( ) ; } } / / hit eof if ( input . available ( ) = = 0 ) { return null ; } if ( offset % 2 ! = 0 ) { read ( ) ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; } } return new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; } closed = true ; input . close ( ) ; } } public int read ( ) throws IOException { final int ret = input . read ( ) ; offset + = ( ret > 0 ? 1 : 0 ) ; return ret ; } public int read ( byte [ ] b ) throws IOException { public int read ( byte [ ] b , final int off , final int len ) throws IOException { int toRead = len ; final int ret = this . input . read ( b , off , toRead ) ; offset + = ( ret > 0 ? ret : 0 ) ; return ret ;", "fixed_code": "* If getNextEnxtry has been called , the entry metadata is stored in * currentEntry . private ArArchiveEntry currentEntry = null ; private long entryOffset = - 1 ; public ArArchiveInputStream ( final InputStream pInput ) { input = pInput ; * if the entry could not be read public ArArchiveEntry getNextArEntry ( ) throws IOException { if ( currentEntry ! = null ) { final long entryEnd = entryOffset + currentEntry . getLength ( ) ; while ( offset < entryEnd ) { int x = read ( ) ; if ( x = = - 1 ) { / / hit EOF before previous entry was complete / / TODO : throw an exception instead ? return null ; } } currentEntry = null ; } if ( offset = = 0 ) { final byte [ ] expected = ArArchiveEntry . HEADER . getBytes ( ) ; } } if ( offset % 2 ! = 0 ) { if ( read ( ) < 0 ) { / / hit eof return null ; } } if ( input . available ( ) = = 0 ) { return null ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; } } entryOffset = offset ; currentEntry = new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; return currentEntry ; } closed = true ; input . close ( ) ; } currentEntry = null ; } public int read ( ) throws IOException { byte [ ] single = new byte [ 1 ] ; int num = read ( single , 0 , 1 ) ; return num = = - 1 ? - 1 : single [ 0 ] & 0xff ; } public int read ( byte [ ] b ) throws IOException { public int read ( byte [ ] b , final int off , final int len ) throws IOException { int toRead = len ; if ( currentEntry ! = null ) { final long entryEnd = entryOffset + currentEntry . getLength ( ) ; if ( len > 0 & & entryEnd > offset ) { toRead = ( int ) Math . min ( len , entryEnd - offset ) ; } else { return - 1 ; } } final int ret = this . input . read ( b , off , toRead ) ; offset + = ( ret > 0 ? ret : 0 ) ; return ret ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Compress_47"}
{"buggy_code": "} catch ( DataFormatException e ) { throw new ZipException ( e . getMessage ( ) ) ; } if ( read = = 0 & & inf . finished ( ) ) { return - 1 ; } crc . update ( buffer , start , read ) ; return read ;", "fixed_code": "} catch ( DataFormatException e ) { throw new ZipException ( e . getMessage ( ) ) ; } if ( read = = 0 ) { if ( inf . finished ( ) ) { return - 1 ; } else if ( lengthOfLastRead = = - 1 ) { throw new IOException ( \" Truncated ZIP file \" ) ; } } crc . update ( buffer , start , read ) ; return read ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_6"}
{"buggy_code": "public ZipArchiveEntry ( String name ) { super ( name ) ; }", "fixed_code": "public ZipArchiveEntry ( String name ) { super ( name ) ; setName ( name ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Compress_6"}
{"buggy_code": "int end = offset + length ; for ( int i = offset ; i < end ; + + i ) { if ( buffer [ i ] = = 0 ) { break ; } result . append ( ( char ) buffer [ i ] ) ; } return result . toString ( ) ;", "fixed_code": "int end = offset + length ; for ( int i = offset ; i < end ; + + i ) { byte b = buffer [ i ] ; if ( b = = 0 ) { / / Trailing null break ; } result . append ( ( char ) ( b & 0xFF ) ) ; / / Allow for sign - extension } return result . toString ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_7"}
{"buggy_code": "public static long parseOctal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; int start = offset ; for ( int i = start ; i < end ; i + + ) { final byte currentByte = buffer [ i ] ; if ( currentByte = = 0 ) { break ; } / / Skip leading spaces if ( currentByte = = ( byte ) ' ' | | currentByte = = ' 0 ' ) { if ( stillPadding ) { continue ; } if ( currentByte = = ( byte ) ' ' ) { break ; } } / / Must have trailing NUL or space / / May have additional NUL or space stillPadding = false ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "fixed_code": "public static long parseOctal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; int end = offset + length ; int start = offset ; if ( length < 2 ) { throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; }  boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; } / / Skip leading spaces while ( start < end ) { if ( buffer [ start ] = = ' ' ) { start + + ; } else { break ; } } / / Must have trailing NUL or space byte trailer ; trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } else { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , end - 1 , trailer ) ) ; } / / May have additional NUL or space trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_8"}
{"buggy_code": "}", "fixed_code": "} @ Deprecated @ Override public int getCount ( ) { return ( int ) getBytesWritten ( ) ; } @ Override public long getBytesWritten ( ) { return ( ( CountingOutputStream ) out ) . getBytesWritten ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Compress_9"}
{"buggy_code": "@ Override public int read ( ) throws IOException { int current = super . read ( ) ; if ( current = = ' \\ n ' ) { lineCounter + + ; } lastChar = current ;", "fixed_code": "@ Override public int read ( ) throws IOException { int current = super . read ( ) ; if ( current = = ' \\ r ' | | ( current = = ' \\ n ' & & lastChar ! = ' \\ r ' ) ) { lineCounter + + ; } lastChar = current ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_1"}
{"buggy_code": "* @ return a copy of the header map that iterates in column order . public Map < String , Integer > getHeaderMap ( ) { return new LinkedHashMap < String , Integer > ( this . headerMap ) ; }", "fixed_code": "* @ return a copy of the header map that iterates in column order . public Map < String , Integer > getHeaderMap ( ) { return this . headerMap = = null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Csv_1"}
{"buggy_code": "this . format . validate ( ) ; / / TODO : Is it a good idea to do this here instead of on the first call to a print method ? / / It seems a pain to have to track whether the header has already been printed or not . } / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =", "fixed_code": "this . format . validate ( ) ; / / TODO : Is it a good idea to do this here instead of on the first call to a print method ? / / It seems a pain to have to track whether the header has already been printed or not . if ( format . getHeader ( ) ! = null ) { this . printRecord ( ( Object [ ] ) format . getHeader ( ) ) ; } } / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_10"}
{"buggy_code": "import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; return this ; } } / / merge multiple < head > or < body > contents into one , delete the remainder , and ensure they are owned by < html > / / ensure parented by < html > / / fast method to get first by tag name , used for html , head , body finders private Element findFirstElementByTagName ( String tag , Node node ) {", "fixed_code": "import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import org . jsoup . select . Elements ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; normaliseStructure ( \" head \" , htmlEl ) ; normaliseStructure ( \" body \" , htmlEl ) ; return this ; } } / / merge multiple < head > or < body > contents into one , delete the remainder , and ensure they are owned by < html > private void normaliseStructure ( String tag , Element htmlEl ) { Elements elements = this . getElementsByTag ( tag ) ; Element master = elements . first ( ) ; / / will always be available as created above if not existent if ( elements . size ( ) > 1 ) { / / dupes , move contents to master List < Node > toMove = new ArrayList < Node > ( ) ; for ( int i = 1 ; i < elements . size ( ) ; i + + ) { Node dupe = elements . get ( i ) ; for ( Node node : dupe . childNodes ) toMove . add ( node ) ; dupe . remove ( ) ; }  for ( Node dupe : toMove ) master . appendChild ( dupe ) ; } / / ensure parented by < html > if ( ! master . parent ( ) . equals ( htmlEl ) ) { htmlEl . appendChild ( master ) ; / / includes remove ( ) } } / / fast method to get first by tag name , used for html , head , body finders private Element findFirstElementByTagName ( String tag , Node node ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_12"}
{"buggy_code": "* Note : this is currently like { @ link # RFC4180 } plus { @ link # withAllowMissingColumnNames ( boolean ) withAllowMissingColumnNames ( true ) } . * < / p > public static final CSVFormat EXCEL = DEFAULT . withIgnoreEmptyLines ( false ) ;", "fixed_code": "* Note : this is currently like { @ link # RFC4180 } plus { @ link # withAllowMissingColumnNames ( boolean ) withAllowMissingColumnNames ( true ) } . * < / p > public static final CSVFormat EXCEL = DEFAULT . withIgnoreEmptyLines ( false ) . withAllowMissingColumnNames ( true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Csv_12"}
{"buggy_code": "* http : / / dev . mysql . com / doc / refman / 5 . 1 / en / load - data . html < / a > public static final CSVFormat MYSQL = DEFAULT . withDelimiter ( TAB ) . withEscape ( BACKSLASH ) . withIgnoreEmptyLines ( false ) . withQuote ( null ) . withRecordSeparator ( LF ) ;", "fixed_code": "* http : / / dev . mysql . com / doc / refman / 5 . 1 / en / load - data . html < / a > public static final CSVFormat MYSQL = DEFAULT . withDelimiter ( TAB ) . withEscape ( BACKSLASH ) . withIgnoreEmptyLines ( false ) . withQuote ( null ) . withRecordSeparator ( LF ) . withNullString ( \" \\ \\ N \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_13"}
{"buggy_code": "} catch ( NumberFormatException e ) { } / / skip } else { String name = m . group ( 1 ) . toLowerCase ( ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } for ( Object [ ] entity : baseArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; baseByVal . put ( c , ( ( String ) entity [ 0 ] ) . toLowerCase ( ) ) ; } for ( Object [ ] entity : fullArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; full . put ( ( String ) entity [ 0 ] , c ) ; fullByVal . put ( c , ( ( String ) entity [ 0 ] ) . toLowerCase ( ) ) ; } }", "fixed_code": "} catch ( NumberFormatException e ) { } / / skip } else { String name = m . group ( 1 ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } for ( Object [ ] entity : baseArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; baseByVal . put ( c , ( ( String ) entity [ 0 ] ) ) ; } for ( Object [ ] entity : fullArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; full . put ( ( String ) entity [ 0 ] , c ) ; fullByVal . put ( c , ( ( String ) entity [ 0 ] ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Csv_13"}
{"buggy_code": "char c = value . charAt ( pos ) ; / / RFC4180 ( https : / / tools . ietf . org / html / rfc4180 ) TEXTDATA = % x20 - 21 / % x23 - 2B / % x2D - 7E if ( newRecord & & ( c < ' 0 ' | | c > ' 9 ' & & c < ' A ' | | c > ' Z ' & & c < ' a ' | | c > ' z ' ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now", "fixed_code": "char c = value . charAt ( pos ) ; / / RFC4180 ( https : / / tools . ietf . org / html / rfc4180 ) TEXTDATA = % x20 - 21 / % x23 - 2B / % x2D - 7E if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_14"}
{"buggy_code": "} else { char c = value . charAt ( pos ) ; if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "fixed_code": "} else { char c = value . charAt ( pos ) ; if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_15"}
{"buggy_code": "private final Lexer lexer ; private final List < String > recordList = new ArrayList < > ( ) ; this . format = format ; this . lexer = new Lexer ( format , new ExtendedBufferedReader ( reader ) ) ; this . headerMap = this . initializeHeader ( ) ; this . characterOffset = characterOffset ; this . recordNumber = recordNumber - 1 ; @ Override public Iterator < CSVRecord > iterator ( ) { return new Iterator < CSVRecord > ( ) { private CSVRecord current ; private CSVRecord getNextRecord ( ) { throw new UnsupportedOperationException ( ) ; } } ; }", "fixed_code": "private final Lexer lexer ; private final CSVRecordIterator csvRecordIterator ; private final List < String > recordList = new ArrayList < > ( ) ; this . format = format ; this . lexer = new Lexer ( format , new ExtendedBufferedReader ( reader ) ) ; this . csvRecordIterator = new CSVRecordIterator ( ) ; this . headerMap = this . initializeHeader ( ) ; this . characterOffset = characterOffset ; this . recordNumber = recordNumber - 1 ; @ Override public Iterator < CSVRecord > iterator ( ) { return csvRecordIterator ; }  class CSVRecordIterator implements Iterator < CSVRecord > { private CSVRecord current ; private CSVRecord getNextRecord ( ) { throw new UnsupportedOperationException ( ) ; } } ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_16"}
{"buggy_code": "\" No header mapping was specified , the record values can ' t be accessed by name \" ) ; } final Integer index = mapping . get ( name ) ; return index ! = null ? values [ index . intValue ( ) ] : null ; }", "fixed_code": "\" No header mapping was specified , the record values can ' t be accessed by name \" ) ; } final Integer index = mapping . get ( name ) ; try { return index ! = null ? values [ index . intValue ( ) ] : null ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( String . format ( \" Index for header ' % s ' is % d but CSVRecord only has % d values ! \" , name , index . intValue ( ) , values . length ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_2"}
{"buggy_code": "throw new IOException ( \" EOF whilst processing escape sequence \" ) ; default : / / Now check for meta - characters return c ; / / indicate unexpected char - available from in . getLastChar ( ) } }", "fixed_code": "throw new IOException ( \" EOF whilst processing escape sequence \" ) ; default : / / Now check for meta - characters if ( isDelimiter ( c ) | | isEscape ( c ) | | isQuoteChar ( c ) | | isCommentStart ( c ) ) { return c ; } / / indicate unexpected char - available from in . getLastChar ( ) return END_OF_STREAM ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_3"}
{"buggy_code": "public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; out . append ( recordSeparator ) ; newRecord = true ; }", "fixed_code": "public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; if ( recordSeparator ! = null ) { out . append ( recordSeparator ) ; } newRecord = true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_5"}
{"buggy_code": "< M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; map . put ( entry . getKey ( ) , values [ col ] ) ; } return map ; }", "fixed_code": "< M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) { map . put ( entry . getKey ( ) , values [ col ] ) ; } } return map ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_6"}
{"buggy_code": "import java . net . URL ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; / / build the name to index mappings if ( header ! = null ) { for ( int i = 0 ; i < header . length ; i + + ) { hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } }", "fixed_code": "import java . net . URL ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; / / build the name to index mappings if ( header ! = null ) { for ( int i = 0 ; i < header . length ; i + + ) { if ( hdrMap . containsKey ( header [ i ] ) ) { throw new IllegalStateException ( \" The header contains duplicate names : \" + Arrays . toString ( header ) ) ; } hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_7"}
{"buggy_code": "if ( header = = null ) { this . header = null ; } else { this . header = header . clone ( ) ; } this . skipHeaderRecord = skipHeaderRecord ; throw new IllegalStateException ( \" No quotes mode set but no escape character is set \" ) ; } if ( header ! = null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size ( ) ! = header . length ) { throw new IllegalStateException ( \" The header contains duplicate names : \" + Arrays . toString ( header ) ) ; } } }", "fixed_code": "if ( header = = null ) { this . header = null ; } else { Set < String > dupCheck = new HashSet < String > ( ) ; for ( String hdr : header ) { if ( ! dupCheck . add ( hdr ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate entry : ' \" + hdr + \" ' in \" + Arrays . toString ( header ) ) ; } } this . header = header . clone ( ) ; } this . skipHeaderRecord = skipHeaderRecord ; throw new IllegalStateException ( \" No quotes mode set but no escape character is set \" ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_8"}
{"buggy_code": "* @ return the given map . < M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) {", "fixed_code": "* @ return the given map . < M extends Map < String , String > > M putIn ( final M map ) { if ( mapping = = null ) { return map ; } for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Csv_9"}
{"buggy_code": "public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { return new BigDecimal ( numStr ) ; } public static BigDecimal parseBigDecimal ( char [ ] buffer ) throws NumberFormatException { public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { return new BigDecimal ( buffer , offset , len ) ; } } return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( _inputStart > = 0 ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( _segmentSize = = 0 ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "fixed_code": "public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { try { return new BigDecimal ( numStr ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( numStr ) ; } } public static BigDecimal parseBigDecimal ( char [ ] buffer ) throws NumberFormatException { public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { try { return new BigDecimal ( buffer , offset , len ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( new String ( buffer , offset , len ) ) ; } } private static NumberFormatException _badBigDecimal ( String str ) { return new NumberFormatException ( \" Value \\ \" \" + str + \" \\ \" can not be represented as BigDecimal \" ) ; } } return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( ( _inputStart > = 0 ) & & ( _inputBuffer ! = null ) ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( ( _segmentSize = = 0 ) & & ( _currentSegment ! = null ) ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_1"}
{"buggy_code": "if ( _spilloverEnd > = hashArea . length ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } * to work it out , but this is the simplest , fast and seems to do ok . hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash > > > 12 ) ; return hash ; }", "fixed_code": "final int end = ( _hashSize < < 3 ) ; if ( _spilloverEnd > = end ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } * to work it out , but this is the simplest , fast and seems to do ok . hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash < < 3 ) ; / / shuffle back a bit hash + = ( hash > > > 12 ) ; / / and bit more return hash ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_10"}
{"buggy_code": "_hashShared = false ; / / 09 - Sep - 2015 , tatu : As per [ jackson - core # 216 ] , also need to ensure / / we rehash as needed , as need - rehash flag is not copied from parent } if ( _needRehash ) { rehash ( ) ;", "fixed_code": "_hashShared = false ; / / 09 - Sep - 2015 , tatu : As per [ jackson - core # 216 ] , also need to ensure / / we rehash as needed , as need - rehash flag is not copied from parent _verifyNeedForRehash ( ) ; } if ( _needRehash ) { rehash ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_11"}
{"buggy_code": "if ( _parsingContext . expectComma ( ) ) { i = _skipComma ( i ) ; } _updateLocation ( ) ;", "fixed_code": "if ( _parsingContext . expectComma ( ) ) { i = _skipComma ( i ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_12"}
{"buggy_code": "return this ; } @ Override protected void _checkStdFeatureChanges ( int newFeatureFlags , int changedFeatures ) {", "fixed_code": "return this ; } @ Override public JsonGenerator disable ( Feature f ) { super . disable ( f ) ; if ( f = = Feature . QUOTE_FIELD_NAMES ) { _cfgUnqNames = true ; } return this ; } @ Override protected void _checkStdFeatureChanges ( int newFeatureFlags , int changedFeatures ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_13"}
{"buggy_code": "protected final void _verifyRelease ( byte [ ] toRelease , byte [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < = src . length ) ) { throw wrongBuf ( ) ; } } protected final void _verifyRelease ( char [ ] toRelease , char [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < = src . length ) ) { throw wrongBuf ( ) ; } } private IllegalArgumentException wrongBuf ( ) { / / sanity check failed ; trying to return different , smaller buffer . return new IllegalArgumentException ( \" Trying to release buffer not owned by the context \" ) ; } }", "fixed_code": "protected final void _verifyRelease ( byte [ ] toRelease , byte [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < src . length ) ) { throw wrongBuf ( ) ; } } protected final void _verifyRelease ( char [ ] toRelease , char [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < src . length ) ) { throw wrongBuf ( ) ; } } private IllegalArgumentException wrongBuf ( ) { / / sanity check failed ; trying to return different , smaller buffer . return new IllegalArgumentException ( \" Trying to release buffer smaller than original \" ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_14"}
{"buggy_code": "/ / Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken / / check for no buffered context _exposedContext - null / / If all the conditions matches then check for scalar / non - scalar property / / if not scalar and ended successfully , then return null / / else if scalar , and scalar not present in obj / array and ! includePath and INCLUDE_ALL matched once / / then return null / / Anything buffered ? TokenFilterContext ctxt = _exposedContext ;", "fixed_code": "/ / Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken / / check for no buffered context _exposedContext - null / / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & _currToken ! = null & & _exposedContext = = null ) { / / if not scalar and ended successfully , then return null if ( ( _currToken . isStructEnd ( ) & & _headContext . isStartHandled ( ) ) ) { return ( _currToken = null ) ; } / / else if scalar , and scalar not present in obj / array and ! includePath and INCLUDE_ALL matched once / / then return null else if ( _currToken . isScalarValue ( ) & & ! _headContext . isStartHandled ( ) & & ! _includePath & & _itemFilter = = TokenFilter . INCLUDE_ALL ) { return ( _currToken = null ) ; } } / / Anything buffered ? TokenFilterContext ctxt = _exposedContext ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonCore_14"}
{"buggy_code": "* * @ since 2 . 8", "fixed_code": "* * @ since 2 . 8 protected boolean _suppressNextToken ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_16"}
{"buggy_code": "final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . while ( len > 0 ) { int len2 = Math . min ( buf . length , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; writeRaw ( buf , 0 , len2 ) ; / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it offset + = len2 ; len - = len2 ; } * * @ since 2 . 8 . 2", "fixed_code": "final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy if ( len < = buf . length ) { text . getChars ( offset , offset + len , buf , 0 ) ; _writeRawSegment ( buf , 0 , len ) ; return ; } / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . final int maxChunk = ( _outputEnd > > 2 ) + ( _outputEnd > > 4 ) ; / / = = ( 1 / 4 + 1 / 16 ) = = 5 / 16 final int maxBytes = maxChunk * 3 ; while ( len > 0 ) { int len2 = Math . min ( maxChunk , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; if ( ( _outputTail + maxBytes ) > _outputEnd ) { _flushBuffer ( ) ; } / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it if ( len > 0 ) { char ch = buf [ len2 - 1 ] ; if ( ( ch > = SURR1_FIRST ) & & ( ch < = SURR1_LAST ) ) { - - len2 ; } } _writeRawSegment ( buf , 0 , len2 ) ; offset + = len2 ; len - = len2 ; } * * @ since 2 . 8 . 2 private void _writeRawSegment ( char [ ] cbuf , int offset , int end ) throws IOException { main_loop : while ( offset < end ) { inner_loop : while ( true ) { int ch = ( int ) cbuf [ offset ] ; if ( ch > 0x7F ) { break inner_loop ; } _outputBuffer [ _outputTail + + ] = ( byte ) ch ; if ( + + offset > = end ) { break main_loop ; } } char ch = cbuf [ offset + + ] ; if ( ch < 0x800 ) { / / 2 - byte ? _outputBuffer [ _outputTail + + ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; _outputBuffer [ _outputTail + + ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { offset = _outputRawMultiByteChar ( ch , cbuf , offset , end ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_17"}
{"buggy_code": "* * @ since 2 . 7 . 7 protected String _asString ( BigDecimal value ) throws IOException { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector return value . toString ( ) ; } if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; } if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "fixed_code": "* * @ since 2 . 7 . 7 protected final static int MAX_BIG_DECIMAL_SCALE = 9999 ; protected String _asString ( BigDecimal value ) throws IOException { if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector int scale = value . scale ( ) ; if ( ( scale < - MAX_BIG_DECIMAL_SCALE ) | | ( scale > MAX_BIG_DECIMAL_SCALE ) ) { _reportError ( String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , scale , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ) ; } return value . toPlainString ( ) ; } return value . toString ( ) ; } if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; } if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_18"}
{"buggy_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction outBuf [ outPtr + + ] = c ; fract_loop : / / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "fixed_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = c ; fract_loop : / / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_19"}
{"buggy_code": "- ptr ; / / need to push back following separator _inputPtr = ptr ; / / As per # 105 , need separating space between root values ; check here int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { - _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! * NOTE : caller MUST ensure there is at least one character available ; * and that input pointer is AT given char ( not past ) / / caller had pushed it back , before calling ; reset / / caller had pushed it back , before calling ; reset / / TODO ? Handle UTF - 8 char decoding for error reporting", "fixed_code": "_inputPtr = ptr ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( ch ) ; } int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! * NOTE : caller MUST ensure there is at least one character available ; * and that input pointer is AT given char ( not past ) private final void _verifyRootSpace ( int ch ) throws IOException { / / caller had pushed it back , before calling ; reset + + _inputPtr ; switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; } private final void _verifyRootSpace ( int ch ) throws IOException { / / caller had pushed it back , before calling ; reset + + _inputPtr ; / / TODO ? Handle UTF - 8 char decoding for error reporting switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_2"}
{"buggy_code": "public void writeEmbeddedObject ( Object object ) throws IOException { / / 01 - Sep - 2016 , tatu : As per [ core # 318 ] , handle small number of cases throw new JsonGenerationException ( \" No native support for writing embedded objects \" , this ) ; }", "fixed_code": "public void writeEmbeddedObject ( Object object ) throws IOException { / / 01 - Sep - 2016 , tatu : As per [ core # 318 ] , handle small number of cases if ( object = = null ) { writeNull ( ) ; return ; } if ( object instanceof byte [ ] ) { writeBinary ( ( byte [ ] ) object ) ; return ; } throw new JsonGenerationException ( \" No native support for writing embedded objects of type \" + object . getClass ( ) . getName ( ) , this ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_20"}
{"buggy_code": "/ / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { / / if not scalar and ended successfully , and ! includePath , then return null if ( _currToken . isStructEnd ( ) ) { if ( _headContext . isStartHandled ( ) ) { return ( _currToken = null ) ; if ( ! _headContext . isStartHandled ( ) & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } } / / Anything buffered ?", "fixed_code": "/ / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { / / if not scalar and ended successfully , and ! includePath , then return null if ( ! _includePath ) { if ( _currToken . isStructEnd ( ) ) { if ( _headContext . isStartHandled ( ) ) { return ( _currToken = null ) ; if ( ! _headContext . isStartHandled ( ) & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } } } / / Anything buffered ?", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_21"}
{"buggy_code": "} _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _includePath ) { return ( _currToken = t ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return ( _currToken = t ) ; } } / / Otherwise not included ( leaves must be explicitly included ) } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _includePath ) { return ( _currToken = t ) ; } / / if ( _includeImmediateParent ) { . . . f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return ( _currToken = t ) ; } } / / Otherwise not included ( leaves must be explicitly included ) continue main_loop ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { return _nextBuffered ( buffRoot ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return _nextBuffered ( buffRoot ) ; } } / / Otherwise not included ( leaves must be explicitly included ) } } @ Override public JsonToken nextValue ( ) throws IOException {", "fixed_code": "} _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _verifyAllowedMatches ( ) & & _includePath ) { return ( _currToken = t ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return ( _currToken = t ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _verifyAllowedMatches ( ) & & _includePath ) { return ( _currToken = t ) ; } / / if ( _includeImmediateParent ) { . . . f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return ( _currToken = t ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) continue main_loop ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL & & _verifyAllowedMatches ( ) ) { return _nextBuffered ( buffRoot ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return _nextBuffered ( buffRoot ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) } } private final boolean _verifyAllowedMatches ( ) throws IOException { if ( _matchCount = = 0 | | _allowMultipleMatches ) { + + _matchCount ; return true ; } return false ; } @ Override public JsonToken nextValue ( ) throws IOException {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_22"}
{"buggy_code": "/ / @ since 2 . 9 . 8 protected void _reportTooLongIntegral ( int expType , String rawNum ) throws IOException { final String numDesc = _longIntegerDesc ( rawNum ) ; _reportError ( \" Numeric value ( % s ) out of range of % s \" , numDesc , ( expType = = NR_LONG ) ? \" long \" : \" int \" ) ; }", "fixed_code": "/ / @ since 2 . 9 . 8 protected void _reportTooLongIntegral ( int expType , String rawNum ) throws IOException { if ( expType = = NR_INT ) { reportOverflowInt ( rawNum ) ; } else { reportOverflowLong ( rawNum ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_23"}
{"buggy_code": "@ Override public DefaultPrettyPrinter createInstance ( ) { return new DefaultPrettyPrinter ( this ) ; }", "fixed_code": "@ Override public DefaultPrettyPrinter createInstance ( ) { if ( getClass ( ) ! = DefaultPrettyPrinter . class ) { / / since 2 . 10 throw new IllegalStateException ( \" Failed ` createInstance ( ) ` : \" + getClass ( ) . getName ( ) + \" does not override method ; it has to \" ) ; } return new DefaultPrettyPrinter ( this ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonCore_23"}
{"buggy_code": "} char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i < = maxCode ) { if ( codes [ i ] ! = 0 ) { break ; }", "fixed_code": "} char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i < maxCode ) { if ( codes [ i ] ! = 0 ) { break ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_25"}
{"buggy_code": "_currInputRowStart = start - ( _inputEnd - _currInputRowStart ) ; / / And then update buffer settings _inputBuffer = buf ; _inputPtr = start ; _inputEnd = end ;", "fixed_code": "_currInputRowStart = start - ( _inputEnd - _currInputRowStart ) ; / / And then update buffer settings _currBufferStart = start ; _inputBuffer = buf ; _inputPtr = start ; _inputEnd = end ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_26"}
{"buggy_code": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; / / If we have offset , need to omit that from byte offset , so : _bufferRecyclable = bufferRecyclable ; }", "fixed_code": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; _currInputRowStart = start ; / / If we have offset , need to omit that from byte offset , so : _currInputProcessed = - start ; _bufferRecyclable = bufferRecyclable ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_3"}
{"buggy_code": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; / / but above intended maximum , slow to increase by 25 % int newLen = ( len = = MAX_SEGMENT_LEN ) ? ( MAX_SEGMENT_LEN + 1 ) : Math . min ( MAX_SEGMENT_LEN , len + ( len > > 1 ) ) ; return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; }", "fixed_code": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; int newLen = len + ( len > > 1 ) ; / / but above intended maximum , slow to increase by 25 % if ( newLen > MAX_SEGMENT_LEN ) { newLen = len + ( len > > 2 ) ; } return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_4"}
{"buggy_code": "return - 1 ; } for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i + + ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "fixed_code": "return - 1 ; } for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_5"}
{"buggy_code": "return - 1 ; } / / [ core # 176 ] : no leading zeroes allowed for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "fixed_code": "return - 1 ; } / / [ core # 176 ] : no leading zeroes allowed char c = str . charAt ( 0 ) ; if ( c < = ' 0 ' ) { return ( len = = 1 & & c = = ' 0 ' ) ? 0 : - 1 ; } if ( c > ' 9 ' ) { return - 1 ; } for ( int i = 1 ; i < len ; + + i ) { c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_6"}
{"buggy_code": "public int writeValue ( ) { / / Most likely , object : if ( _type = = TYPE_OBJECT ) { _gotName = false ; return STATUS_OK_AFTER_COLON ;", "fixed_code": "public int writeValue ( ) { / / Most likely , object : if ( _type = = TYPE_OBJECT ) { if ( ! _gotName ) { return STATUS_EXPECT_NAME ; } _gotName = false ; + _index ; return STATUS_OK_AFTER_COLON ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_7"}
{"buggy_code": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "fixed_code": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments & & _currentSegment ! = null ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_8"}
{"buggy_code": "if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } return getValueAsString ( null ) ; } if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; } } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( null ) ; } } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( defValue ) ; } } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( null ) ; } } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( defValue ) ; }", "fixed_code": "if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return getValueAsString ( null ) ; } if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; } } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( null ) ; } } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( defValue ) ; } } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( null ) ; } } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( defValue ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonCore_9"}
{"buggy_code": "} else { / / can NOT suppress entries in tabular output jgen . writeNull ( ) ; } } / / otherwise find serializer to use JsonSerializer < Object > ser = _serializer ;", "fixed_code": "} else { / / can NOT suppress entries in tabular output jgen . writeNull ( ) ; } return ; } / / otherwise find serializer to use JsonSerializer < Object > ser = _serializer ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_1"}
{"buggy_code": "int ix = 0 ; JsonToken t ; while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value ; } chunk [ ix + + ] = value ; } / / note : pass String . class , not String [ ] . class , as we need element type for error info String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ; int ix = 0 ; JsonToken t ; while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; } chunk [ ix + + ] = value ; } / / note : pass String . class , not String [ ] . class , as we need element type for error info String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ;", "fixed_code": "int ix = 0 ; JsonToken t ; try { while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value ; } chunk [ ix + + ] = value ; } } catch ( Exception e ) { / / note : pass String . class , not String [ ] . class , as we need element type for error info throw JsonMappingException . wrapWithPath ( e , String . class , ix ) ; } String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ; int ix = 0 ; JsonToken t ; try { while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; } chunk [ ix + + ] = value ; } } catch ( Exception e ) { / / note : pass String . class , not String [ ] . class , as we need element type for error info throw JsonMappingException . wrapWithPath ( e , String . class , ix ) ; } String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_1"}
{"buggy_code": "protected final AnnotatedMember _accessor ; protected MapSerializer _mapSerializer ; @ SuppressWarnings ( \" unchecked \" ) public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , MapSerializer serializer ) { _accessor = accessor ; _property = property ; _mapSerializer = ( MapSerializer ) serializer ; } public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } } / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "fixed_code": "protected final AnnotatedMember _accessor ; protected JsonSerializer < Object > _serializer ; protected MapSerializer _mapSerializer ; @ SuppressWarnings ( \" unchecked \" ) public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , JsonSerializer < ? > serializer ) { _accessor = accessor ; _property = property ; _serializer = ( JsonSerializer < Object > ) serializer ; if ( serializer instanceof MapSerializer ) { _mapSerializer = ( MapSerializer ) serializer ; } } public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } _serializer . serialize ( value , gen , provider ) ; } } / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_10"}
{"buggy_code": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : byte [ ] data = n . binaryValue ( ) ; if ( data ! = null ) { return data ; } if ( n . isPojo ( ) ) { Object ob = ( ( POJONode ) n ) . getPojo ( ) ; if ( ob instanceof byte [ ] ) { return ( byte [ ] ) ob ; } } } / / otherwise return null to mark we have no binary content return null ;", "fixed_code": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : if ( n instanceof TextNode ) { return ( ( TextNode ) n ) . getBinaryValue ( b64variant ) ; } return n . binaryValue ( ) ; } / / otherwise return null to mark we have no binary content return null ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_100"}
{"buggy_code": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "fixed_code": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants if ( t ! = JsonToken . END_OBJECT ) { ctxt . reportWrongTokenException ( this , JsonToken . END_OBJECT , \" Attempted to unwrap ' % s ' value \" , handledType ( ) . getName ( ) ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_101"}
{"buggy_code": "{ / / Note ! Should not skip if ` property ` null since that ' d skip check / / for config overrides , in case of root value if ( property = = null ) { return this ; } JsonFormat . Value format = findFormatOverrides ( serializers , property , handledType ( ) ) ; if ( format = = null ) { return this ;", "fixed_code": "{ / / Note ! Should not skip if ` property ` null since that ' d skip check / / for config overrides , in case of root value JsonFormat . Value format = findFormatOverrides ( serializers , property , handledType ( ) ) ; if ( format = = null ) { return this ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_102"}
{"buggy_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , e . getMessage ( ) ) ) ; } } String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = cause . getMessage ( ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" , import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ;", "fixed_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( e ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , ClassUtil . exceptionMessage ( e ) ) ) ; } } String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = ClassUtil . exceptionMessage ( cause ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" , import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . util . ClassUtil ; public static String exceptionMessage ( Throwable t ) { if ( t instanceof JsonProcessingException ) { return ( ( JsonProcessingException ) t ) . getOriginalMessage ( ) ; } return t . getMessage ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_103"}
{"buggy_code": "final int year = cal . get ( Calendar . YEAR ) ; / / Assuming GregorianCalendar , special handling needed for BCE ( aka BC ) / / 22 - Nov - 2018 , tatu : Handling beyond 4 - digits is not well specified wrt ISO - 8601 , but / / it seems that plus prefix IS mandated . Padding is an open question , but since agreeement / / for max length would be needed , we ewould need to limit to arbitrary length / / like five digits ( erroring out if beyond or padding to that as minimum ) . / / Instead , let ' s just print number out as is and let decoder try to make sense of it . pad4 ( buffer , year ) ; buffer . append ( ' - ' ) ; pad2 ( buffer , cal . get ( Calendar . MONTH ) + 1 ) ; buffer . append ( ' - ' ) ; } } / / Ok . First of all , BCE 1 output ( given as value ` 1 ` in era BCE ) needs to become / / \" + 0000 \" , but rest ( from ` 2 ` up , in that era ) need minus sign . / / as with CE , 4 digit variant needs padding ; beyond that not ( although that part is / / open to debate , needs agreement with receiver ) / / But ` pad4 ( ) ` deals with \" big \" numbers now so : private static void pad2 ( StringBuffer buffer , int value ) { int tens = value / 10 ; if ( h = = 0 ) { buffer . append ( ' 0 ' ) . append ( ' 0 ' ) ; } else { pad2 ( buffer , h ) ; value - = ( 100 * h ) ; } pad2 ( buffer , value ) ;", "fixed_code": "final int year = cal . get ( Calendar . YEAR ) ; / / Assuming GregorianCalendar , special handling needed for BCE ( aka BC ) if ( cal . get ( Calendar . ERA ) = = GregorianCalendar . BC ) { _formatBCEYear ( buffer , year ) ; } else { if ( year > 9999 ) { / / 22 - Nov - 2018 , tatu : Handling beyond 4 - digits is not well specified wrt ISO - 8601 , but / / it seems that plus prefix IS mandated . Padding is an open question , but since agreeement / / for max length would be needed , we ewould need to limit to arbitrary length / / like five digits ( erroring out if beyond or padding to that as minimum ) . / / Instead , let ' s just print number out as is and let decoder try to make sense of it . buffer . append ( ' + ' ) ; } pad4 ( buffer , year ) ; } buffer . append ( ' - ' ) ; pad2 ( buffer , cal . get ( Calendar . MONTH ) + 1 ) ; buffer . append ( ' - ' ) ; } } protected void _formatBCEYear ( StringBuffer buffer , int bceYearNoSign ) { / / Ok . First of all , BCE 1 output ( given as value ` 1 ` in era BCE ) needs to become / / \" + 0000 \" , but rest ( from ` 2 ` up , in that era ) need minus sign . if ( bceYearNoSign = = 1 ) { buffer . append ( \" + 0000 \" ) ; return ; } final int isoYear = bceYearNoSign - 1 ; buffer . append ( ' - ' ) ; / / as with CE , 4 digit variant needs padding ; beyond that not ( although that part is / / open to debate , needs agreement with receiver ) / / But ` pad4 ( ) ` deals with \" big \" numbers now so : pad4 ( buffer , isoYear ) ; } private static void pad2 ( StringBuffer buffer , int value ) { int tens = value / 10 ; if ( h = = 0 ) { buffer . append ( ' 0 ' ) . append ( ' 0 ' ) ; } else { if ( h > 99 ) { / / [ databind # 2167 ] : handle above 9999 correctly buffer . append ( h ) ; } else { pad2 ( buffer , h ) ; } value - = ( 100 * h ) ; } pad2 ( buffer , value ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_104"}
{"buggy_code": "UUID . class , AtomicBoolean . class , StackTraceElement . class , ByteBuffer . class } ; for ( Class < ? > cls : types ) { _classNames . add ( cls . getName ( ) ) ; } for ( Class < ? > cls : FromStringDeserializer . types ( ) ) { _classNames . add ( cls . getName ( ) ) ; } if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } } return null ; }", "fixed_code": "UUID . class , AtomicBoolean . class , StackTraceElement . class , ByteBuffer . class , Void . class } ; for ( Class < ? > cls : types ) { _classNames . add ( cls . getName ( ) ) ; } for ( Class < ? > cls : FromStringDeserializer . types ( ) ) { _classNames . add ( cls . getName ( ) ) ; } if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } if ( rawType = = Void . class ) { return NullifyingDeserializer . instance ; } } return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_105"}
{"buggy_code": "@ Override public int getIntValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; return node . intValue ( ) ; } @ Override public long getLongValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; return node . longValue ( ) ; }", "fixed_code": "@ Override public int getIntValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; if ( ! node . canConvertToInt ( ) ) { reportOverflowInt ( ) ; } return node . intValue ( ) ; } @ Override public long getLongValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; if ( ! node . canConvertToInt ( ) ) { reportOverflowLong ( ) ; } return node . longValue ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_106"}
{"buggy_code": "JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual = = null ) { / / what should this be taken to mean ? / / 17 - Jan - 2019 , tatu : As per [ databind # 2221 ] , better NOT return ` null ` but . . . return null ; } / / . . . would this actually work ? deser = ctxt . findContextualValueDeserializer ( actual , _property ) ;", "fixed_code": "JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual = = null ) { / / what should this be taken to mean ? / / 17 - Jan - 2019 , tatu : As per [ databind # 2221 ] , better NOT return ` null ` but . . . return NullifyingDeserializer . instance ; } / / . . . would this actually work ? deser = ctxt . findContextualValueDeserializer ( actual , _property ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_107"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) @ Override public < T extends TreeNode > T readTree ( JsonParser p ) throws IOException { return ( T ) _bindAsTree ( p ) ; } @ Override * Same as { @ link # _bindAsTree } except end - of - input is reported by returning * { @ code null } , not \" missing node \"", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) @ Override public < T extends TreeNode > T readTree ( JsonParser p ) throws IOException { return ( T ) _bindAsTreeOrNull ( p ) ; } @ Override * Same as { @ link # _bindAsTree } except end - of - input is reported by returning * { @ code null } , not \" missing node \" protected final JsonNode _bindAsTreeOrNull ( JsonParser p ) throws IOException { _config . initialize ( p ) ; if ( _schema ! = null ) { p . setSchema ( _schema ) ; } JsonToken t = p . getCurrentToken ( ) ; if ( t = = null ) { t = p . nextToken ( ) ; if ( t = = null ) { return null ; } } final JsonNode resultNode ; if ( t = = JsonToken . VALUE_NULL ) { resultNode = _config . getNodeFactory ( ) . nullNode ( ) ; } else { final DeserializationContext ctxt = createDeserializationContext ( p ) ; final JsonDeserializer < Object > deser = _findTreeDeserializer ( ctxt ) ; if ( _unwrapRoot ) { resultNode = ( JsonNode ) _unwrapAndDeserialize ( p , ctxt , JSON_NODE_TYPE , deser ) ; } else { resultNode = ( JsonNode ) deser . deserialize ( p , ctxt ) ; if ( _config . isEnabled ( DeserializationFeature . FAIL_ON_TRAILING_TOKENS ) ) { _verifyNoTrailingTokens ( p , ctxt , JSON_NODE_TYPE ) ; } } } return resultNode ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_108"}
{"buggy_code": "protected final boolean _isInt ; switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` return ToStringSerializer . instance ; default : } / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this / / . . . but wouldn ' t it be nice to trigger error via generator ? Alas , / / no method to do that . So we ' ll do . . . / / should never be called / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this } import java . io . IOException ; import java . lang . reflect . Type ; import java . util . Map ; import com . fasterxml . jackson . annotation . JsonFormat ; if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : return ToStringSerializer . instance ; default : }", "fixed_code": "protected final static int MAX_BIG_DECIMAL_SCALE = 9999 ; protected final boolean _isInt ; switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : } public static JsonSerializer < ? > bigDecimalAsStringSerializer ( ) { return BigDecimalAsStringSerializer . BD_INSTANCE ; } final static class BigDecimalAsStringSerializer extends ToStringSerializerBase { final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer ( ) ;  public BigDecimalAsStringSerializer ( ) { super ( BigDecimal . class ) ; } @ Override public boolean isEmpty ( SerializerProvider prov , Object value ) { return valueToString ( value ) . isEmpty ( ) ; } @ Override public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { final String text ; if ( gen . isEnabled ( JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { final BigDecimal bd = ( BigDecimal ) value ; / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this if ( ! _verifyBigDecimalRange ( gen , bd ) ) { / / . . . but wouldn ' t it be nice to trigger error via generator ? Alas , / / no method to do that . So we ' ll do . . . final String errorMsg = String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , bd . scale ( ) , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ; provider . reportMappingProblem ( errorMsg ) ; } text = bd . toPlainString ( ) ; } else { text = value . toString ( ) ; } gen . writeString ( text ) ; } @ Override public String valueToString ( Object value ) { / / should never be called throw new IllegalStateException ( ) ; } / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this protected boolean _verifyBigDecimalRange ( JsonGenerator gen , BigDecimal value ) throws IOException { int scale = value . scale ( ) ; return ( ( scale > = - MAX_BIG_DECIMAL_SCALE ) & & ( scale < = MAX_BIG_DECIMAL_SCALE ) ) ; } } } import java . io . IOException ; import java . lang . reflect . Type ; import java . math . BigDecimal ; import java . util . Map ; import com . fasterxml . jackson . annotation . JsonFormat ; if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return NumberSerializer . bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_109"}
{"buggy_code": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : return _unknownType ( ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name ) ; if ( actualType ! = null ) { return actualType ; }", "fixed_code": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : context = new TypeBindings ( this , ( Class < ? > ) null ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name , false ) ; if ( actualType ! = null ) { return actualType ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_11"}
{"buggy_code": "private final static Class < ? > CLASS_UNMODIFIABLE_MAP ; static { CLASS_SINGLETON_LIST = list . getClass ( ) ; CLASS_UNMODIFIABLE_LIST = Collections . unmodifiableList ( list ) . getClass ( ) ; / / for [ databind # 2265 ] Map < ? , ? > map = Collections . singletonMap ( \" a \" , \" b \" ) ; CLASS_SINGLETON_MAP = map . getClass ( ) ; } else if ( type . hasRawClass ( CLASS_SINGLETON_SET ) ) { conv = converter ( TYPE_SINGLETON_SET , type , Set . class ) ; / / [ databind # 2265 ] : we may have another impl type for unmodifiable Lists , check both } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_LIST ) ) { conv = converter ( TYPE_UNMODIFIABLE_LIST , type , List . class ) ; } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_SET ) ) { conv = converter ( TYPE_UNMODIFIABLE_SET , type , Set . class ) ;", "fixed_code": "private final static Class < ? > CLASS_UNMODIFIABLE_LIST_ALIAS ; private final static Class < ? > CLASS_UNMODIFIABLE_MAP ; static { CLASS_SINGLETON_LIST = list . getClass ( ) ; CLASS_UNMODIFIABLE_LIST = Collections . unmodifiableList ( list ) . getClass ( ) ; / / for [ databind # 2265 ] CLASS_UNMODIFIABLE_LIST_ALIAS = Collections . unmodifiableList ( new LinkedList < Object > ( ) ) . getClass ( ) ; Map < ? , ? > map = Collections . singletonMap ( \" a \" , \" b \" ) ; CLASS_SINGLETON_MAP = map . getClass ( ) ; } else if ( type . hasRawClass ( CLASS_SINGLETON_SET ) ) { conv = converter ( TYPE_SINGLETON_SET , type , Set . class ) ; / / [ databind # 2265 ] : we may have another impl type for unmodifiable Lists , check both } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_LIST ) | | type . hasRawClass ( CLASS_UNMODIFIABLE_LIST_ALIAS ) ) { conv = converter ( TYPE_UNMODIFIABLE_LIST , type , List . class ) ; } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_SET ) ) { conv = converter ( TYPE_UNMODIFIABLE_SET , type , Set . class ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_110"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new CreatorProperty ( this , deser , _nullProvider ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new FieldProperty ( this , deser , _nullProvider ) ; } @ Override Object readResolve ( ) { return new FieldProperty ( this ) ; } \\ No newline at end of file } return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new MethodProperty ( this , deser , _nullProvider ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdReferenceProperty ( this , deser , _nullProvider ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdValueProperty ( this , deser , _nullProvider ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new SetterlessProperty ( this , deser , _nullProvider ) ; } @ Override set ( instance , value ) ; return instance ; } \\ No newline at end of file } @ Override public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( ) ; } @ Override", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new CreatorProperty ( this , deser , nvp ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new FieldProperty ( this , deser , nvp ) ; } @ Override Object readResolve ( ) { return new FieldProperty ( this ) ; } } \\ No newline at end of file return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new MethodProperty ( this , deser , nvp ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdReferenceProperty ( this , deser , nvp ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdValueProperty ( this , deser , nvp ) ; } @ Override return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new SetterlessProperty ( this , deser , nvp ) ; } @ Override set ( instance , value ) ; return instance ; } } \\ No newline at end of file @ Override public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( _valueDeserializer . getNullValue ( ctxt ) ) ; } @ Override", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_111"}
{"buggy_code": "JsonDeserializer < Object > delegate = null ; if ( _valueInstantiator ! = null ) { / / [ databind # 2324 ] : check both array - delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator . getDelegateCreator ( ) ; if ( delegateCreator ! = null ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; }", "fixed_code": "JsonDeserializer < Object > delegate = null ; if ( _valueInstantiator ! = null ) { / / [ databind # 2324 ] : check both array - delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator . getArrayDelegateCreator ( ) ; if ( delegateCreator ! = null ) { JavaType delegateType = _valueInstantiator . getArrayDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; } else if ( ( delegateCreator = _valueInstantiator . getDelegateCreator ( ) ) ! = null ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_112"}
{"buggy_code": "return ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; }", "fixed_code": "return ( _valueDeserializer = = null ) & & ( _keyDeserializer = = null ) & & ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_12"}
{"buggy_code": "final ObjectIdGenerator . IdKey key = gen . key ( id ) ; * will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "fixed_code": "if ( id = = null ) { return null ; } final ObjectIdGenerator . IdKey key = gen . key ( id ) ; * will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_13"}
{"buggy_code": "result = NullNode . instance ; } else { DeserializationContext ctxt = createDeserializationContext ( jp , _config ) ; JsonDeserializer < Object > deser = _findRootDeserializer ( ctxt , JSON_NODE_TYPE ) ; if ( _unwrapRoot ) { result = ( JsonNode ) _unwrapAndDeserialize ( jp , ctxt , JSON_NODE_TYPE , deser ) ; } else { / / Nope : need to ask provider to resolve it", "fixed_code": "result = NullNode . instance ; } else { DeserializationContext ctxt = createDeserializationContext ( jp , _config ) ; JsonDeserializer < Object > deser = _findTreeDeserializer ( ctxt ) ; if ( _unwrapRoot ) { result = ( JsonNode ) _unwrapAndDeserialize ( jp , ctxt , JSON_NODE_TYPE , deser ) ; } else { protected JsonDeserializer < Object > _findTreeDeserializer ( DeserializationContext ctxt ) throws JsonMappingException { JsonDeserializer < Object > deser = _rootDeserializers . get ( JSON_NODE_TYPE ) ; if ( deser = = null ) { / / Nope : need to ask provider to resolve it deser = ctxt . findRootValueDeserializer ( JSON_NODE_TYPE ) ; if ( deser = = null ) { / / can this happen ? throw new JsonMappingException ( \" Can not find a deserializer for type \" + JSON_NODE_TYPE ) ; } _rootDeserializers . put ( JSON_NODE_TYPE , deser ) ; } return deser ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_14"}
{"buggy_code": "* * @ since 2 . 5 delSer = provider . findValueSerializer ( delegateType ) ; } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } return ( delSer = = _delegateSerializer ) ? this : withDelegate ( _converter , delegateType , delSer ) ; } Object delegateValue = convertValue ( value ) ; _delegateSerializer . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } @ Override public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( delegateValue ) ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } * properly . . . but for now , try this : / / 02 - Apr - 2015 , tatu : For dynamic case , very little we can do _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } / / NOTE : will NOT call contextualization } Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "fixed_code": "* * @ since 2 . 5 public final boolean isJavaLangObject ( ) { return _class = = Object . class ; } if ( ! delegateType . isJavaLangObject ( ) ) { delSer = provider . findValueSerializer ( delegateType ) ; } } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } if ( delSer = = _delegateSerializer & & delegateType = = _delegateType ) { return this ; } return withDelegate ( _converter , delegateType , delSer ) ; } Object delegateValue = convertValue ( value ) ; JsonSerializer < Object > ser = _delegateSerializer ; if ( ser = = null ) { ser = _findSerializer ( value , provider ) ; } ser . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } @ Override public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( delegateValue ) ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } * properly . . . but for now , try this : / / 02 - Apr - 2015 , tatu : For dynamic case , very little we can do if ( _delegateSerializer ! = null ) { _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } } protected JsonSerializer < Object > _findSerializer ( Object value , SerializerProvider serializers ) throws JsonMappingException { / / NOTE : will NOT call contextualization return serializers . findValueSerializer ( value . getClass ( ) ) ; } } Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null & & ! delegateType . hasRawClass ( Object . class ) ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_15"}
{"buggy_code": "_annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous ! = null ) & & previous . equals ( ann ) ; } }", "fixed_code": "_annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous = = null ) | | ! previous . equals ( ann ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_16"}
{"buggy_code": "return ( t . getRawClass ( ) = = Object . class ) | | ( ! t . isConcrete ( ) / / [ databind # 88 ] Should not apply to JSON tree models : | | TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) {", "fixed_code": "return ( t . getRawClass ( ) = = Object . class ) | | ( ! t . isConcrete ( ) / / [ databind # 88 ] Should not apply to JSON tree models : & & ! TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_17"}
{"buggy_code": "protected JsonParser _parser ; protected boolean _hasNextChecked ; if ( managedParser & & ( p ! = null ) & & p . isExpectedStartArrayToken ( ) ) { / / If pointing to START_ARRAY , context should be that ARRAY p . clearCurrentToken ( ) ; / / regardless , recovery context should be whatever context we have now , / / with sole exception of pointing to a start marker , in which case it ' s / / the parent } } @ Override public void close ( ) throws IOException { if ( _parser ! = null ) { _parser . close ( ) ; } } public boolean hasNextValue ( ) throws IOException { if ( _parser = = null ) { return false ; / / fall - through } if ( ! _hasNextChecked ) { JsonToken t = _parser . getCurrentToken ( ) ; _hasNextChecked = true ; if ( t = = null ) { / / un - initialized or cleared ; find next t = _parser . nextToken ( ) ; / / If EOF , no more , or if we hit END_ARRAY ( although we don ' t clear the token ) . if ( t = = null | | t = = JsonToken . END_ARRAY ) { JsonParser jp = _parser ; _parser = null ; if ( _closeParser ) { jp . close ( ) ; } return false ; } } / / fall through } return true ; public T nextValue ( ) throws IOException { if ( ! _hasNextChecked ) { if ( ! hasNextValue ( ) ) { return _throwNoSuchElement ( ) ; } } if ( _parser = = null ) { return _throwNoSuchElement ( ) ; } _hasNextChecked = false ; try { T value ; if ( _updatedValue = = null ) { _deserializer . deserialize ( _parser , _context , _updatedValue ) ; value = _updatedValue ; } return value ; } finally { / / First , a quick check to see if we might have been lucky and no re - sync needed protected < R > R _throwNoSuchElement ( ) { throw new NoSuchElementException ( ) ;", "fixed_code": "protected final static int STATE_CLOSED = 0 ; protected final static int STATE_NEED_RESYNC = 1 ; protected final static int STATE_MAY_HAVE_VALUE = 2 ; protected final static int STATE_HAS_VALUE = 3 ; protected final JsonParser _parser ; protected final JsonStreamContext _seqContext ; protected int _state ; if ( p = = null ) { / / can this occur ? _seqContext = null ; _state = STATE_CLOSED ; } else { JsonStreamContext sctxt = p . getParsingContext ( ) ; if ( managedParser & & p . isExpectedStartArrayToken ( ) ) { / / If pointing to START_ARRAY , context should be that ARRAY p . clearCurrentToken ( ) ; } else { / / regardless , recovery context should be whatever context we have now , / / with sole exception of pointing to a start marker , in which case it ' s / / the parent JsonToken t = p . getCurrentToken ( ) ; if ( ( t = = JsonToken . START_OBJECT ) | | ( t = = JsonToken . START_ARRAY ) ) { sctxt = sctxt . getParent ( ) ; } } _seqContext = sctxt ; _state = STATE_MAY_HAVE_VALUE ; } } @ Override public void close ( ) throws IOException { if ( _state ! = STATE_CLOSED ) { _state = STATE_CLOSED ; if ( _parser ! = null ) { _parser . close ( ) ; } } } public boolean hasNextValue ( ) throws IOException { switch ( _state ) { case STATE_CLOSED : return false ; case STATE_NEED_RESYNC : _resync ( ) ; / / fall - through case STATE_MAY_HAVE_VALUE : JsonToken t = _parser . getCurrentToken ( ) ; if ( t = = null ) { / / un - initialized or cleared ; find next t = _parser . nextToken ( ) ; / / If EOF , no more , or if we hit END_ARRAY ( although we don ' t clear the token ) . if ( t = = null | | t = = JsonToken . END_ARRAY ) { _state = STATE_CLOSED ; if ( _closeParser & & ( _parser ! = null ) ) { _parser . close ( ) ; } return false ; } } _state = STATE_HAS_VALUE ; return true ; case STATE_HAS_VALUE : / / fall through } return true ; public T nextValue ( ) throws IOException { switch ( _state ) { case STATE_CLOSED : return _throwNoSuchElement ( ) ; case STATE_NEED_RESYNC : / / fall - through , will do re - sync case STATE_MAY_HAVE_VALUE : if ( ! hasNextValue ( ) ) { return _throwNoSuchElement ( ) ; } break ; case STATE_HAS_VALUE : break ; } int nextState = STATE_NEED_RESYNC ; try { T value ; if ( _updatedValue = = null ) { _deserializer . deserialize ( _parser , _context , _updatedValue ) ; value = _updatedValue ; } nextState = STATE_MAY_HAVE_VALUE ; return value ; } finally { _state = nextState ; protected void _resync ( ) throws IOException { final JsonParser p = _parser ; / / First , a quick check to see if we might have been lucky and no re - sync needed if ( p . getParsingContext ( ) = = _seqContext ) { return ; } while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = JsonToken . END_ARRAY ) | | ( t = = JsonToken . END_OBJECT ) ) { if ( p . getParsingContext ( ) = = _seqContext ) { p . clearCurrentToken ( ) ; return ; } } else if ( ( t = = JsonToken . START_ARRAY ) | | ( t = = JsonToken . START_OBJECT ) ) { p . skipChildren ( ) ; } else if ( t = = null ) { return ; } } } protected < R > R _throwNoSuchElement ( ) { throw new NoSuchElementException ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_18"}
{"buggy_code": "private JavaType _mapType ( Class < ? > rawClass ) { / / 28 - May - 2015 , tatu : Properties are special , as per [ databind # 810 ] JavaType [ ] typeParams = findTypeParameters ( rawClass , Map . class ) ; / / ok to have no types ( \" raw \" ) if ( typeParams = = null ) {", "fixed_code": "private JavaType _mapType ( Class < ? > rawClass ) { / / 28 - May - 2015 , tatu : Properties are special , as per [ databind # 810 ] if ( rawClass = = Properties . class ) { return MapType . construct ( rawClass , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } JavaType [ ] typeParams = findTypeParameters ( rawClass , Map . class ) ; / / ok to have no types ( \" raw \" ) if ( typeParams = = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_19"}
{"buggy_code": "package org . apache . commons . cli ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . Iterator ; protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = options . getRequiredOptions ( ) ; } protected Options getOptions ( ) {", "fixed_code": "package org . apache . commons . cli ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . Iterator ; protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions ( ) ) ; } protected Options getOptions ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_19"}
{"buggy_code": "@ Override public void writeObject ( Object value ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; } @ Override public void writeTree ( TreeNode node ) throws IOException { / / as with ' writeObject ( ) ' , is codec optional ? _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; }", "fixed_code": "@ Override public void writeObject ( Object value ) throws IOException { if ( value = = null ) { writeNull ( ) ; return ; } Class < ? > raw = value . getClass ( ) ; if ( raw = = byte [ ] . class ) { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; return ; } else if ( _objectCodec = = null ) { / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } } @ Override public void writeTree ( TreeNode node ) throws IOException { if ( node = = null ) { writeNull ( ) ; return ; } if ( _objectCodec = = null ) { / / as with ' writeObject ( ) ' , is codec optional ? _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_2"}
{"buggy_code": "package com . fasterxml . jackson . databind . node ; import com . fasterxml . jackson . annotation . JsonAutoDetect ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . JsonNode ; import com . fasterxml . jackson . databind . SerializerProvider ; * * @ since 2 . 1 public JsonNode setAll ( Map < String , ? extends JsonNode > properties ) { for ( Map . Entry < String , ? extends JsonNode > en : properties . entrySet ( ) ) {", "fixed_code": "package com . fasterxml . jackson . databind . node ; import com . fasterxml . jackson . annotation . JsonAutoDetect ; import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . JsonNode ; import com . fasterxml . jackson . databind . SerializerProvider ; * * @ since 2 . 1 @ JsonIgnore / / work - around for [ databind # 815 ] public JsonNode setAll ( Map < String , ? extends JsonNode > properties ) { for ( Map . Entry < String , ? extends JsonNode > en : properties . entrySet ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_20"}
{"buggy_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( config , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom MapLikeType mlType = ( MapLikeType ) type ; ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( config , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( config , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; * * @ since 2 . 1 protected JsonSerializer < ? > buildCollectionSerializer ( SerializationConfig config , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } * Helper method that handles configuration details when constructing serializers for * { @ link java . util . Map } types . protected JsonSerializer < ? > buildMapSerializer ( SerializationConfig config , MapType type , BeanDescription beanDesc , boolean staticTyping , JsonSerializer < Object > keySerializer , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / 08 - Nov - 2014 , tatu : As per [ databind # 601 ] , better just use default Map serializer protected JsonSerializer < ? > buildArraySerializer ( SerializationConfig config , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) / / types can not be annotated ( in theory I guess we could have mix - ins but . . . ? ) / / so we need not do primary annotation lookup here . / / So all we need is ( 1 ) Custom , ( 2 ) Default array serializers JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; if ( ser ! = null ) { return ser ; } final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . } if ( ser = = null ) {", "fixed_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( prov , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; MapLikeType mlType = ( MapLikeType ) type ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } } return ser ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( prov , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } } return ser ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( prov , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; * * @ since 2 . 1 protected JsonSerializer < ? > buildCollectionSerializer ( SerializerProvider prov , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } * Helper method that handles configuration details when constructing serializers for * { @ link java . util . Map } types . protected JsonSerializer < ? > buildMapSerializer ( SerializerProvider prov , MapType type , BeanDescription beanDesc , boolean staticTyping , JsonSerializer < Object > keySerializer , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { final SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : if ( ser ! = null ) { break ; } } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / 08 - Nov - 2014 , tatu : As per [ databind # 601 ] , better just use default Map serializer protected JsonSerializer < ? > buildArraySerializer ( SerializerProvider prov , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) / / types can not be annotated ( in theory I guess we could have mix - ins but . . . ? ) / / so we need not do primary annotation lookup here . / / So all we need is ( 1 ) Custom , ( 2 ) Default array serializers SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = null ; final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } } if ( ser = = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_22"}
{"buggy_code": "protected abstract static class Base < T > extends StdScalarSerializer < T > implements ContextualSerializer { protected final JsonParser . NumberType _numberType ; protected final String _schemaType ; @ JacksonStdImpl public final static class ShortSerializer extends Base < Short > { final static ShortSerializer instance = new ShortSerializer ( ) ; public ShortSerializer ( ) { super ( Short . class , JsonParser . NumberType . INT , \" number \" ) ; } @ Override public void serialize ( Short value , JsonGenerator gen , SerializerProvider provider ) throws IOException { serialize ( value , gen , provider ) ; } }", "fixed_code": "protected abstract static class Base < T > extends StdScalarSerializer < T > implements ContextualSerializer { protected final static Integer EMPTY_INTEGER = Integer . valueOf ( 0 ) ; protected final JsonParser . NumberType _numberType ; protected final String _schemaType ; @ JacksonStdImpl public final static class ShortSerializer extends Base < Short > { private final static Short EMPTY = ( short ) 0 ; final static ShortSerializer instance = new ShortSerializer ( ) ; public ShortSerializer ( ) { super ( Short . class , JsonParser . NumberType . INT , \" number \" ) ; } @ Override public boolean isEmpty ( SerializerProvider prov , Short value ) { return EMPTY . equals ( value ) ; } @ Override public void serialize ( Short value , JsonGenerator gen , SerializerProvider provider ) throws IOException { serialize ( value , gen , provider ) ; } @ Override public boolean isEmpty ( SerializerProvider prov , Object value ) { return EMPTY_INTEGER . equals ( value ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_23"}
{"buggy_code": "if ( _dateFormat = = df ) { return this ; } TimeZone tz = ( df = = null ) ? _timeZone : df . getTimeZone ( ) ; return new BaseSettings ( _classIntrospector , _annotationIntrospector , _visibilityChecker , _propertyNamingStrategy , _typeFactory , _typeResolverBuilder , df , _handlerInstantiator , _locale , tz , _defaultBase64 ) ; } public BaseSettings withHandlerInstantiator ( HandlerInstantiator hi ) {", "fixed_code": "if ( _dateFormat = = df ) { return this ; } return new BaseSettings ( _classIntrospector , _annotationIntrospector , _visibilityChecker , _propertyNamingStrategy , _typeFactory , _typeResolverBuilder , df , _handlerInstantiator , _locale , _timeZone , _defaultBase64 ) ; } public BaseSettings withHandlerInstantiator ( HandlerInstantiator hi ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_24"}
{"buggy_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } * important for some reason ? * Disabling the check will break 2 Enum - related tests . type = _baseType . narrowBy ( type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; } return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return type . narrowBy ( dst ) ; }", "fixed_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } * important for some reason ? * Disabling the check will break 2 Enum - related tests . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; } return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return config . getTypeFactory ( ) . constructSpecializedType ( type , dst ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_25"}
{"buggy_code": "@ Override public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . getCurrentToken ( ) = = JsonToken . START_OBJECT ) { p . nextToken ( ) ; return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . getCurrentToken ( ) = = JsonToken . FIELD_NAME ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "fixed_code": "@ Override public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . isExpectedStartObjectToken ( ) | | p . hasToken ( JsonToken . FIELD_NAME ) ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . hasToken ( JsonToken . END_OBJECT ) ) { return ctxt . getNodeFactory ( ) . objectNode ( ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_28"}
{"buggy_code": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , buffer ) ) { ; } else { / / Last creator property to set ?", "fixed_code": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) { ; } else { / / Last creator property to set ?", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_28"}
{"buggy_code": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "fixed_code": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { return null ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { _properties [ index ] . getProperty ( ) . set ( bean , null ) ; return ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_29"}
{"buggy_code": "if ( t = = JsonToken . VALUE_STRING ) { value = jp . getText ( ) ; } else if ( t = = JsonToken . VALUE_NULL ) { value = _elementDeserializer . getNullValue ( ) ; } else { value = _parseString ( jp , ctxt ) ; } while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? null : deser . deserialize ( jp , ctxt ) ; if ( ix > = chunk . length ) { chunk = buffer . appendCompletedChunk ( chunk ) ; ix = 0 ;", "fixed_code": "if ( t = = JsonToken . VALUE_STRING ) { value = jp . getText ( ) ; } else if ( t = = JsonToken . VALUE_NULL ) { value = null ; / / since we have established that ' _elementDeserializer = = null ' earlier } else { value = _parseString ( jp , ctxt ) ; } while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; if ( ix > = chunk . length ) { chunk = buffer . appendCompletedChunk ( chunk ) ; ix = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_3"}
{"buggy_code": "{ if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; JsonNode result ; try { writeValue ( buf , fromValue ) ; / / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing * * @ since 2 . 7 @ Override public Version version ( ) { } break ; case VALUE_NUMBER_FLOAT : switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } break ; case VALUE_TRUE :", "fixed_code": "{ if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } JsonNode result ; try { writeValue ( buf , fromValue ) ; / / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing * * @ since 2 . 7 protected boolean _forceBigDecimal ; public TokenBuffer forceUseOfBigDecimal ( boolean b ) { _forceBigDecimal = b ; return this ; } @ Override public Version version ( ) { } break ; case VALUE_NUMBER_FLOAT : if ( _forceBigDecimal ) { writeNumber ( p . getDecimalValue ( ) ) ; } else { switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } } break ; case VALUE_TRUE :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_30"}
{"buggy_code": "if ( text = = null ) { writeNull ( ) ; } else { _append ( JsonToken . VALUE_STRING , text ) ; } } if ( text = = null ) { writeNull ( ) ; } else { _append ( JsonToken . VALUE_STRING , text ) ; } } @ Override public void writeRawValue ( String text ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override if ( offset > 0 | | len ! = text . length ( ) ) { text = text . substring ( offset , offset + len ) ; } _append ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override public void writeRawValue ( char [ ] text , int offset , int len ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , new String ( text , offset , len ) ) ; } _append ( JsonToken . VALUE_NUMBER_FLOAT , encodedValue ) ; } @ Override public void writeBoolean ( boolean state ) throws IOException { _append ( state ? JsonToken . VALUE_TRUE : JsonToken . VALUE_FALSE ) ; } @ Override public void writeNull ( ) throws IOException { _append ( JsonToken . VALUE_NULL ) ; } / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } if ( _objectCodec = = null ) { / / as with ' writeObject ( ) ' , is codec optional ? _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } * * @ since 2 . 6 . 4 protected final void _appendRaw ( int rawType , Object value ) {", "fixed_code": "if ( text = = null ) { writeNull ( ) ; } else { _appendValue ( JsonToken . VALUE_STRING , text ) ; } } if ( text = = null ) { writeNull ( ) ; } else { _appendValue ( JsonToken . VALUE_STRING , text ) ; } } @ Override public void writeRawValue ( String text ) throws IOException { _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override if ( offset > 0 | | len ! = text . length ( ) ) { text = text . substring ( offset , offset + len ) ; } _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override public void writeRawValue ( char [ ] text , int offset , int len ) throws IOException { _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , new String ( text , offset , len ) ) ; } _appendValue ( JsonToken . VALUE_NUMBER_FLOAT , encodedValue ) ; } @ Override public void writeBoolean ( boolean state ) throws IOException { _appendValue ( state ? JsonToken . VALUE_TRUE : JsonToken . VALUE_FALSE ) ; } @ Override public void writeNull ( ) throws IOException { _appendValue ( JsonToken . VALUE_NULL ) ; } / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } if ( _objectCodec = = null ) { / / as with ' writeObject ( ) ' , is codec optional ? _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } * * @ since 2 . 6 . 4 protected final void _appendValue ( JsonToken type ) { _writeContext . writeValue ( ) ; Segment next = _hasNativeId ? _last . append ( _appendAt , type , _objectId , _typeId ) : _last . append ( _appendAt , type ) ; if ( next = = null ) { + + _appendAt ; } else { _last = next ; _appendAt = 1 ; / / since we added first at 0 } } protected final void _appendValue ( JsonToken type , Object value ) { _writeContext . writeValue ( ) ; Segment next = _hasNativeId ? _last . append ( _appendAt , type , value , _objectId , _typeId ) : _last . append ( _appendAt , type , value ) ; if ( next = = null ) { + + _appendAt ; } else { _last = next ; _appendAt = 1 ; } } protected final void _appendRaw ( int rawType , Object value ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_31"}
{"buggy_code": "} else if ( _hasAnnotation ( a , JsonSerialize . class ) | | _hasAnnotation ( a , JsonView . class ) | | _hasAnnotation ( a , JsonRawValue . class ) ) { name = \" \" ; } else { return null ;", "fixed_code": "} else if ( _hasAnnotation ( a , JsonSerialize . class ) | | _hasAnnotation ( a , JsonView . class ) | | _hasAnnotation ( a , JsonRawValue . class ) | | _hasAnnotation ( a , JsonUnwrapped . class ) | | _hasAnnotation ( a , JsonBackReference . class ) | | _hasAnnotation ( a , JsonManagedReference . class ) ) { name = \" \" ; } else { return null ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_33"}
{"buggy_code": "case JsonTokenId . ID_FIELD_NAME : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( _mapDeserializer ! = null ) { return _mapDeserializer . deserialize ( p , ctxt ) ; } case JsonTokenId . ID_NULL : / / should not get this but . . . return null ; / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object / / case JsonTokenId . ID_END_ARRAY : / / invalid default :", "fixed_code": "case JsonTokenId . ID_FIELD_NAME : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object case JsonTokenId . ID_END_OBJECT : if ( _mapDeserializer ! = null ) { return _mapDeserializer . deserialize ( p , ctxt ) ; } case JsonTokenId . ID_NULL : / / should not get this but . . . return null ; case JsonTokenId . ID_END_OBJECT : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object return new LinkedHashMap < String , Object > ( 2 ) ; / / case JsonTokenId . ID_END_ARRAY : / / invalid default :", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_33"}
{"buggy_code": "} else { Class < ? > h = handledType ( ) ; if ( h = = BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_INTEGER ) ; } else { / / otherwise bit unclear what to call . . . but let ' s try :", "fixed_code": "} else { Class < ? > h = handledType ( ) ; if ( h = = BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_DECIMAL ) ; } else { / / otherwise bit unclear what to call . . . but let ' s try :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_34"}
{"buggy_code": "} } / / first , sanity checks if ( p . getCurrentToken ( ) ! = JsonToken . START_OBJECT ) { throw ctxt . wrongTokenException ( p , JsonToken . START_OBJECT , \" need JSON Object to contain As . WRAPPER_OBJECT type information for class \" + baseTypeName ( ) ) ; } / / should always get field name , but just in case . . . if ( p . nextToken ( ) ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . FIELD_NAME , \" need JSON String that contains type id ( for subtype of \" + baseTypeName ( ) + \" ) \" ) ; } final String typeId = p . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; p . nextToken ( ) ;", "fixed_code": "} } / / first , sanity checks JsonToken t = p . getCurrentToken ( ) ; if ( t = = JsonToken . START_OBJECT ) { / / should always get field name , but just in case . . . if ( p . nextToken ( ) ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . FIELD_NAME , \" need JSON String that contains type id ( for subtype of \" + baseTypeName ( ) + \" ) \" ) ; } } else if ( t ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . START_OBJECT , \" need JSON Object to contain As . WRAPPER_OBJECT type information for class \" + baseTypeName ( ) ) ; } final String typeId = p . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; p . nextToken ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_35"}
{"buggy_code": "* and not via underlying { @ link Calendar } instance like base class * does . / / and since leniency settings may have been used : @ Override / / since 2 . 7 public boolean isLenient ( ) { df . setTimeZone ( tz ) ; } } return df ; }", "fixed_code": "* and not via underlying { @ link Calendar } instance like base class * does . @ Override / / since 2 . 7 public void setLenient ( boolean enabled ) { Boolean newValue = enabled ; if ( _lenient ! = newValue ) { _lenient = newValue ; / / and since leniency settings may have been used : _clearFormats ( ) ; } } @ Override / / since 2 . 7 public boolean isLenient ( ) { df . setTimeZone ( tz ) ; } } if ( lenient ! = null ) { df . setLenient ( lenient . booleanValue ( ) ) ; } return df ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_36"}
{"buggy_code": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , _superClass , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; }", "fixed_code": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_37"}
{"buggy_code": "package com . fasterxml . jackson . databind . type ; import com . fasterxml . jackson . databind . JavaType ; public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) return new CollectionType ( rawType , null , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ; package com . fasterxml . jackson . databind . type ; import com . fasterxml . jackson . databind . JavaType ; { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , null , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; } if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } return new SimpleType ( cls , TypeBindings . emptyBindings ( ) , _bogusSuperClass ( cls ) , null , null , null , false ) ; } @ Override * * @ since 2 . 7 - - remove when not needed ( 2 . 8 ? )", "fixed_code": "package com . fasterxml . jackson . databind . type ; import java . lang . reflect . TypeVariable ; import com . fasterxml . jackson . databind . JavaType ; public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 1 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , elemT ) ; } return new CollectionType ( rawType , bindings , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ; package com . fasterxml . jackson . databind . type ; import java . lang . reflect . TypeVariable ; import com . fasterxml . jackson . databind . JavaType ; { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 2 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , keyT , valueT ) ; } / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , bindings , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; } if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } TypeBindings b = TypeBindings . emptyBindings ( ) ; return new SimpleType ( cls , b , _buildSuperClass ( cls . getSuperclass ( ) , b ) , null , null , null , false ) ; } @ Override * * @ since 2 . 7 - - remove when not needed ( 2 . 8 ? ) private static JavaType _buildSuperClass ( Class < ? > superClass , TypeBindings b ) { if ( superClass = = null ) { return null ; } if ( superClass = = Object . class ) { return TypeFactory . unknownType ( ) ; } JavaType superSuper = _buildSuperClass ( superClass . getSuperclass ( ) , b ) ; return new SimpleType ( superClass , b , superSuper , null , null , null , false ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_38"}
{"buggy_code": "List < String > matchingOpts = new ArrayList < String > ( ) ; / / for a perfect match return the single option only for ( String longOpt : longOpts . keySet ( ) ) {", "fixed_code": "List < String > matchingOpts = new ArrayList < String > ( ) ; / / for a perfect match return the single option only if ( longOpts . keySet ( ) . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( String longOpt : longOpts . keySet ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_38"}
{"buggy_code": "return _nullValue ; } / / [ databind # 1095 ] : Should not allow coercion from into null from Empty String / / either , if ` null ` not allowed }", "fixed_code": "return _nullValue ; } @ Override public T getEmptyValue ( DeserializationContext ctxt ) throws JsonMappingException { / / [ databind # 1095 ] : Should not allow coercion from into null from Empty String / / either , if ` null ` not allowed if ( _primitive & & ctxt . isEnabled ( DeserializationFeature . FAIL_ON_NULL_FOR_PRIMITIVES ) ) { throw ctxt . mappingException ( \" Can not map Empty String as null into type % s ( set DeserializationConfig . DeserializationFeature . FAIL_ON_NULL_FOR_PRIMITIVES to ' false ' to allow ) \" , handledType ( ) . toString ( ) ) ; } return _nullValue ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_40"}
{"buggy_code": "@ Deprecated public JavaType constructType ( Type type , Class < ? > contextClass ) { return constructType ( type , constructType ( contextClass ) ) ; } @ Deprecated public JavaType constructType ( Type type , JavaType contextType ) { return _fromAny ( null , type , contextType . getBindings ( ) ) ; }", "fixed_code": "@ Deprecated public JavaType constructType ( Type type , Class < ? > contextClass ) { TypeBindings bindings = ( contextClass = = null ) ? TypeBindings . emptyBindings ( ) : constructType ( contextClass ) . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; } @ Deprecated public JavaType constructType ( Type type , JavaType contextType ) { TypeBindings bindings = ( contextType = = null ) ? TypeBindings . emptyBindings ( ) : contextType . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_41"}
{"buggy_code": "return URI . create ( \" \" ) ; } / / As per [ databind # 1123 ] , Locale too return super . _deserializeFromEmptyString ( ) ; } }", "fixed_code": "return URI . create ( \" \" ) ; } / / As per [ databind # 1123 ] , Locale too if ( _kind = = STD_LOCALE ) { return Locale . ROOT ; } return super . _deserializeFromEmptyString ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_42"}
{"buggy_code": "import java . lang . annotation . Annotation ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMember ; public Object deserializeSetAndReturn ( JsonParser p , DeserializationContext ctxt , Object instance ) throws IOException { Object id = _valueDeserializer . deserialize ( p , ctxt ) ; / / note : no null checks ( unlike usually ) ; deserializer should fail if one found if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ; / / also : may need to set a property value as well", "fixed_code": "import java . lang . annotation . Annotation ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . core . JsonToken ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMember ; public Object deserializeSetAndReturn ( JsonParser p , DeserializationContext ctxt , Object instance ) throws IOException { / / note : no null checks ( unlike usually ) ; deserializer should fail if one found if ( p . hasToken ( JsonToken . VALUE_NULL ) ) { return null ; } Object id = _valueDeserializer . deserialize ( p , ctxt ) ; ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ; / / also : may need to set a property value as well", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_43"}
{"buggy_code": "/ / 15 - Jan - 2016 , tatu : Almost yes , but there are some complications with / / placeholder values ( ` Void ` , ` NoClass ` ) , so can not quite do yet . / / TODO : fix in 2 . 8 return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; / / Otherwise , stitch together the hierarchy . First , super - class / / if not found , try a super - interface / / should not get here but . . . } @ Override", "fixed_code": "/ / 15 - Jan - 2016 , tatu : Almost yes , but there are some complications with / / placeholder values ( ` Void ` , ` NoClass ` ) , so can not quite do yet . / / TODO : fix in 2 . 8 if ( ! _class . isAssignableFrom ( subclass ) ) { return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } / / Otherwise , stitch together the hierarchy . First , super - class Class < ? > next = subclass . getSuperclass ( ) ; if ( next = = _class ) { / / straight up parent class ? Great . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } if ( ( next ! = null ) & & _class . isAssignableFrom ( next ) ) { JavaType superb = _narrow ( next ) ; return new SimpleType ( subclass , _bindings , superb , null , _valueHandler , _typeHandler , _asStatic ) ; } / / if not found , try a super - interface Class < ? > [ ] nextI = subclass . getInterfaces ( ) ; for ( Class < ? > iface : nextI ) { if ( iface = = _class ) { / / directly implemented return new SimpleType ( subclass , _bindings , null , new JavaType [ ] { this } , _valueHandler , _typeHandler , _asStatic ) ; } if ( _class . isAssignableFrom ( iface ) ) { / / indirect , so recurse JavaType superb = _narrow ( iface ) ; return new SimpleType ( subclass , _bindings , null , new JavaType [ ] { superb } , _valueHandler , _typeHandler , _asStatic ) ; } } / / should not get here but . . . throw new IllegalArgumentException ( \" Internal error : Can not resolve sub - type for Class \" + subclass . getName ( ) + \" to \" + _class . getName ( ) ) ; } @ Override", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_44"}
{"buggy_code": "return withFormat ( Boolean . TRUE , null ) ; } if ( format . getShape ( ) = = JsonFormat . Shape . STRING ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( )", "fixed_code": "return withFormat ( Boolean . TRUE , null ) ; } if ( ( shape = = JsonFormat . Shape . STRING ) | | format . hasPattern ( ) | | format . hasLocale ( ) | | format . hasTimeZone ( ) ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_45"}
{"buggy_code": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( ' ; ' ) ; return sb ; }", "fixed_code": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( \" > ; \" ) ; return sb ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_46"}
{"buggy_code": "/ / static typing this way type = type . withStaticTyping ( ) ; } else { try { / / 11 - Oct - 2015 , tatu : For deser , we call ` TypeFactory . constructSpecializedType ( ) ` , / / may be needed here too in future ? type = tf . constructGeneralizedType ( type , serClass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( null , String . format ( \" Failed to widen type % s with annotation ( value % s ) , from ' % s ' : % s \" ,", "fixed_code": "/ / static typing this way type = type . withStaticTyping ( ) ; } else { Class < ? > currRaw = type . getRawClass ( ) ; try { / / 11 - Oct - 2015 , tatu : For deser , we call ` TypeFactory . constructSpecializedType ( ) ` , / / may be needed here too in future ? if ( serClass . isAssignableFrom ( currRaw ) ) { / / common case type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , type , serClass . getName ( ) ) ) ; } } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( null , String . format ( \" Failed to widen type % s with annotation ( value % s ) , from ' % s ' : % s \" ,", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_47"}
{"buggy_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; } { VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "fixed_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_IS_GETTERS ) ) { vchecker = vchecker . withIsGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; } { VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_SETTERS ) ) { vchecker = vchecker . withSetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_48"}
{"buggy_code": "/ / 04 - Jun - 2016 , tatu : As per [ databind # 1255 ] , need to consider possibility of / / id being generated for \" alwaysAsId \" , but not being written as POJO ; regardless , / / need to use existing id if there is one : id = generator . generateId ( forPojo ) ; return id ; }", "fixed_code": "/ / 04 - Jun - 2016 , tatu : As per [ databind # 1255 ] , need to consider possibility of / / id being generated for \" alwaysAsId \" , but not being written as POJO ; regardless , / / need to use existing id if there is one : if ( id = = null ) { id = generator . generateId ( forPojo ) ; } return id ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_49"}
{"buggy_code": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . mixIns . add ( _constructMethod ( m ) ) ; } } }", "fixed_code": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . am = mixIns . find ( m ) ; if ( am ! = null ) { _addMixUnders ( m , am ) ; } else { mixIns . add ( _constructMethod ( m ) ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_5"}
{"buggy_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . impl . * ; import com . fasterxml . jackson . databind . util . NameTransformer ; import com . fasterxml . jackson . databind . util . TokenBuffer ; TokenBuffer unknown = null ; JsonToken t = p . getCurrentToken ( ) ; for ( ; t = = JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; / / to point to value / / regular property ? needs buffering SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop ! = null ) { buffer . bufferProperty ( prop , _deserializeWithErrorWrapping ( p , ctxt , prop ) ) ; / / 14 - Jun - 2016 , tatu : As per [ databind # 1261 ] , looks like we need additional / / handling of forward references here . Not exactly sure why existing / / facilities did not cover , but this does appear to solve the problem continue ; } / / Things marked as ignorable should not be passed to any setter wrapInstantiationProblem ( e , ctxt ) ; bean = null ; / / never gets here } if ( unknown ! = null ) { / / polymorphic ? if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { protected final Object _deserializeWithErrorWrapping ( JsonParser p , DeserializationContext ctxt , SettableBeanProperty prop ) }", "fixed_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . impl . * ; import com . fasterxml . jackson . databind . deser . impl . ReadableObjectId . Referring ; import com . fasterxml . jackson . databind . util . NameTransformer ; import com . fasterxml . jackson . databind . util . TokenBuffer ; TokenBuffer unknown = null ; JsonToken t = p . getCurrentToken ( ) ; List < BeanReferring > referrings = null ; for ( ; t = = JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; / / to point to value / / regular property ? needs buffering SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop ! = null ) { try { buffer . bufferProperty ( prop , _deserializeWithErrorWrapping ( p , ctxt , prop ) ) ; } catch ( UnresolvedForwardReference reference ) { / / 14 - Jun - 2016 , tatu : As per [ databind # 1261 ] , looks like we need additional / / handling of forward references here . Not exactly sure why existing / / facilities did not cover , but this does appear to solve the problem BeanReferring referring = handleUnresolvedReference ( p , prop , buffer , reference ) ; if ( referrings = = null ) { referrings = new ArrayList < BeanReferring > ( ) ; } referrings . add ( referring ) ; } continue ; } / / Things marked as ignorable should not be passed to any setter wrapInstantiationProblem ( e , ctxt ) ; bean = null ; / / never gets here } if ( referrings ! = null ) { for ( BeanReferring referring : referrings ) { referring . setBean ( bean ) ; } } if ( unknown ! = null ) { / / polymorphic ? if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { private BeanReferring handleUnresolvedReference ( JsonParser p , SettableBeanProperty prop , PropertyValueBuffer buffer , UnresolvedForwardReference reference ) throws JsonMappingException { BeanReferring referring = new BeanReferring ( reference , prop . getType ( ) . getRawClass ( ) , buffer , prop ) ; reference . getRoid ( ) . appendReferring ( referring ) ; return referring ; } protected final Object _deserializeWithErrorWrapping ( JsonParser p , DeserializationContext ctxt , SettableBeanProperty prop ) static class BeanReferring extends Referring { private final SettableBeanProperty _prop ; private Object _bean ; public void setBean ( Object bean ) { _bean = bean ; } BeanReferring ( UnresolvedForwardReference ref , Class < ? > valueType , PropertyValueBuffer buffer , SettableBeanProperty prop ) { super ( ref , valueType ) ; _prop = prop ; } @ Override public void handleResolvedForwardReference ( Object id , Object value ) throws IOException { _prop . set ( _bean , value ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_50"}
{"buggy_code": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "fixed_code": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . if ( ! type . hasGenericTypes ( ) ) { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_51"}
{"buggy_code": "if ( extTypes ! = null ) { / / 21 - Jun - 2016 , tatu : related to [ databind # 999 ] , may need to link type ids too , / / so need to pass collected properties _externalTypeIdHandler = extTypes . build ( ) ; / / we consider this non - standard , to offline handling _nonStandardCreation = true ; } * * @ since 2 . 8 / / 21 - Jun - 2016 , tatu : as per [ databind # 999 ] , may need to link type id property also @ Deprecated / / since 2 . 8 ; may be removed as early as 2 . 9 public ExternalTypeHandler build ( ) {", "fixed_code": "if ( extTypes ! = null ) { / / 21 - Jun - 2016 , tatu : related to [ databind # 999 ] , may need to link type ids too , / / so need to pass collected properties _externalTypeIdHandler = extTypes . build ( _beanProperties ) ; / / we consider this non - standard , to offline handling _nonStandardCreation = true ; } * * @ since 2 . 8 public ExternalTypeHandler build ( BeanPropertyMap otherProps ) { / / 21 - Jun - 2016 , tatu : as per [ databind # 999 ] , may need to link type id property also final int len = _properties . size ( ) ; ExtTypedProperty [ ] extProps = new ExtTypedProperty [ len ] ; for ( int i = 0 ; i < len ; + + i ) { ExtTypedProperty extProp = _properties . get ( i ) ; String typePropId = extProp . getTypePropertyName ( ) ; SettableBeanProperty typeProp = otherProps . find ( typePropId ) ; if ( typeProp ! = null ) { extProp . linkTypeProperty ( typeProp ) ; } extProps [ i ] = extProp ; } return new ExternalTypeHandler ( extProps , _nameToPropertyIndex , null , null ) ; } @ Deprecated / / since 2 . 8 ; may be removed as early as 2 . 9 public ExternalTypeHandler build ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_53"}
{"buggy_code": "* * @ since 2 . 8 / / safe to pass _types array without copy since it is not exposed via / / any access , nor modified by this class } * actual generic types ) , we will use small cache to avoid repetitive * resolution of core types protected final LRUMap < Class < ? > , JavaType > _typeCache = new LRUMap < Class < ? > , JavaType > ( 16 , 100 ) ; } / / But otherwise gets bit tricky , as we need to partially resolve the type hierarchy / / ( hopefully passing null Class for root is ok ) / / Otherwise , two choices : match N first , or empty . Do latter , for now", "fixed_code": "* * @ since 2 . 8 public Object asKey ( Class < ? > rawBase ) { / / safe to pass _types array without copy since it is not exposed via / / any access , nor modified by this class return new AsKey ( rawBase , _types , _hashCode ) ; } final static class AsKey { private final Class < ? > _raw ; private final JavaType [ ] _params ; private final int _hash ;  public AsKey ( Class < ? > raw , JavaType [ ] params , int hash ) { _raw = raw ; _params = params ; _hash = hash ; } @ Override public int hashCode ( ) { return _hash ; }  @ Override public boolean equals ( Object o ) { if ( o = = this ) return true ; if ( o = = null ) return false ; if ( o . getClass ( ) ! = getClass ( ) ) return false ; AsKey other = ( AsKey ) o ;  if ( ( _hash = = other . _hash ) & & ( _raw = = other . _raw ) ) { final JavaType [ ] otherParams = other . _params ; final int len = _params . length ;  if ( len = = otherParams . length ) { for ( int i = 0 ; i < len ; + + i ) { if ( ! _params [ i ] . equals ( otherParams [ i ] ) ) { return false ; } } return true ; } } return false ; } @ Override public String toString ( ) { return _raw . getName ( ) + \" < > \" ; } } } * actual generic types ) , we will use small cache to avoid repetitive * resolution of core types protected final LRUMap < Object , JavaType > _typeCache = new LRUMap < Object , JavaType > ( 16 , 100 ) ; } private TypeBindings _bindingsForSubtype ( JavaType baseType , int typeParamCount , Class < ? > subclass ) { / / But otherwise gets bit tricky , as we need to partially resolve the type hierarchy / / ( hopefully passing null Class for root is ok ) int baseCount = baseType . containedTypeCount ( ) ; if ( baseCount = = typeParamCount ) { if ( typeParamCount = = 1 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } if ( typeParamCount = = 2 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } List < JavaType > types = new ArrayList < JavaType > ( baseCount ) ; for ( int i = 0 ; i < baseCount ; + + i ) { types . add ( baseType . containedType ( i ) ) ; } return TypeBindings . create ( subclass , types ) ; } / / Otherwise , two choices : match N first , or empty . Do latter , for now return TypeBindings . emptyBindings ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_53"}
{"buggy_code": "/ / always suppress nulls suppressNulls = true ; / / and for referential types , also \" empty \" , which in their case means \" absent \" if ( declaredType . isReferenceType ( ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; } break ; case ALWAYS : / / default default : / / we may still want to suppress empty collections , as per [ JACKSON - 254 ] : if ( declaredType . isContainerType ( ) & & ! _config . isEnabled ( SerializationFeature . WRITE_EMPTY_JSON_ARRAYS ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; }", "fixed_code": "/ / always suppress nulls suppressNulls = true ; / / and for referential types , also \" empty \" , which in their case means \" absent \" if ( actualType . isReferenceType ( ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; } break ; case ALWAYS : / / default default : / / we may still want to suppress empty collections , as per [ JACKSON - 254 ] : if ( actualType . isContainerType ( ) & & ! _config . isEnabled ( SerializationFeature . WRITE_EMPTY_JSON_ARRAYS ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_54"}
{"buggy_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . ser . impl . PropertySerializerMap ; @ SuppressWarnings ( \" serial \" ) public class StdKeySerializers return new Dynamic ( ) ; } if ( rawKeyType . isEnum ( ) ) { return new Default ( Default . TYPE_ENUM , rawKeyType ) ; } } return DEFAULT_KEY_SERIALIZER ; * * @ since 2 . 8 }", "fixed_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . ser . impl . PropertySerializerMap ; import com . fasterxml . jackson . databind . util . EnumValues ; @ SuppressWarnings ( \" serial \" ) public class StdKeySerializers return new Dynamic ( ) ; } if ( rawKeyType . isEnum ( ) ) { return EnumKeySerializer . construct ( rawKeyType , EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) rawKeyType ) ) ; } } return DEFAULT_KEY_SERIALIZER ; * * @ since 2 . 8 public static class EnumKeySerializer extends StdSerializer < Object > { protected final EnumValues _values ; protected EnumKeySerializer ( Class < ? > enumType , EnumValues values ) { super ( enumType , false ) ; _values = values ; } public static EnumKeySerializer construct ( Class < ? > enumType , EnumValues enumValues ) { return new EnumKeySerializer ( enumType , enumValues ) ; } @ Override public void serialize ( Object value , JsonGenerator g , SerializerProvider serializers ) throws IOException { if ( serializers . isEnabled ( SerializationFeature . WRITE_ENUMS_USING_TO_STRING ) ) { g . writeFieldName ( value . toString ( ) ) ; return ; } Enum < ? > en = ( Enum < ? > ) value ; g . writeFieldName ( _values . serializedValueFor ( en ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_55"}
{"buggy_code": "return Pattern . compile ( value ) ; case STD_LOCALE : { int ix = value . indexOf ( ' _ ' ) ; if ( ix < 0 ) { / / single argument return new Locale ( value ) ; } String first = value . substring ( 0 , ix ) ; value = value . substring ( ix + 1 ) ; ix = value . indexOf ( ' _ ' ) ; if ( ix < 0 ) { / / two pieces return new Locale ( first , value ) ; } } } }", "fixed_code": "return Pattern . compile ( value ) ; case STD_LOCALE : { int ix = _firstHyphenOrUnderscore ( value ) ; if ( ix < 0 ) { / / single argument return new Locale ( value ) ; } String first = value . substring ( 0 , ix ) ; value = value . substring ( ix + 1 ) ; ix = _firstHyphenOrUnderscore ( value ) ; if ( ix < 0 ) { / / two pieces return new Locale ( first , value ) ; } } protected int _firstHyphenOrUnderscore ( String str ) { for ( int i = 0 , end = str . length ( ) ; i < end ; + + i ) { char c = str . charAt ( i ) ; if ( c = = ' _ ' | | c = = ' - ' ) { return i ; } } return - 1 ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_56"}
{"buggy_code": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src ) , true ) ) ; }", "fixed_code": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src , offset , length ) , true ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_57"}
{"buggy_code": "/ / [ databind # 877 ] : explicitly prevent forced access to ` cause ` of ` Throwable ` ; / / never needed and attempts may cause problems on some platforms . / / ! ! ! NOTE : should be handled better for 2 . 8 and later mutator . fixAccess ( ctxt . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } / / note : this works since we know there ' s exactly one argument for methods BeanProperty . Std property = new BeanProperty . Std ( propDef . getFullName ( ) ,", "fixed_code": "/ / [ databind # 877 ] : explicitly prevent forced access to ` cause ` of ` Throwable ` ; / / never needed and attempts may cause problems on some platforms . / / ! ! ! NOTE : should be handled better for 2 . 8 and later if ( ( mutator instanceof AnnotatedField ) & & \" cause \" . equals ( mutator . getName ( ) ) ) { ; } else { mutator . fixAccess ( ctxt . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } } / / note : this works since we know there ' s exactly one argument for methods BeanProperty . Std property = new BeanProperty . Std ( propDef . getFullName ( ) ,", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_58"}
{"buggy_code": "* * @ since 2 . 8 . 4", "fixed_code": "* * @ since 2 . 8 . 4 public JavaType withHandlersFrom ( JavaType src ) { JavaType type = this ; Object h = src . getTypeHandler ( ) ; if ( h ! = _typeHandler ) { type = type . withTypeHandler ( h ) ; } h = src . getValueHandler ( ) ; if ( h ! = _valueHandler ) { type = type . withValueHandler ( h ) ; } return type ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_59"}
{"buggy_code": "/ / Milliseconds partial or missing ; and even seconds are optional len = dateStr . length ( ) ; / / remove ' T ' , ' + ' / ' - ' and 4 - digit timezone - offset c = dateStr . charAt ( len - 9 ) ; if ( Character . isDigit ( c ) ) { StringBuilder sb = new StringBuilder ( dateStr ) ; sb . insert ( len - 5 , \" . 000 \" ) ; dateStr = sb . toString ( ) ; } df = _formatISO8601 ; StringBuilder sb = new StringBuilder ( dateStr ) ; / / And possible also millisecond part if missing int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; if ( timeLen < = 8 ) { sb . append ( \" . 000 \" ) ; } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ;", "fixed_code": "/ / Milliseconds partial or missing ; and even seconds are optional len = dateStr . length ( ) ; / / remove ' T ' , ' + ' / ' - ' and 4 - digit timezone - offset int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 6 ; if ( timeLen < 12 ) { / / 8 for hh : mm : ss , 4 for . sss int offset = len - 5 ; / / insertion offset , before tz - offset StringBuilder sb = new StringBuilder ( dateStr ) ; switch ( timeLen ) { case 11 : sb . insert ( offset , ' 0 ' ) ; break ; case 10 : sb . insert ( offset , \" 00 \" ) ; break ; case 9 : / / is this legal ? ( just second fraction marker ) sb . insert ( offset , \" 000 \" ) ; break ; case 8 : sb . insert ( offset , \" . 000 \" ) ; break ; case 7 : / / not legal to have single - digit second break ; case 6 : / / probably not legal , but let ' s allow sb . insert ( offset , \" 00 . 000 \" ) ; case 5 : / / is legal to omit seconds sb . insert ( offset , \" : 00 . 000 \" ) ; } dateStr = sb . toString ( ) ; } df = _formatISO8601 ; StringBuilder sb = new StringBuilder ( dateStr ) ; / / And possible also millisecond part if missing int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; if ( timeLen < 12 ) { / / missing , or partial switch ( timeLen ) { case 11 : sb . append ( ' 0 ' ) ; case 10 : sb . append ( ' 0 ' ) ; case 9 : sb . append ( ' 0 ' ) ; break ; default : sb . append ( \" . 000 \" ) ; } } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_6"}
{"buggy_code": "import java . util . LinkedHashSet ; import java . util . Set ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . annotation . JacksonStdImpl ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonFormatVisitorWrapper ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonStringFormatVisitor ; import com . fasterxml . jackson . databind . jsonschema . SchemaAware ; import com . fasterxml . jackson . databind . jsontype . TypeSerializer ; import com . fasterxml . jackson . databind . ser . BeanSerializer ; import com . fasterxml . jackson . databind . ser . ContextualSerializer ; / / 28 - Sep - 2016 , tatu : As per [ databind # 1385 ] , we do need to do some juggling / / to use different Object for type id ( logical type ) and actual serialization / / ( delegat type ) . ser . serializeWithType ( value , gen , provider , typeSer0 ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { * override Object to use for type id ( logical type ) even when asking serialization * of something else ( delegate type ) }", "fixed_code": "import java . util . LinkedHashSet ; import java . util . Set ; import com . fasterxml . jackson . annotation . JsonTypeInfo . As ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . annotation . JacksonStdImpl ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonFormatVisitorWrapper ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonStringFormatVisitor ; import com . fasterxml . jackson . databind . jsonschema . SchemaAware ; import com . fasterxml . jackson . databind . jsontype . TypeIdResolver ; import com . fasterxml . jackson . databind . jsontype . TypeSerializer ; import com . fasterxml . jackson . databind . ser . BeanSerializer ; import com . fasterxml . jackson . databind . ser . ContextualSerializer ; / / 28 - Sep - 2016 , tatu : As per [ databind # 1385 ] , we do need to do some juggling / / to use different Object for type id ( logical type ) and actual serialization / / ( delegat type ) . TypeSerializerRerouter rr = new TypeSerializerRerouter ( typeSer0 , bean ) ; ser . serializeWithType ( value , gen , provider , rr ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { * override Object to use for type id ( logical type ) even when asking serialization * of something else ( delegate type ) static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer ; protected final Object _forObject ; public TypeSerializerRerouter ( TypeSerializer ts , Object ob ) { _typeSerializer = ts ; _forObject = ob ; } @ Override public TypeSerializer forProperty ( BeanProperty prop ) { / / should never get called throw new UnsupportedOperationException ( ) ; } @ Override public As getTypeInclusion ( ) { return _typeSerializer . getTypeInclusion ( ) ; } @ Override public String getPropertyName ( ) { return _typeSerializer . getPropertyName ( ) ; } @ Override public TypeIdResolver getTypeIdResolver ( ) { return _typeSerializer . getTypeIdResolver ( ) ; } @ Override public void writeTypePrefixForScalar ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForScalar ( _forObject , gen ) ; } @ Override public void writeTypePrefixForObject ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForObject ( _forObject , gen ) ; } @ Override public void writeTypePrefixForArray ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForArray ( _forObject , gen ) ; } @ Override public void writeTypeSuffixForScalar ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForScalar ( _forObject , gen ) ; } @ Override public void writeTypeSuffixForObject ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForObject ( _forObject , gen ) ; } @ Override public void writeTypeSuffixForArray ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForArray ( _forObject , gen ) ; } public void writeTypePrefixForScalar ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForScalar ( _forObject , gen , type ) ; } public void writeTypePrefixForObject ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForObject ( _forObject , gen , type ) ; } public void writeTypePrefixForArray ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForArray ( _forObject , gen , type ) ; } @ Override public void writeCustomTypePrefixForScalar ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForScalar ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypePrefixForObject ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForObject ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypePrefixForArray ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForArray ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypeSuffixForScalar ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForScalar ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypeSuffixForObject ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForObject ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypeSuffixForArray ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForArray ( _forObject , gen , typeId ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_60"}
{"buggy_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS : if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ;", "fixed_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless if ( t . isPrimitive ( ) ) { return false ; } switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS : if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_61"}
{"buggy_code": "} delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } } / / [ databind # 1043 ] : allow per - property allow - wrapping of single overrides :", "fixed_code": "\" ) returned true for ' canCreateUsingDelegate ( ) ' , but null for ' getDelegateType ( ) ' \" ) ; } delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } else if ( _valueInstantiator . canCreateUsingArrayDelegate ( ) ) { JavaType delegateType = _valueInstantiator . getArrayDelegateType ( ctxt . getConfig ( ) ) ; if ( delegateType = = null ) { throw new IllegalArgumentException ( \" Invalid array - delegate - creator definition for \" + _collectionType + \" : value instantiator ( \" + _valueInstantiator . getClass ( ) . getName ( ) + \" ) returned true for ' canCreateUsingArrayDelegate ( ) ' , but null for ' getArrayDelegateType ( ) ' \" ) ; } delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } } / / [ databind # 1043 ] : allow per - property allow - wrapping of single overrides :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_62"}
{"buggy_code": "import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . util . ClassUtil ; sb . append ( cls . getSimpleName ( ) ) ; } sb . append ( ' [ ' ) ; if ( _fieldName ! = null ) {", "fixed_code": "import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; } sb . append ( ' [ ' ) ; if ( _fieldName ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_63"}
{"buggy_code": "/ / whereas for global defaults OR per - property overrides , we have more / / static definition . Sigh . / / First : case of class / type specifying it ; try to find POJO property defaults / / 16 - Oct - 2016 , tatu : Note : if we can not for some reason create \" default instance \" , / / revert logic to the case of general / per - property handling , so both / / type - default AND null are to be excluded . / / ( as per [ databind # 1417 ] if ( _useRealPropertyDefaults ) { / / 07 - Sep - 2016 , tatu : may also need to front - load access forcing now if ( prov . isEnabled ( MapperFeature . CAN_OVERRIDE_ACCESS_MODIFIERS ) ) { am . fixAccess ( _config . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } valueToSuppress = getPropertyDefaultValue ( propDef . getName ( ) , am , actualType ) ; } else { valueToSuppress = getDefaultValue ( actualType ) ; suppressNulls = true ;", "fixed_code": "/ / whereas for global defaults OR per - property overrides , we have more / / static definition . Sigh . / / First : case of class / type specifying it ; try to find POJO property defaults Object defaultBean ; / / 16 - Oct - 2016 , tatu : Note : if we can not for some reason create \" default instance \" , / / revert logic to the case of general / per - property handling , so both / / type - default AND null are to be excluded . / / ( as per [ databind # 1417 ] if ( _useRealPropertyDefaults & & ( defaultBean = getDefaultBean ( ) ) ! = null ) { / / 07 - Sep - 2016 , tatu : may also need to front - load access forcing now if ( prov . isEnabled ( MapperFeature . CAN_OVERRIDE_ACCESS_MODIFIERS ) ) { am . fixAccess ( _config . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } try { valueToSuppress = am . getValue ( defaultBean ) ; } catch ( Exception e ) { _throwWrapped ( e , propDef . getName ( ) , defaultBean ) ; } } else { valueToSuppress = getDefaultValue ( actualType ) ; suppressNulls = true ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_65"}
{"buggy_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : % s \" , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; / / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { return true ; } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "fixed_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; / / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) & & am . getParameterCount ( ) = = 1 ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { if ( am . getParameterCount ( ) = = 1 ) { return true ; } } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_65"}
{"buggy_code": "import java . net . URL ; import java . util . * ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . core . io . NumberInput ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMethod ; import com . fasterxml . jackson . databind . util . ClassUtil ; import com . fasterxml . jackson . databind . util . EnumResolver ;", "fixed_code": "import java . net . URL ; import java . util . * ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . core . io . NumberInput ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMethod ; import com . fasterxml . jackson . databind . util . ClassUtil ; import com . fasterxml . jackson . databind . util . EnumResolver ; import com . fasterxml . jackson . databind . util . TokenBuffer ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_66"}
{"buggy_code": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { return _createEnumKeyDeserializer ( ctxt , type ) ; } deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } / / and then post - processing if ( deser ! = null ) {", "fixed_code": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { deser = _createEnumKeyDeserializer ( ctxt , type ) ; } else { deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } } / / and then post - processing if ( deser ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_67"}
{"buggy_code": "protected Object deserializeFromObjectUsingNonDefault ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( _delegateDeserializer ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; } if ( _propertyBasedCreator ! = null ) { return _deserializeUsingPropertyBased ( p , ctxt ) ; if ( _objectIdReader ! = null ) { return deserializeFromObjectId ( p , ctxt ) ; } switch ( p . getNumberType ( ) ) { case INT : if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } } return _valueInstantiator . createFromInt ( ctxt , p . getIntValue ( ) ) ; case LONG : if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromLong ( ctxt , p . getLongValue ( ) ) ; } / / actually , could also be BigInteger , so : if ( _delegateDeserializer ! = null ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromString ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } NumberType t = p . getNumberType ( ) ; / / no separate methods for taking float . . . if ( ( t = = NumberType . DOUBLE ) | | ( t = = NumberType . FLOAT ) ) { if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromDouble ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromDouble ( ctxt , p . getDoubleValue ( ) ) ; } / / actually , could also be BigDecimal , so : if ( _delegateDeserializer ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; } return ctxt . handleMissingInstantiator ( handledType ( ) , p , \" no suitable creator method found to deserialize from Number value ( % s ) \" , public Object deserializeFromBoolean ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromBoolean ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } public Object deserializeFromArray ( JsonParser p , DeserializationContext ctxt ) throws IOException { / / note : can not call ` _delegateDeserializer ( ) ` since order reversed here : if ( _arrayDelegateDeserializer ! = null ) { try { Object bean = _valueInstantiator . createUsingArrayDelegate ( ctxt , _arrayDelegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return bean ; } catch ( Exception e ) { return wrapInstantiationProblem ( e , ctxt ) ; } } / / fallback to non - array delegate if ( _delegateDeserializer ! = null ) { try { Object bean = _valueInstantiator . createUsingArrayDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return bean ; } catch ( Exception e ) { wrapInstantiationProblem ( e , ctxt ) ; return null ; } } if ( ctxt . isEnabled ( DeserializationFeature . UNWRAP_SINGLE_VALUE_ARRAYS ) ) { JsonToken t = p . nextToken ( ) ;", "fixed_code": "protected Object deserializeFromObjectUsingNonDefault ( JsonParser p , DeserializationContext ctxt ) throws IOException { final JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; } if ( _propertyBasedCreator ! = null ) { return _deserializeUsingPropertyBased ( p , ctxt ) ; if ( _objectIdReader ! = null ) { return deserializeFromObjectId ( p , ctxt ) ; } final JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; switch ( p . getNumberType ( ) ) { case INT : if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } } return _valueInstantiator . createFromInt ( ctxt , p . getIntValue ( ) ) ; case LONG : if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromLong ( ctxt , p . getLongValue ( ) ) ; } / / actually , could also be BigInteger , so : if ( delegateDeser ! = null ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromString ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } NumberType t = p . getNumberType ( ) ; / / no separate methods for taking float . . . if ( ( t = = NumberType . DOUBLE ) | | ( t = = NumberType . FLOAT ) ) { JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromDouble ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromDouble ( ctxt , p . getDoubleValue ( ) ) ; } / / actually , could also be BigDecimal , so : JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; } return ctxt . handleMissingInstantiator ( handledType ( ) , p , \" no suitable creator method found to deserialize from Number value ( % s ) \" , public Object deserializeFromBoolean ( JsonParser p , DeserializationContext ctxt ) throws IOException { JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromBoolean ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } public Object deserializeFromArray ( JsonParser p , DeserializationContext ctxt ) throws IOException { / / note : can not call ` _delegateDeserializer ( ) ` since order reversed here : JsonDeserializer < Object > delegateDeser = _arrayDelegateDeserializer ; / / fallback to non - array delegate if ( ( delegateDeser ! = null ) | | ( ( delegateDeser = _delegateDeserializer ) ! = null ) ) { Object bean = _valueInstantiator . createUsingArrayDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return bean ; } if ( ctxt . isEnabled ( DeserializationFeature . UNWRAP_SINGLE_VALUE_ARRAYS ) ) { JsonToken t = p . nextToken ( ) ; private final JsonDeserializer < Object > _delegateDeserializer ( ) { JsonDeserializer < Object > deser = _delegateDeserializer ; if ( deser = = null ) { deser = _arrayDelegateDeserializer ; } return deser ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_68"}
{"buggy_code": "SettableBeanProperty [ ] injectables ) { if ( creator . getParameterType ( 0 ) . isCollectionLikeType ( ) ) { verifyNonDup ( creator , C_ARRAY_DELEGATE , explicit ) ; _arrayDelegateArgs = injectables ; } else { verifyNonDup ( creator , C_DELEGATE , explicit ) ; _delegateArgs = injectables ; } } public void addPropertyCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] properties ) { verifyNonDup ( creator , C_PROPS , explicit ) ; / / Better ensure we have no duplicate names either . . . if ( properties . length > 1 ) { HashMap < String , Integer > names = new HashMap < String , Integer > ( ) ; } } _propertyBasedArgs = properties ; } public void addIncompeteParameter ( AnnotatedParameter parameter ) { protected void verifyNonDup ( AnnotatedWithParams newOne , int typeIndex , boolean explicit ) { final int mask = ( 1 < < typeIndex ) ; _hasNonDefaultCreator = true ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated if ( ! explicit ) { return ; } / / both explicit : verify verify = true ; / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } _explicitCreators | = mask ; } _creators [ typeIndex ] = _fixAccess ( newOne ) ; }", "fixed_code": "SettableBeanProperty [ ] injectables ) { if ( creator . getParameterType ( 0 ) . isCollectionLikeType ( ) ) { if ( verifyNonDup ( creator , C_ARRAY_DELEGATE , explicit ) ) { _arrayDelegateArgs = injectables ; } } else { if ( verifyNonDup ( creator , C_DELEGATE , explicit ) ) { _delegateArgs = injectables ; } } } public void addPropertyCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] properties ) { if ( verifyNonDup ( creator , C_PROPS , explicit ) ) { / / Better ensure we have no duplicate names either . . . if ( properties . length > 1 ) { HashMap < String , Integer > names = new HashMap < String , Integer > ( ) ; } } _propertyBasedArgs = properties ; } } public void addIncompeteParameter ( AnnotatedParameter parameter ) { protected boolean verifyNonDup ( AnnotatedWithParams newOne , int typeIndex , boolean explicit ) { final int mask = ( 1 < < typeIndex ) ; _hasNonDefaultCreator = true ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated if ( ! explicit ) { return false ; } / / both explicit : verify verify = true ; / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return false ; } / / new type more specific , use it } _explicitCreators | = mask ; } _creators [ typeIndex ] = _fixAccess ( newOne ) ; return true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_69"}
{"buggy_code": "public TokenBuffer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException { copyCurrentStructure ( jp ) ; return this ; }", "fixed_code": "public TokenBuffer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException { if ( jp . getCurrentTokenId ( ) ! = JsonToken . FIELD_NAME . id ( ) ) { copyCurrentStructure ( jp ) ; return this ; } JsonToken t ; writeStartObject ( ) ; do { copyCurrentStructure ( jp ) ; } while ( ( t = jp . nextToken ( ) ) = = JsonToken . FIELD_NAME ) ; if ( t ! = JsonToken . END_OBJECT ) { throw ctxt . mappingException ( \" Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer , got \" + t ) ; } writeEndObject ( ) ; return this ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_7"}
{"buggy_code": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( prop . getName ( ) ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "fixed_code": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( _hashArea [ i - 1 ] ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_70"}
{"buggy_code": "int kind ; / / first common types : if ( raw = = String . class | | raw = = Object . class ) { return StringKD . forType ( raw ) ; } else if ( raw = = UUID . class ) { kind = TYPE_UUID ;", "fixed_code": "int kind ; / / first common types : if ( raw = = String . class | | raw = = Object . class | | raw = = CharSequence . class ) { return StringKD . forType ( raw ) ; } else if ( raw = = UUID . class ) { kind = TYPE_UUID ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_71"}
{"buggy_code": "@ Override public int getPropertyIndex ( ) { return _delegate . getPropertyIndex ( ) ; } / / / / / / BeanProperty impl } return new InnerClassProperty ( this , new AnnotatedConstructor ( null , _creator , null , null ) ) ; } \\ No newline at end of file }", "fixed_code": "@ Override public int getPropertyIndex ( ) { return _delegate . getPropertyIndex ( ) ; } @ Override public int getCreatorIndex ( ) { return _delegate . getCreatorIndex ( ) ; } / / / / / / BeanProperty impl } return new InnerClassProperty ( this , new AnnotatedConstructor ( null , _creator , null , null ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_73"}
{"buggy_code": "import java . util . * ; import com . fasterxml . jackson . annotation . JsonAnySetter ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . cfg . HandlerInstantiator ; import com . fasterxml . jackson . databind . cfg . MapperConfig ; while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of prop . removeNonVisible ( inferMutators ) ; } } * @ param inferMutators Whether mutators can be \" pulled in \" by visible * accessors or not . public void removeNonVisible ( boolean inferMutators ) {", "fixed_code": "import java . util . * ; import com . fasterxml . jackson . annotation . JsonAnySetter ; import com . fasterxml . jackson . annotation . JsonProperty . Access ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . cfg . HandlerInstantiator ; import com . fasterxml . jackson . databind . cfg . MapperConfig ; while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of Access acc = prop . removeNonVisible ( inferMutators ) ; if ( ! _forSerialization & & ( acc = = Access . READ_ONLY ) ) { _collectIgnorals ( prop . getName ( ) ) ; } } } * @ param inferMutators Whether mutators can be \" pulled in \" by visible * accessors or not . public JsonProperty . Access removeNonVisible ( boolean inferMutators ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_73"}
{"buggy_code": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "fixed_code": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } else if ( p . getCurrentToken ( ) = = JsonToken . VALUE_STRING ) { if ( ctxt . isEnabled ( DeserializationFeature . ACCEPT_EMPTY_STRING_AS_NULL_OBJECT ) ) { String str = p . getText ( ) . trim ( ) ; if ( str . isEmpty ( ) ) { return null ; } } } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_74"}
{"buggy_code": "* handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * index ( number ) or not . protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return null ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return null ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) {", "fixed_code": "* handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true , null ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false , _serializeAsIndex ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * index ( number ) or not . protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass , Boolean defaultValue ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return defaultValue ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return defaultValue ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_75"}
{"buggy_code": "/ / creator property ? SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp ! = null ) { if ( buffer . assignParameter ( creatorProp , creatorProp . deserialize ( p , ctxt ) ) ) { t = p . nextToken ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrapAndThrow ( e , _beanType . getRawClass ( ) , propName , ctxt ) ; continue ; } while ( t = = JsonToken . FIELD_NAME ) { p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { ctxt . reportMappingException ( \" Can not create polymorphic instances with unwrapped values \" ) ; return null ; } return _unwrappedPropertyHandler . processUnwrapped ( p , ctxt , bean , tokens ) ; } continue ; } / / Object Id property ?", "fixed_code": "/ / creator property ? SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp ! = null ) { buffer . assignParameter ( creatorProp , creatorProp . deserialize ( p , ctxt ) ) ; continue ; } / / Object Id property ?", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_76"}
{"buggy_code": "return null ; } / / For checks like [ databind # 1599 ] / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; } / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here .  }", "fixed_code": "return null ; } / / For checks like [ databind # 1599 ] checkIllegalTypes ( ctxt , type , beanDesc ) ; / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; } protected void checkIllegalTypes ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here . Class < ? > raw = type . getRawClass ( ) ; String name = raw . getSimpleName ( ) ;  if ( \" TemplatesImpl \" . equals ( name ) ) { / / [ databind # 1599 ] if ( raw . getName ( ) . startsWith ( \" com . sun . org . apache . xalan \" ) ) { throw JsonMappingException . from ( ctxt , String . format ( \" Illegal type ( % s ) to deserialize : prevented for security reasons \" , name ) ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_77"}
{"buggy_code": "* * @ since 2 . 8 . 9 / / Courtesy of [ https : / / github . com / kantega / notsoserial ] : / / ( and wrt [ databind # 1599 ] / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here . }", "fixed_code": "* * @ since 2 . 8 . 9 protected final static Set < String > DEFAULT_NO_DESER_CLASS_NAMES ; static { Set < String > s = new HashSet < > ( ) ; / / Courtesy of [ https : / / github . com / kantega / notsoserial ] : / / ( and wrt [ databind # 1599 ] s . add ( \" org . apache . commons . collections . functors . InvokerTransformer \" ) ; s . add ( \" org . apache . commons . collections . functors . InstantiateTransformer \" ) ; s . add ( \" org . apache . commons . collections4 . functors . InvokerTransformer \" ) ; s . add ( \" org . apache . commons . collections4 . functors . InstantiateTransformer \" ) ; s . add ( \" org . codehaus . groovy . runtime . ConvertedClosure \" ) ; s . add ( \" org . codehaus . groovy . runtime . MethodClosure \" ) ; s . add ( \" org . springframework . beans . factory . ObjectFactory \" ) ; s . add ( \" com . sun . org . apache . xalan . internal . xsltc . trax . TemplatesImpl \" ) ; DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; } protected Set < String > _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES ; protected void checkIllegalTypes ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here . String full = type . getRawClass ( ) . getName ( ) ; if ( _cfgIllegalClassNames . contains ( full ) ) { ctxt . reportBadTypeDefinition ( beanDesc , \" Illegal type ( % s ) to deserialize : prevented for security reasons \" , full ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_78"}
{"buggy_code": "import org . jsoup . SerializationException ; import org . jsoup . helper . Validate ; import org . jsoup . internal . StringUtil ; import java . io . IOException ; import java . util . AbstractMap ; * Adds a new attribute . Will produce duplicates if the key already exists . * @ see Attributes # put ( String , String ) private void add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ; vals [ size ] = value ; size + + ; } private static class Dataset extends AbstractMap < String , String > { private final Attributes attributes ; Element insert ( final Token . StartTag startTag ) { / / cleanup duplicate attributes : / / handle empty unknown tags / / when the spec expects an empty tag , will directly hit insertEmpty , so won ' t generate this fake end tag .", "fixed_code": "import org . jsoup . SerializationException ; import org . jsoup . helper . Validate ; import org . jsoup . internal . StringUtil ; import org . jsoup . parser . ParseSettings ; import java . io . IOException ; import java . util . AbstractMap ; * Adds a new attribute . Will produce duplicates if the key already exists . * @ see Attributes # put ( String , String ) public Attributes add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ; vals [ size ] = value ; size + + ; return this ; } public boolean isEmpty ( ) { return size = = 0 ; } public int deduplicate ( ParseSettings settings ) { if ( isEmpty ( ) ) return 0 ; boolean preserve = settings . preserveAttributeCase ( ) ; int dupes = 0 ; OUTER : for ( int i = 0 ; i < keys . length ; i + + ) { for ( int j = i + 1 ; j < keys . length ; j + + ) { if ( keys [ j ] = = null ) continue OUTER ; / / keys . length doesn ' t shrink when removing , so re - test if ( ( preserve & & keys [ i ] . equals ( keys [ j ] ) ) | | ( ! preserve & & keys [ i ] . equalsIgnoreCase ( keys [ j ] ) ) ) { dupes + + ; remove ( j ) ; j - - ; } } } return dupes ; } private static class Dataset extends AbstractMap < String , String > { private final Attributes attributes ; Element insert ( final Token . StartTag startTag ) { / / cleanup duplicate attributes : if ( ! startTag . attributes . isEmpty ( ) ) { int dupes = startTag . attributes . deduplicate ( settings ) ; if ( dupes > 0 ) { error ( \" Duplicate attribute \" ) ; } } / / handle empty unknown tags / / when the spec expects an empty tag , will directly hit insertEmpty , so won ' t generate this fake end tag . public boolean preserveAttributeCase ( ) { return preserveAttributeCase ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_79"}
{"buggy_code": "@ Override public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref ! = null ) { objectIdInfo = objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } return objectIdInfo ; } public ObjectIdInfo ( PropertyName name , Class < ? > scope , Class < ? extends ObjectIdGenerator < ? > > gen , Class < ? extends ObjectIdResolver > resolver ) _resolver = resolver ; } public ObjectIdInfo withAlwaysAsId ( boolean state ) { if ( _alwaysAsId = = state ) { if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( NAME_FOR_OBJECT_REF , null , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "fixed_code": "@ Override public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref = = null ) { return objectIdInfo ; } if ( objectIdInfo = = null ) { objectIdInfo = ObjectIdInfo . empty ( ) ; } return objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } private final static ObjectIdInfo EMPTY = new ObjectIdInfo ( PropertyName . NO_NAME , Object . class , null , false , null ) ; public ObjectIdInfo ( PropertyName name , Class < ? > scope , Class < ? extends ObjectIdGenerator < ? > > gen , Class < ? extends ObjectIdResolver > resolver ) _resolver = resolver ; } public static ObjectIdInfo empty ( ) { return EMPTY ; } public ObjectIdInfo withAlwaysAsId ( boolean state ) { if ( _alwaysAsId = = state ) { if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , null ) ; if ( objectIdInfo ! = null ) { oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_79"}
{"buggy_code": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify / / otherwise only verify if neither explicitly annotated . } / / one more thing : ok to override in sub - class if ( oldOne . getClass ( ) = = newOne . getClass ( ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] / / otherwise , which one to choose ? / / new type more generic , use old / / new type more specific , use it } }", "fixed_code": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { boolean verify ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify verify = true ; } else { / / otherwise only verify if neither explicitly annotated . verify = ! explicit ; } / / one more thing : ok to override in sub - class if ( verify & & ( oldOne . getClass ( ) = = newOne . getClass ( ) ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems Class < ? > oldType = oldOne . getRawParameterType ( 0 ) ; Class < ? > newType = newOne . getRawParameterType ( 0 ) ; if ( oldType = = newType ) { throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] \" creators : already had explicitly marked \" + oldOne + \" , encountered \" + newOne ) ; } / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_8"}
{"buggy_code": "} / / then annotated types for property itself Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { nt . getType ( ) ) ; _collectAndResolve ( ac , nt , config , ai , collected ) ; } } NamedType rootType = new NamedType ( rawBase , null ) ; _collectAndResolveByTypeId ( ac , rootType , config , typesHandled , byName ) ; / / then with definitions from property Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { ac = AnnotatedClassResolver . resolveWithoutSuperTypes ( config , nt . getType ( ) ) ; _collectAndResolveByTypeId ( ac , nt , config , typesHandled , byName ) ; } } / / and finally explicit type registrations ( highest precedence ) if ( _registeredSubtypes ! = null ) {", "fixed_code": "} / / then annotated types for property itself if ( property ! = null ) { Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { nt . getType ( ) ) ; _collectAndResolve ( ac , nt , config , ai , collected ) ; } } } NamedType rootType = new NamedType ( rawBase , null ) ; _collectAndResolveByTypeId ( ac , rootType , config , typesHandled , byName ) ; / / then with definitions from property if ( property ! = null ) { Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { ac = AnnotatedClassResolver . resolveWithoutSuperTypes ( config , nt . getType ( ) ) ; _collectAndResolveByTypeId ( ac , nt , config , typesHandled , byName ) ; } } } / / and finally explicit type registrations ( highest precedence ) if ( _registeredSubtypes ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_80"}
{"buggy_code": "type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , keyType = tf . constructGeneralizedType ( keyType , keyClass ) ; } else if ( currRaw . isAssignableFrom ( keyClass ) ) { / / specialization , ok as well keyType = tf . constructSpecializedType ( keyType , keyClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization key type % s into % s ; types not related \" , contentType = tf . constructGeneralizedType ( contentType , contentClass ) ; } else if ( currRaw . isAssignableFrom ( contentClass ) ) { / / specialization , ok as well contentType = tf . constructSpecializedType ( contentType , contentClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization content type % s into % s ; types not related \" , / / Ok : start by refining the main type itself ; common to all types final Class < ? > valueClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . as ( ) ) ; if ( ( valueClass ! = null ) & & ! type . hasRawClass ( valueClass ) ) { try { type = tf . constructSpecializedType ( type , valueClass ) ; } catch ( IllegalArgumentException iae ) { if ( type . isMapLikeType ( ) ) { JavaType keyType = type . getKeyType ( ) ; final Class < ? > keyClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . keyAs ( ) ) ; if ( keyClass ! = null ) { try { keyType = tf . constructSpecializedType ( keyType , keyClass ) ; type = ( ( MapLikeType ) type ) . withKeyType ( keyType ) ; if ( contentType ! = null ) { / / collection [ like ] , map [ like ] , array , reference / / And then value types for all containers : final Class < ? > contentClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . contentAs ( ) ) ; if ( contentClass ! = null ) { try { contentType = tf . constructSpecializedType ( contentType , contentClass ) ; type = type . withContentType ( contentType ) ; return StdTypeResolverBuilder . noTypeInfoBuilder ( ) ; } }", "fixed_code": "type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; } else if ( _primitiveAndWrapper ( currRaw , serClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements type = type . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , keyType = tf . constructGeneralizedType ( keyType , keyClass ) ; } else if ( currRaw . isAssignableFrom ( keyClass ) ) { / / specialization , ok as well keyType = tf . constructSpecializedType ( keyType , keyClass ) ; } else if ( _primitiveAndWrapper ( currRaw , keyClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements keyType = keyType . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization key type % s into % s ; types not related \" , contentType = tf . constructGeneralizedType ( contentType , contentClass ) ; } else if ( currRaw . isAssignableFrom ( contentClass ) ) { / / specialization , ok as well contentType = tf . constructSpecializedType ( contentType , contentClass ) ; } else if ( _primitiveAndWrapper ( currRaw , contentClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements contentType = contentType . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization content type % s into % s ; types not related \" , / / Ok : start by refining the main type itself ; common to all types final Class < ? > valueClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . as ( ) ) ; if ( ( valueClass ! = null ) & & ! type . hasRawClass ( valueClass ) & & ! _primitiveAndWrapper ( type , valueClass ) ) { try { type = tf . constructSpecializedType ( type , valueClass ) ; } catch ( IllegalArgumentException iae ) { if ( type . isMapLikeType ( ) ) { JavaType keyType = type . getKeyType ( ) ; final Class < ? > keyClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . keyAs ( ) ) ; if ( ( keyClass ! = null ) & & ! _primitiveAndWrapper ( keyType , keyClass ) ) { try { keyType = tf . constructSpecializedType ( keyType , keyClass ) ; type = ( ( MapLikeType ) type ) . withKeyType ( keyType ) ; if ( contentType ! = null ) { / / collection [ like ] , map [ like ] , array , reference / / And then value types for all containers : final Class < ? > contentClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . contentAs ( ) ) ; if ( ( contentClass ! = null ) & & ! _primitiveAndWrapper ( contentType , contentClass ) ) { try { contentType = tf . constructSpecializedType ( contentType , contentClass ) ; type = type . withContentType ( contentType ) ; return StdTypeResolverBuilder . noTypeInfoBuilder ( ) ; } private boolean _primitiveAndWrapper ( Class < ? > baseType , Class < ? > refinement ) { if ( baseType . isPrimitive ( ) ) { return baseType = = ClassUtil . primitiveType ( refinement ) ; } if ( refinement . isPrimitive ( ) ) { return refinement = = ClassUtil . primitiveType ( baseType ) ; } return false ; } private boolean _primitiveAndWrapper ( JavaType baseType , Class < ? > refinement ) { if ( baseType . isPrimitive ( ) ) { return baseType . hasRawClass ( ClassUtil . primitiveType ( refinement ) ) ; } if ( refinement . isPrimitive ( ) ) { return refinement = = ClassUtil . primitiveType ( baseType . getRawClass ( ) ) ; } return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_81"}
{"buggy_code": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . getIgnored ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "fixed_code": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . findIgnoredForDeserialization ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_83"}
{"buggy_code": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . if ( _deserialize ( text , ctxt ) ! = null ) { return _deserialize ( text , ctxt ) ; } } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "fixed_code": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . return _deserialize ( text , ctxt ) ; } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_83"}
{"buggy_code": "/ / 08 - Jun - 2017 , tatu : With [ databind # 1648 ] , this gets bit tricky . . / / First : custom pattern will override things if ( ( shape = = JsonFormat . Shape . STRING ) | | format . hasPattern ( ) | | format . hasLocale ( ) | | format . hasTimeZone ( ) ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( ) : StdDateFormat . DATE_FORMAT_STR_ISO8601 ; final Locale loc = format . hasLocale ( ) ? format . getLocale ( ) : serializers . getLocale ( ) ; SimpleDateFormat df = new SimpleDateFormat ( pattern , loc ) ; if ( tz = = null ) { tz = serializers . getTimeZone ( ) ; } df . setTimeZone ( tz ) ; return withFormat ( Boolean . FALSE , df ) ; } / / Otherwise , need one of these changes : / / Jackson ' s own ` StdDateFormat ` is quite easy to deal with . . . / / 08 - Jun - 2017 , tatu : Unfortunately there ' s no generally usable / / mechanism for changing ` DateFormat ` instances ( or even clone ( ) ing ) / / So : require it be ` SimpleDateFormat ` ; can ' t config other types / / serializers . reportBadDefinition ( handledType ( ) , String . format ( / / Ugh . No way to change ` Locale ` , create copy ; must re - crete completely : return this ; }", "fixed_code": "/ / 08 - Jun - 2017 , tatu : With [ databind # 1648 ] , this gets bit tricky . . / / First : custom pattern will override things if ( format . hasPattern ( ) ) { final Locale loc = format . hasLocale ( ) ? format . getLocale ( ) : serializers . getLocale ( ) ; SimpleDateFormat df = new SimpleDateFormat ( format . getPattern ( ) , loc ) ; TimeZone tz = format . hasTimeZone ( ) ? format . getTimeZone ( ) : serializers . getTimeZone ( ) ; df . setTimeZone ( tz ) ; return withFormat ( Boolean . FALSE , df ) ; } / / Otherwise , need one of these changes : final boolean hasLocale = format . hasLocale ( ) ; final boolean hasTZ = format . hasTimeZone ( ) ; final boolean asString = ( shape = = JsonFormat . Shape . STRING ) ; if ( ! hasLocale & & ! hasTZ & & ! asString ) { return this ; } DateFormat df0 = serializers . getConfig ( ) . getDateFormat ( ) ; / / Jackson ' s own ` StdDateFormat ` is quite easy to deal with . . . if ( df0 instanceof StdDateFormat ) { StdDateFormat std = ( StdDateFormat ) df0 ; if ( format . hasLocale ( ) ) { std = std . withLocale ( format . getLocale ( ) ) ; } if ( format . hasTimeZone ( ) ) { std = std . withTimeZone ( format . getTimeZone ( ) ) ; } return withFormat ( Boolean . FALSE , std ) ; } / / 08 - Jun - 2017 , tatu : Unfortunately there ' s no generally usable / / mechanism for changing ` DateFormat ` instances ( or even clone ( ) ing ) / / So : require it be ` SimpleDateFormat ` ; can ' t config other types if ( ! ( df0 instanceof SimpleDateFormat ) ) { / / serializers . reportBadDefinition ( handledType ( ) , String . format ( serializers . reportMappingProblem ( \" Configured ` DateFormat ` ( % s ) not a ` SimpleDateFormat ` ; can not configure ` Locale ` or ` TimeZone ` \" , df0 . getClass ( ) . getName ( ) ) ; } SimpleDateFormat df = ( SimpleDateFormat ) df0 ; if ( hasLocale ) { / / Ugh . No way to change ` Locale ` , create copy ; must re - crete completely : df = new SimpleDateFormat ( df . toPattern ( ) , format . getLocale ( ) ) ; } else { df = ( SimpleDateFormat ) df . clone ( ) ; } TimeZone newTz = format . getTimeZone ( ) ; boolean changeTZ = ( newTz ! = null ) & & ! newTz . equals ( df . getTimeZone ( ) ) ; if ( changeTZ ) { df . setTimeZone ( newTz ) ; } return withFormat ( Boolean . FALSE , df ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_85"}
{"buggy_code": "_referencedType = ref ; } public JavaType getSelfReferencedType ( ) { return _referencedType ; }", "fixed_code": "_referencedType = ref ; } @ Override public JavaType getSuperClass ( ) { if ( _referencedType ! = null ) { return _referencedType . getSuperClass ( ) ; } return super . getSuperClass ( ) ; } public JavaType getSelfReferencedType ( ) { return _referencedType ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_86"}
{"buggy_code": "* * @ since 2 . 8 . 10", "fixed_code": "* * @ since 2 . 8 . 10 protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = \" yyyy - MM - dd ' T ' HH : mm : ss . SSS \" ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_87"}
{"buggy_code": "/ / compatibility - - needed later anyway , and not doing so may open / / security issues . JavaType t = tf . constructFromCanonical ( id ) ; / / Probably cleaner to have a method in ` TypeFactory ` but can ' t add in patch return t ; } Class < ? > cls ;", "fixed_code": "/ / compatibility - - needed later anyway , and not doing so may open / / security issues . JavaType t = tf . constructFromCanonical ( id ) ; if ( ! t . isTypeOrSubTypeOf ( _baseType . getRawClass ( ) ) ) { / / Probably cleaner to have a method in ` TypeFactory ` but can ' t add in patch throw new IllegalArgumentException ( String . format ( \" Class % s not subtype of % s \" , t . getRawClass ( ) . getName ( ) , _baseType ) ) ; } return t ; } Class < ? > cls ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_88"}
{"buggy_code": "/ / [ databind # 1680 ] : may or may not be problem , take no chance s . add ( \" com . sun . rowset . JdbcRowSetImpl \" ) ; / / [ databind # 1737 ] ; JDK provided / / [ databind # 1737 ] ; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; }", "fixed_code": "/ / [ databind # 1680 ] : may or may not be problem , take no chance s . add ( \" com . sun . rowset . JdbcRowSetImpl \" ) ; / / [ databind # 1737 ] ; JDK provided s . add ( \" java . util . logging . FileHandler \" ) ; s . add ( \" java . rmi . server . UnicastRemoteObject \" ) ; / / [ databind # 1737 ] ; 3rd party s . add ( \" org . springframework . aop . support . AbstractBeanFactoryPointcutAdvisor \" ) ; s . add ( \" org . springframework . beans . factory . config . PropertyPathFactoryBean \" ) ; s . add ( \" com . mchange . v2 . c3p0 . JndiRefForwardingDataSource \" ) ; s . add ( \" com . mchange . v2 . c3p0 . WrapperConnectionPoolDataSource \" ) ; DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_89"}
{"buggy_code": "@ Override public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; if ( value instanceof Date ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else { str = value . toString ( ) ; }", "fixed_code": "@ Override public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; Class < ? > cls = value . getClass ( ) ; if ( cls = = String . class ) { str = ( String ) value ; } else if ( Date . class . isAssignableFrom ( cls ) ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else if ( cls = = Class . class ) { str = ( ( Class < ? > ) value ) . getName ( ) ; } else { str = value . toString ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_9"}
{"buggy_code": "public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ; return ( _withArgsCreator ! = null ) ; } @ Override public JavaType getDelegateType ( DeserializationConfig config ) {", "fixed_code": "public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ; return ( _withArgsCreator ! = null ) ; } @ Override public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ; } @ Override public JavaType getDelegateType ( DeserializationConfig config ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_90"}
{"buggy_code": "/ / First : value types may have both value and type handlers JavaType ct = t . getContentType ( ) ; if ( ct ! = null ) { return ( ct . getValueHandler ( ) ! = null ) | | ( ct . getTypeHandler ( ) ! = null ) ; / / Second : map ( - like ) types may have value handler for key ( but not type ; keys are untyped ) } } return false ;", "fixed_code": "/ / First : value types may have both value and type handlers JavaType ct = t . getContentType ( ) ; if ( ct ! = null ) { if ( ( ct . getValueHandler ( ) ! = null ) | | ( ct . getTypeHandler ( ) ! = null ) ) { return true ; } } / / Second : map ( - like ) types may have value handler for key ( but not type ; keys are untyped ) if ( t . isMapLikeType ( ) ) { JavaType kt = t . getKeyType ( ) ; if ( kt . getValueHandler ( ) ! = null ) { return true ; } } } return false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_91"}
{"buggy_code": "/ / [ databind # 1680 ] : may or may not be problem , take no chance s . add ( \" com . sun . rowset . JdbcRowSetImpl \" ) ; / / [ databind # 1737 ] ; JDK provided / / [ databind # 1737 ] ; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; }", "fixed_code": "/ / [ databind # 1680 ] : may or may not be problem , take no chance s . add ( \" com . sun . rowset . JdbcRowSetImpl \" ) ; / / [ databind # 1737 ] ; JDK provided s . add ( \" java . util . logging . FileHandler \" ) ; s . add ( \" java . rmi . server . UnicastRemoteObject \" ) ; / / [ databind # 1737 ] ; 3rd party s . add ( \" org . springframework . aop . support . AbstractBeanFactoryPointcutAdvisor \" ) ; s . add ( \" org . springframework . beans . factory . config . PropertyPathFactoryBean \" ) ; s . add ( \" com . mchange . v2 . c3p0 . JndiRefForwardingDataSource \" ) ; s . add ( \" com . mchange . v2 . c3p0 . WrapperConnectionPoolDataSource \" ) ; DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_92"}
{"buggy_code": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; cls ! = Object . class ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "fixed_code": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( ! raw . isInterface ( ) & & full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; ( cls ! = null ) & & ( cls ! = Object . class ) ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_93"}
{"buggy_code": "{ protected final static String PREFIX_SPRING = \" org . springframework . \" ;", "fixed_code": "{ protected final static String PREFIX_SPRING = \" org . springframework . \" ; protected final static String PREFIX_C3P0 = \" com . mchange . v2 . c3p0 . \" ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_94"}
{"buggy_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , null ) ; } return constructParametricType ( parametrized , pt ) ; } / / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , null ) ; } protected List < JavaType > parseTypes ( MyTokenizer tokens )", "fixed_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , EMPTY_BINDINGS ) ; } return constructParametricType ( parametrized , pt ) ; } / / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , TypeBindings . emptyBindings ( ) ) ; } protected List < JavaType > parseTypes ( MyTokenizer tokens )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_95"}
{"buggy_code": "/ / 25 - May - 2018 , tatu : as per [ databind # 2051 ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / paramName = candidate . findImplicitParamName ( 0 ) ; paramName = candidate . findImplicitParamName ( 0 ) ; useProps = ( paramName ! = null ) & & paramDef . couldSerialize ( ) ; } if ( useProps ) {", "fixed_code": "/ / 25 - May - 2018 , tatu : as per [ databind # 2051 ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / paramName = candidate . findImplicitParamName ( 0 ) ; paramName = candidate . paramName ( 0 ) ; useProps = ( paramName ! = null ) & & paramDef . couldSerialize ( ) ; } if ( useProps ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_96"}
{"buggy_code": "} else { / / 25 - May - 2018 , tatu : [ databind # 1991 ] do not call via generator but through context ; / / this to preserve contextual information gen . writeObject ( _value ) ; } }", "fixed_code": "} else { / / 25 - May - 2018 , tatu : [ databind # 1991 ] do not call via generator but through context ; / / this to preserve contextual information ctxt . defaultSerializeValue ( _value , gen ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_97"}
{"buggy_code": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; return sb . toString ( ) ; }", "fixed_code": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; sb . append ( ' > ' ) ; return sb . toString ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonDatabind_99"}
{"buggy_code": "if ( ( typeProp ! = null ) & & ( typeProp . getCreatorIndex ( ) > = 0 ) ) { / / 31 - May - 2018 , tatu : [ databind # 1328 ] if id is NOT plain ` String ` , need to / / apply deserializer . . . fun fun . buffer . assignParameter ( typeProp , typeId ) ; } } }", "fixed_code": "if ( ( typeProp ! = null ) & & ( typeProp . getCreatorIndex ( ) > = 0 ) ) { / / 31 - May - 2018 , tatu : [ databind # 1328 ] if id is NOT plain ` String ` , need to / / apply deserializer . . . fun fun . final Object v ; if ( typeProp . getType ( ) . hasRawClass ( String . class ) ) { v = typeId ; } else { TokenBuffer tb = new TokenBuffer ( p , ctxt ) ; tb . writeString ( typeId ) ; v = typeProp . getValueDeserializer ( ) . deserialize ( tb . asParserOnFirstToken ( ) , ctxt ) ; tb . close ( ) ; } buffer . assignParameter ( typeProp , v ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JacksonDatabind_99"}
{"buggy_code": "/ / Simple , except that if this is a leaf , need to suppress end : if ( _mayBeLeaf ) { _mayBeLeaf = false ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _currToken = JsonToken . END_ARRAY ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; } } return ( _currToken = JsonToken . VALUE_STRING ) ;", "fixed_code": "/ / Simple , except that if this is a leaf , need to suppress end : if ( _mayBeLeaf ) { _mayBeLeaf = false ; if ( _parsingContext . inArray ( ) ) { / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } } return ( _currToken = JsonToken . VALUE_STRING ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonXml_1"}
{"buggy_code": "* * @ since 2 . 8", "fixed_code": "* * @ since 2 . 8 protected boolean _mixedText ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonXml_2"}
{"buggy_code": "} break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; _currToken = JsonToken . VALUE_STRING ; break ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) {", "fixed_code": "} break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currToken = JsonToken . VALUE_STRING ; return ( _currText = _xmlTokens . getText ( ) ) ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonXml_3"}
{"buggy_code": "{ / / 14 - Nov - 2016 , tatu : As per [ dataformat - xml # 213 ] , we may have explicitly / / configured root name . . . if ( jgen instanceof ToXmlGenerator ) { _initWithRootName ( ( ToXmlGenerator ) jgen , ROOT_NAME_FOR_NULL ) ; } super . serializeValue ( jgen , null ) ; }", "fixed_code": "{ / / 14 - Nov - 2016 , tatu : As per [ dataformat - xml # 213 ] , we may have explicitly / / configured root name . . . QName rootName = _rootNameFromConfig ( ) ; if ( rootName = = null ) { rootName = ROOT_NAME_FOR_NULL ; } if ( jgen instanceof ToXmlGenerator ) { _initWithRootName ( ( ToXmlGenerator ) jgen , rootName ) ; } super . serializeValue ( jgen , null ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonXml_4"}
{"buggy_code": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = src . _rootNameLookup ; }", "fixed_code": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = new XmlRootNameLookup ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonXml_5"}
{"buggy_code": "} } / / Stax2 API only has ' full buffer ' write method : / / should we consider pretty - printing or not ? / / base64 encodes up to 3 bytes into a 4 bytes string / / we still have < 3 bytes in the buffer private byte [ ] toFullBuffer ( byte [ ] data , int offset , int len ) return result ; }", "fixed_code": "} } @ Override public int writeBinary ( Base64Variant b64variant , InputStream data , int dataLength ) throws IOException { if ( data = = null ) { writeNull ( ) ; return 0 ; } _verifyValueWrite ( \" write Binary value \" ) ; if ( _nextName = = null ) { handleMissingName ( ) ; } try { if ( _nextIsAttribute ) { / / Stax2 API only has ' full buffer ' write method : byte [ ] fullBuffer = toFullBuffer ( data , dataLength ) ; _xmlWriter . writeBinaryAttribute ( \" \" , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , fullBuffer ) ; } else if ( checkNextIsUnwrapped ( ) ) { / / should we consider pretty - printing or not ? writeStreamAsBinary ( data , dataLength ) ; } else { if ( _xmlPrettyPrinter ! = null ) { _xmlPrettyPrinter . writeLeafElement ( _xmlWriter , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , toFullBuffer ( data , dataLength ) , 0 , dataLength ) ; } else { _xmlWriter . writeStartElement ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) ) ; writeStreamAsBinary ( data , dataLength ) ; _xmlWriter . writeEndElement ( ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwAsGenerationException ( e , this ) ; } return dataLength ; } private void writeStreamAsBinary ( InputStream data , int len ) throws IOException , XMLStreamException { / / base64 encodes up to 3 bytes into a 4 bytes string byte [ ] tmp = new byte [ 3 ] ; int offset = 0 ; int read ; while ( ( read = data . read ( tmp , offset , Math . min ( 3 - offset , len ) ) ) ! = - 1 ) { offset + = read ; len - = read ; if ( offset = = 3 ) { offset = 0 ; _xmlWriter . writeBinary ( tmp , 0 , 3 ) ; } if ( len = = 0 ) { break ; } } / / we still have < 3 bytes in the buffer if ( offset > 0 ) { _xmlWriter . writeBinary ( tmp , 0 , offset ) ; } } private byte [ ] toFullBuffer ( byte [ ] data , int offset , int len ) return result ; } private byte [ ] toFullBuffer ( InputStream data , final int len ) throws IOException { byte [ ] result = new byte [ len ] ; int offset = 0 ; for ( ; offset < len ; ) { int count = data . read ( result , offset , len - offset ) ; if ( count < 0 ) { _reportError ( \" Too few bytes available : missing \" + ( len - offset ) + \" bytes ( out of \" + len + \" ) \" ) ; } offset + = count ; } return result ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JacksonXml_6"}
{"buggy_code": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . appendChild ( new TextNode ( \" \" , \" \" ) ) ; body ( ) . appendChild ( node ) ; } }", "fixed_code": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode ( \" \" , \" \" ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_1"}
{"buggy_code": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "fixed_code": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header = = null | | header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Jsoup_1"}
{"buggy_code": "return abs . toExternalForm ( ) ; } / / workaround : java resolves ' / / path / file + ? foo ' to ' / / path / ? foo ' , not ' / / path / file ? foo ' as desired URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) {", "fixed_code": "return abs . toExternalForm ( ) ; } / / workaround : java resolves ' / / path / file + ? foo ' to ' / / path / ? foo ' , not ' / / path / file ? foo ' as desired if ( relUrl . startsWith ( \" ? \" ) ) relUrl = base . getPath ( ) + relUrl ; URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_10"}
{"buggy_code": "if ( tq . matchesAny ( combinators ) ) { / / if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; / / chomp first element matcher off queue } return matches ( false ) ; } else if ( tq . matches ( \" : matchesOwn ( \" ) ) { return matches ( true ) ; } else { / / unhandled throw new SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ; } } / / : not ( selector ) / / direct child descendants private static Elements filterForChildren ( Collection < Element > parents , Collection < Element > candidates ) { } / / exclude set . package open so that Elements can implement . not ( ) selector . public static class SelectorParseException extends IllegalStateException { public SelectorParseException ( String msg , Object . . . params ) {", "fixed_code": "if ( tq . matchesAny ( combinators ) ) { / / if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( tq . matches ( \" : has ( \" ) ) { elements . addAll ( root . getAllElements ( ) ) ; } else { addElements ( findElements ( ) ) ; / / chomp first element matcher off queue } return matches ( false ) ; } else if ( tq . matches ( \" : matchesOwn ( \" ) ) { return matches ( true ) ; } else if ( tq . matches ( \" : not ( \" ) ) { return not ( ) ; } else { / / unhandled throw new SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ; } } / / : not ( selector ) private Elements not ( ) { tq . consume ( \" : not \" ) ; String subQuery = tq . chompBalanced ( ' ( ' , ' ) ' ) ; Validate . notEmpty ( subQuery , \" : not ( selector ) subselect must not be empty \" ) ; return filterOut ( root . getAllElements ( ) , select ( subQuery , root ) ) ; } / / direct child descendants private static Elements filterForChildren ( Collection < Element > parents , Collection < Element > candidates ) { } / / exclude set . package open so that Elements can implement . not ( ) selector . static Elements filterOut ( Collection < Element > elements , Collection < Element > outs ) { Elements output = new Elements ( ) ; for ( Element el : elements ) { boolean found = false ; for ( Element out : outs ) { if ( el . equals ( out ) ) { found = true ; break ; } } if ( ! found ) output . add ( el ) ; } return output ; } public static class SelectorParseException extends IllegalStateException { public SelectorParseException ( String msg , Object . . . params ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_11"}
{"buggy_code": "private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } private Elements findElements ( ) { if ( tq . matchChomp ( \" # \" ) ) {", "fixed_code": "private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } private String consumeSubQuery ( ) { StringBuilder sq = new StringBuilder ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( \" ( \" ) ) sq . append ( \" ( \" ) . append ( tq . chompBalanced ( ' ( ' , ' ) ' ) ) . append ( \" ) \" ) ; else if ( tq . matches ( \" [ \" ) ) sq . append ( \" [ \" ) . append ( tq . chompBalanced ( ' [ ' , ' ] ' ) ) . append ( \" ] \" ) ; else if ( tq . matchesAny ( combinators ) ) break ; else sq . append ( tq . consume ( ) ) ; } return sq . toString ( ) ; } private Elements findElements ( ) { if ( tq . matchChomp ( \" # \" ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_12"}
{"buggy_code": "public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; return attributes . hasKey ( attributeKey ) ; }", "fixed_code": "public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; if ( attributeKey . toLowerCase ( ) . startsWith ( \" abs : \" ) ) { String key = attributeKey . substring ( \" abs : \" . length ( ) ) ; if ( attributes . hasKey ( key ) & & ! absUrl ( key ) . equals ( \" \" ) ) return true ; } return attributes . hasKey ( attributeKey ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_13"}
{"buggy_code": "return tagPending . tagName . equals ( lastStartTag . tagName ) ; } boolean isTrackErrors ( ) { return trackErrors ; if ( r . matches ( ' / ' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( RCDATAEndTagOpen ) ; / / diverge from spec : got a start tag , but there ' s no appropriate end tag ( < / title > ) , so rather than / / consuming to EOF ; break out here } else { t . emit ( \" < \" ) ; t . transition ( Rcdata ) ;", "fixed_code": "return tagPending . tagName . equals ( lastStartTag . tagName ) ; } String appropriateEndTagName ( ) { return lastStartTag . tagName ; } boolean isTrackErrors ( ) { return trackErrors ; if ( r . matches ( ' / ' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( RCDATAEndTagOpen ) ; } else if ( r . matchesLetter ( ) & & ! r . containsIgnoreCase ( \" < / \" + t . appropriateEndTagName ( ) ) ) { / / diverge from spec : got a start tag , but there ' s no appropriate end tag ( < / title > ) , so rather than / / consuming to EOF ; break out here t . tagPending = new Token . EndTag ( t . appropriateEndTagName ( ) ) ; t . emitTagPending ( ) ; r . unconsume ( ) ; / / undo \" < \" t . transition ( Data ) ; } else { t . emit ( \" < \" ) ; t . transition ( Rcdata ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_14"}
{"buggy_code": "if ( ! html . hasAttr ( attribute . getKey ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( StringUtil . in ( name , \" base \" , \" basefont \" , \" bgsound \" , \" command \" , \" link \" , \" meta \" , \" noframes \" , \" style \" , \" title \" ) ) { return tb . process ( t , InHead ) ; } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ;", "fixed_code": "if ( ! html . hasAttr ( attribute . getKey ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( StringUtil . in ( name , \" base \" , \" basefont \" , \" bgsound \" , \" command \" , \" link \" , \" meta \" , \" noframes \" , \" script \" , \" style \" , \" title \" ) ) { return tb . process ( t , InHead ) ; } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_15"}
{"buggy_code": "package org . jsoup . nodes ; import org . jsoup . helper . StringUtil ;", "fixed_code": "package org . jsoup . nodes ; import org . jsoup . helper . StringUtil ; import org . jsoup . helper . Validate ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_16"}
{"buggy_code": "} } ; private static String nullString = String . valueOf ( 0x0000 ) ; abstract boolean process ( Token t , TreeBuilder tb ) ;", "fixed_code": "} } ; private static String nullString = String . valueOf ( ' \\ u0000 ' ) ; abstract boolean process ( Token t , TreeBuilder tb ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_17"}
{"buggy_code": "CharacterReader ( String input ) { Validate . notNull ( input ) ; this . input = input ; this . length = input . length ( ) ; } String consumeToEnd ( ) { String data = input . substring ( pos , input . length ( ) - 1 ) ; pos = input . length ( ) ; return data ; }", "fixed_code": "CharacterReader ( String input ) { Validate . notNull ( input ) ; input = input . replaceAll ( \" \\ r \\ n ? \" , \" \\ n \" ) ; / / normalise carriage returns to newlines this . input = input ; this . length = input . length ( ) ; } String consumeToEnd ( ) { String data = input . substring ( pos , input . length ( ) ) ; pos = input . length ( ) ; return data ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_18"}
{"buggy_code": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "fixed_code": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( value . length ( ) = = 0 ) value = attr . getValue ( ) ; / / if it could not be made abs , run as - is to allow custom unknown protocols if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_19"}
{"buggy_code": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "fixed_code": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; popStackToClose ( tag ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_2"}
{"buggy_code": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "fixed_code": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode if ( docData . charAt ( 0 ) = = 65279 ) docData = docData . substring ( 1 ) ; doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_20"}
{"buggy_code": "this . evaluators . addAll ( evaluators ) ; } public void add ( Evaluator e ) { evaluators . add ( e ) ; / / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( \" , \" ) ) { CombiningEvaluator . Or or = new CombiningEvaluator . Or ( evals ) ; evals . clear ( ) ; evals . add ( or ) ; while ( ! tq . isEmpty ( ) ) { String subQuery = tq . chompTo ( \" , \" ) ; or . add ( parse ( subQuery ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; }", "fixed_code": "this . evaluators . addAll ( evaluators ) ; } Or ( ) { super ( ) ; } public void add ( Evaluator e ) { evaluators . add ( e ) ; / / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else if ( combinator = = ' , ' ) { / / group or CombiningEvaluator . Or or ; if ( e instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) e ; or . add ( f ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( e ) ; or . add ( f ) ; } evals . add ( or ) ; } else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_21"}
{"buggy_code": "* @ return sibling elements public Elements siblingElements ( ) { return parent ( ) . children ( ) ; } public Element nextElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; * @ see # nextElementSibling ( ) public Element previousElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; @ return node siblings . If the node has no parent , returns an empty list . public List < Node > siblingNodes ( ) { return parent ( ) . childNodes ( ) ; } public Node previousSibling ( ) { List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; contents = new ArrayList < Element > ( ) ; } public Elements ( Collection < Element > elements ) { contents = new ArrayList < Element > ( elements ) ;", "fixed_code": "* @ return sibling elements public Elements siblingElements ( ) { if ( parentNode = = null ) return new Elements ( 0 ) ; List < Element > elements = parent ( ) . children ( ) ; Elements siblings = new Elements ( elements . size ( ) - 1 ) ; for ( Element el : elements ) if ( el ! = this ) siblings . add ( el ) ; return siblings ; } public Element nextElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; * @ see # nextElementSibling ( ) public Element previousElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; @ return node siblings . If the node has no parent , returns an empty list . public List < Node > siblingNodes ( ) { if ( parentNode = = null ) return Collections . emptyList ( ) ; List < Node > nodes = parentNode . childNodes ; List < Node > siblings = new ArrayList < Node > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node ! = this ) siblings . add ( node ) ; return siblings ; } public Node previousSibling ( ) { if ( parentNode = = null ) return null ; / / root List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; contents = new ArrayList < Element > ( ) ; } public Elements ( int initialCapacity ) { contents = new ArrayList < Element > ( initialCapacity ) ; } public Elements ( Collection < Element > elements ) { contents = new ArrayList < Element > ( elements ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_22"}
{"buggy_code": "return input . substring ( start , pos ) ; } String consumeHexSequence ( ) { int start = pos ; } } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "fixed_code": "return input . substring ( start , pos ) ; } String consumeLetterThenDigitSequence ( ) { int start = pos ; while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ) pos + + ; else break ; } while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( c > = ' 0 ' & & c < = ' 9 ' ) pos + + ; else break ; } return input . substring ( start , pos ) ; } String consumeHexSequence ( ) { int start = pos ; } } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterThenDigitSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_23"}
{"buggy_code": "String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name . toLowerCase ( ) ) ; t . dataBuffer . append ( name ) ; r . advance ( ) ; return ; }", "fixed_code": "String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name . toLowerCase ( ) ) ; t . dataBuffer . append ( name ) ; return ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_24"}
{"buggy_code": "private static final String [ ] formatAsInlineTags = { \" title \" , \" a \" , \" p \" , \" h1 \" , \" h2 \" , \" h3 \" , \" h4 \" , \" h5 \" , \" h6 \" , \" pre \" , \" address \" , \" li \" , \" th \" , \" td \" , \" script \" , \" style \" } ; private static final String [ ] preserveWhitespaceTags = { \" pre \" , \" plaintext \" , \" title \" } ; static { / / creates", "fixed_code": "private static final String [ ] formatAsInlineTags = { \" title \" , \" a \" , \" p \" , \" h1 \" , \" h2 \" , \" h3 \" , \" h4 \" , \" h5 \" , \" h6 \" , \" pre \" , \" address \" , \" li \" , \" th \" , \" td \" , \" script \" , \" style \" } ; private static final String [ ] preserveWhitespaceTags = { \" pre \" , \" plaintext \" , \" title \" , \" textarea \" } ; static { / / creates", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_25"}
{"buggy_code": "Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ;", "fixed_code": "Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; if ( dirtyDocument . body ( ) ! = null ) / / frameset documents won ' t have a body . the clean doc will have empty body . copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_26"}
{"buggy_code": "Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; return charset ; } return null ; }", "fixed_code": "Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_27"}
{"buggy_code": "package org . jsoup . nodes ; import java . io . IOException ; import java . io . InputStream ; * @ return true if a known named entity in the base set * @ see # isNamedEntity ( String ) static String unescape ( String string , boolean strict ) { if ( ! string . contains ( \" & \" ) ) return string ; Matcher m = strict ? strictUnescapePattern . matcher ( string ) : unescapePattern . matcher ( string ) ; StringBuffer accum = new StringBuffer ( string . length ( ) ) ; while ( m . find ( ) ) { int charval = - 1 ; String num = m . group ( 3 ) ; if ( num ! = null ) { try { int base = m . group ( 2 ) ! = null ? 16 : 10 ; charval = Integer . valueOf ( num , base ) ; } catch ( NumberFormatException e ) { } } else { String name = m . group ( 1 ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } if ( charval ! = - 1 | | charval > 0xFFFF ) { String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , Matcher . quoteReplacement ( c ) ) ; } else { m . appendReplacement ( accum , Matcher . quoteReplacement ( m . group ( 0 ) ) ) ; } } m . appendTail ( accum ) ; return accum . toString ( ) ; } / / xhtml has restricted entities * @ param inAttribute if the string is to be escaped in strict mode ( as attributes are ) * @ return an unescaped string }", "fixed_code": "package org . jsoup . nodes ; import org . jsoup . parser . Parser ; import java . io . IOException ; import java . io . InputStream ; * @ return true if a known named entity in the base set * @ see # isNamedEntity ( String ) public static boolean isBaseNamedEntity ( String name ) { return base . containsKey ( name ) ; } static String unescape ( String string , boolean strict ) { return Parser . unescapeEntities ( string , strict ) ; } / / xhtml has restricted entities * @ param inAttribute if the string is to be escaped in strict mode ( as attributes are ) * @ return an unescaped string public static String unescapeEntities ( String string , boolean inAttribute ) { Tokeniser tokeniser = new Tokeniser ( new CharacterReader ( string ) , ParseErrorList . noTracking ( ) ) ; return tokeniser . unescapeEntities ( inAttribute ) ; } String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = new StringBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( ' & ' ) ) ; if ( reader . matches ( ' & ' ) ) { reader . consume ( ) ; Character c = consumeCharacterReference ( null , inAttribute ) ; if ( c = = null ) builder . append ( ' & ' ) ; else builder . append ( c ) ; } } return builder . toString ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_28"}
{"buggy_code": "package org . jsoup . nodes ; import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import org . jsoup . select . Elements ; public String title ( ) { / / title is a preserve whitespace tag ( for document output ) , but normalised here Element titleEl = getElementsByTag ( \" title \" ) . first ( ) ; return titleEl ! = null ? titleEl . text ( ) . trim ( ) : \" \" ; }", "fixed_code": "package org . jsoup . nodes ; import org . jsoup . helper . StringUtil ; import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import org . jsoup . select . Elements ; public String title ( ) { / / title is a preserve whitespace tag ( for document output ) , but normalised here Element titleEl = getElementsByTag ( \" title \" ) . first ( ) ; return titleEl ! = null ? StringUtil . normaliseWhitespace ( titleEl . text ( ) ) . trim ( ) : \" \" ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_29"}
{"buggy_code": "public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop private final TokenQueue tq ; private final Document doc ; private String baseUri ; private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; @ param baseUri base URI of document ( i . e . original fetch location ) , for resolving relative URLs . @ return Document , with empty head , and HTML parsed into body private Document parse ( ) { while ( ! tq . isEmpty ( ) ) { Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node / / otherwise , look up the stack for valid ancestors for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } private boolean empty = false ; / / can hold nothing ; e . g . img private boolean preserveWhitespace = false ; / / for pre , textarea , script etc private List < Tag > ancestors ; / / elements must be a descendant of one of these ancestors private Tag ( String tagName ) { this . tagName = tagName . toLowerCase ( ) ; return false ; / / don ' t allow children to contain their parent ( directly ) return true ; } return ( ! ancestors . isEmpty ( ) ) ? ancestors . get ( 0 ) : null ; } boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; / / HTML tag createBlock ( \" TITLE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setContainDataOnly ( ) ; createInline ( \" BASE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setEmpty ( ) ; createBlock ( \" FRAME \" ) . setAncestor ( \" FRAMESET \" ) . setEmpty ( ) ; createBlock ( \" NOFRAMES \" ) . setAncestor ( \" FRAMESET \" ) . setContainDataOnly ( ) ; createInline ( \" TEXTAREA \" ) . setAncestor ( \" FORM \" ) . setContainDataOnly ( ) ; createInline ( \" LABEL \" ) . setAncestor ( \" FORM \" ) . setOptionalClosing ( ) ; / / not self createInline ( \" BUTTON \" ) . setAncestor ( \" FORM \" ) ; / / bunch of excludes not defined createInline ( \" OPTGROUP \" ) . setAncestor ( \" SELECT \" ) ; createInline ( \" OPTION \" ) . setAncestor ( \" SELECT \" ) . setContainDataOnly ( ) ; createBlock ( \" FIELDSET \" ) . setAncestor ( \" FORM \" ) ; createInline ( \" LEGEND \" ) . setAncestor ( \" FIELDSET \" ) ; / / other createInline ( \" AREA \" ) . setEmpty ( ) ; / / not an inline per - se createInline ( \" PARAM \" ) . setAncestor ( \" OBJECT \" ) . setEmpty ( ) ; createBlock ( \" INS \" ) ; / / only within body createBlock ( \" DEL \" ) ; / / only within body createBlock ( \" DL \" ) ; createInline ( \" DT \" ) . setAncestor ( \" DL \" ) . setOptionalClosing ( ) ; createInline ( \" DD \" ) . setAncestor ( \" DL \" ) . setOptionalClosing ( ) ; createBlock ( \" LI \" ) . setAncestor ( \" UL \" , \" OL \" ) . setOptionalClosing ( ) ; / / only within OL or UL . / / tables createBlock ( \" TABLE \" ) ; / / specific list of only includes ( tr , td , thead etc ) not implemented createBlock ( \" CAPTION \" ) . setAncestor ( \" TABLE \" ) ; createBlock ( \" THEAD \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" TFOOT \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" TBODY \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" COLGROUP \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" COL \" ) . setAncestor ( \" COLGROUP \" ) . setEmpty ( ) ; createBlock ( \" TR \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" TH \" ) . setAncestor ( \" TR \" ) . setOptionalClosing ( ) ; createBlock ( \" TD \" ) . setAncestor ( \" TR \" ) . setOptionalClosing ( ) ; } private static Tag createBlock ( String tagName ) { return this ; } }", "fixed_code": "public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragmentRelaxed ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop private final TokenQueue tq ; private final Document doc ; private String baseUri ; private boolean relaxed = false ; private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; @ param baseUri base URI of document ( i . e . original fetch location ) , for resolving relative URLs . @ return Document , with empty head , and HTML parsed into body public static Document parseBodyFragmentRelaxed ( String bodyHtml , String baseUri ) { Parser parser = new Parser ( bodyHtml , baseUri , true ) ; parser . relaxed = true ; return parser . parse ( ) ; } private Document parse ( ) { while ( ! tq . isEmpty ( ) ) { Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor & & ! relaxed ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node if ( childTag . requiresSpecificParent ( ) ) return stack . getLast ( ) . tag ( ) . isValidParent ( childTag ) ; / / otherwise , look up the stack for valid ancestors for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidAncestor ( childTag ) ) { return true ; } } private boolean empty = false ; / / can hold nothing ; e . g . img private boolean preserveWhitespace = false ; / / for pre , textarea , script etc private List < Tag > ancestors ; / / elements must be a descendant of one of these ancestors private Tag parent ; / / if not null , elements must be a direct child of parent private Tag ( String tagName ) { this . tagName = tagName . toLowerCase ( ) ; return false ; / / don ' t allow children to contain their parent ( directly ) if ( this . requiresSpecificParent ( ) & & this . getImplicitParent ( ) . equals ( child ) ) return false ; return true ; } return ( ! ancestors . isEmpty ( ) ) ? ancestors . get ( 0 ) : null ; } boolean requiresSpecificParent ( ) { return this . parent ! = null ; } boolean isValidParent ( Tag child ) { return this . equals ( child . parent ) ; } boolean isValidAncestor ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; / / HTML tag createBlock ( \" TITLE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setContainDataOnly ( ) ; createInline ( \" BASE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setEmpty ( ) ; createBlock ( \" FRAME \" ) . setParent ( \" FRAMESET \" ) . setEmpty ( ) ; createBlock ( \" NOFRAMES \" ) . setParent ( \" FRAMESET \" ) . setContainDataOnly ( ) ; createInline ( \" TEXTAREA \" ) . setAncestor ( \" FORM \" ) . setContainDataOnly ( ) ; createInline ( \" LABEL \" ) . setAncestor ( \" FORM \" ) . setOptionalClosing ( ) ; / / not self createInline ( \" BUTTON \" ) . setAncestor ( \" FORM \" ) ; / / bunch of excludes not defined createInline ( \" OPTGROUP \" ) . setParent ( \" SELECT \" ) ; / / only contain option createInline ( \" OPTION \" ) . setParent ( \" SELECT \" ) . setContainDataOnly ( ) ; createBlock ( \" FIELDSET \" ) . setAncestor ( \" FORM \" ) ; createInline ( \" LEGEND \" ) . setAncestor ( \" FIELDSET \" ) ; / / other createInline ( \" AREA \" ) . setEmpty ( ) ; / / not an inline per - se createInline ( \" PARAM \" ) . setParent ( \" OBJECT \" ) . setEmpty ( ) ; createBlock ( \" INS \" ) ; / / only within body createBlock ( \" DEL \" ) ; / / only within body createBlock ( \" DL \" ) ; createInline ( \" DT \" ) . setParent ( \" DL \" ) . setOptionalClosing ( ) ; / / only within DL . createInline ( \" DD \" ) . setParent ( \" DL \" ) . setOptionalClosing ( ) ; / / only within DL . createBlock ( \" LI \" ) . setAncestor ( \" UL \" , \" OL \" ) . setOptionalClosing ( ) ; / / only within OL or UL . / / tables createBlock ( \" TABLE \" ) ; / / specific list of only includes ( tr , td , thead etc ) not implemented createBlock ( \" CAPTION \" ) . setParent ( \" TABLE \" ) ; createBlock ( \" THEAD \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just TR createBlock ( \" TFOOT \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just TR createBlock ( \" TBODY \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / optional / implicit open too . just TR createBlock ( \" COLGROUP \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just COL createBlock ( \" COL \" ) . setParent ( \" COLGROUP \" ) . setEmpty ( ) ; createBlock ( \" TR \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just TH , TD createBlock ( \" TH \" ) . setParent ( \" TR \" ) . setOptionalClosing ( ) ; createBlock ( \" TD \" ) . setParent ( \" TR \" ) . setOptionalClosing ( ) ; } private static Tag createBlock ( String tagName ) { return this ; } private Tag setParent ( String tagName ) { parent = Tag . valueOf ( tagName ) ; setAncestor ( tagName ) ; return this ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_3"}
{"buggy_code": "import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; import org . jsoup . parser . Tag ; import java . util . List ; private int copySafeNodes ( Element root , Element destination ) { List < Node > sourceChildren = root . childNodes ( ) ; int numDiscarded = 0 ; for ( Node source : sourceChildren ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; } else { numDiscarded + + ; numDiscarded + = copySafeNodes ( sourceEl , destination ) ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } } return numDiscarded ; } private ElementMeta createSafeElement ( Element sourceEl ) {", "fixed_code": "import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; import org . jsoup . parser . Tag ; import org . jsoup . select . NodeTraversor ; import org . jsoup . select . NodeVisitor ; import java . util . List ; private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0 ; private final Element root ; private Element destination ; / / current element to append nodes to  private CleaningVisitor ( Element root , Element destination ) { this . root = root ; this . destination = destination ; } public void head ( Node source , int depth ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; destination = destChild ; } else if ( source ! = root ) { / / not a safe tag , so don ' t add . don ' t count root against discarded . numDiscarded + + ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } else { / / else , we don ' t care about comments , xml proc instructions , etc numDiscarded + + ; } } public void tail ( Node source , int depth ) { if ( source instanceof Element & & whitelist . isSafeTag ( source . nodeName ( ) ) ) { destination = destination . parent ( ) ; / / would have descended , so pop destination stack } } } private int copySafeNodes ( Element source , Element dest ) { CleaningVisitor cleaningVisitor = new CleaningVisitor ( source , dest ) ; NodeTraversor traversor = new NodeTraversor ( cleaningVisitor ) ; traversor . traverse ( source ) ; return cleaningVisitor . numDiscarded ; } private ElementMeta createSafeElement ( Element sourceEl ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_30"}
{"buggy_code": "@ Override public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames ( ) ; return clone ; } }", "fixed_code": "@ Override public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames = null ; / / derived on first hit , otherwise gets a pointer to source classnames return clone ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_31"}
{"buggy_code": "static class Comment extends Token { final StringBuilder data = new StringBuilder ( ) ; Comment ( ) { type = TokenType . Comment ; / / rewind to capture character that lead us here r . unconsume ( ) ; Token . Comment comment = new Token . Comment ( ) ; comment . data . append ( r . consumeTo ( ' > ' ) ) ; / / todo : replace nullChar with replaceChar t . emit ( comment ) ; void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; insertNode ( insert ) ; }", "fixed_code": "static class Comment extends Token { final StringBuilder data = new StringBuilder ( ) ; boolean bogus = false ; Comment ( ) { type = TokenType . Comment ; / / rewind to capture character that lead us here r . unconsume ( ) ; Token . Comment comment = new Token . Comment ( ) ; comment . bogus = true ; comment . data . append ( r . consumeTo ( ' > ' ) ) ; / / todo : replace nullChar with replaceChar t . emit ( comment ) ; void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; if ( commentToken . bogus ) { / / xml declarations are emitted as bogus comments ( which is right for html , but not xml ) String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Jsoup_31"}
{"buggy_code": "if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; / / ensure we get out of whatever state we are in . emitted for yielded processing return el ; }", "fixed_code": "if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . transition ( TokeniserState . Data ) ; / / handles < script / > , otherwise needs breakout steps from script data tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; / / ensure we get out of whatever state we are in . emitted for yielded processing return el ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_33"}
{"buggy_code": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "fixed_code": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length & & last < = length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_34"}
{"buggy_code": "} Element adopter = new Element ( formatEl . tag ( ) , tb . getBaseUri ( ) ) ; Node [ ] childNodes = furthestBlock . childNodes ( ) . toArray ( new Node [ furthestBlock . childNodeSize ( ) ] ) ; for ( Node childNode : childNodes ) { adopter . appendChild ( childNode ) ; / / append will reparent . thus the clone to avoid concurrent mod .", "fixed_code": "} Element adopter = new Element ( formatEl . tag ( ) , tb . getBaseUri ( ) ) ; adopter . attributes ( ) . addAll ( formatEl . attributes ( ) ) ; Node [ ] childNodes = furthestBlock . childNodes ( ) . toArray ( new Node [ furthestBlock . childNodeSize ( ) ] ) ; for ( Node childNode : childNodes ) { adopter . appendChild ( childNode ) ; / / append will reparent . thus the clone to avoid concurrent mod .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_35"}
{"buggy_code": "import java . io . * ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . Locale ; * public class DataUtil { private static final Pattern charsetPattern = Pattern . compile ( \" ( ? i ) \\ \\ bcharset = \\ \\ s * \\ \" ? ( [ ^ \\ \\ s ; \\ \" ] * ) \" ) ; static final String defaultCharset = \" UTF - 8 \" ; / / used if not found in header or meta charset private static final int bufferSize = 0x20000 ; / / ~ 130K . String foundCharset ; if ( meta . hasAttr ( \" http - equiv \" ) ) { foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } else { foundCharset = meta . attr ( \" charset \" ) ; } if ( foundCharset ! = null & & foundCharset . length ( ) ! = 0 & & ! foundCharset . equals ( defaultCharset ) ) { / / need to re - decode charsetName = foundCharset ; byteData . rewind ( ) ; docData = Charset . forName ( foundCharset ) . decode ( byteData ) . toString ( ) ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; / / if our advanced charset matching fails . . . . we just take the default } return null ; }", "fixed_code": "import java . io . * ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . nio . charset . IllegalCharsetNameException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . Locale ; * public class DataUtil { private static final Pattern charsetPattern = Pattern . compile ( \" ( ? i ) \\ \\ bcharset = \\ \\ s * ( ? : \\ \" | ' ) ? ( [ ^ \\ \\ s , ; \\ \" ' ] * ) \" ) ; static final String defaultCharset = \" UTF - 8 \" ; / / used if not found in header or meta charset private static final int bufferSize = 0x20000 ; / / ~ 130K . String foundCharset ; if ( meta . hasAttr ( \" http - equiv \" ) ) { foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } else { foundCharset = meta . attr ( \" charset \" ) ; } if ( foundCharset ! = null & & foundCharset . length ( ) ! = 0 & & ! foundCharset . equals ( defaultCharset ) ) { / / need to re - decode foundCharset = foundCharset . trim ( ) . replaceAll ( \" [ \\ \" ' ] \" , \" \" ) ; charsetName = foundCharset ; byteData . rewind ( ) ; docData = Charset . forName ( foundCharset ) . decode ( byteData ) . toString ( ) ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . replace ( \" charset = \" , \" \" ) ; if ( charset . isEmpty ( ) ) return null ; try { if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } catch ( IllegalCharsetNameException e ) { / / if our advanced charset matching fails . . . . we just take the default return null ; } } return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_36"}
{"buggy_code": "public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return accum . toString ( ) . trim ( ) ; } private void html ( StringBuilder accum ) {", "fixed_code": "public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return getOutputSettings ( ) . prettyPrint ( ) ? accum . toString ( ) . trim ( ) : accum . toString ( ) ; } private void html ( StringBuilder accum ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_37"}
{"buggy_code": "tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( \" image \" ) ) { return tb . process ( startTag . name ( \" img \" ) ) ; / / change < image > to < img > , unless in svg } else if ( name . equals ( \" isindex \" ) ) { / / how much do we care about the early 90s ? tb . error ( this ) ;", "fixed_code": "tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( \" image \" ) ) { if ( tb . getFromStack ( \" svg \" ) = = null ) return tb . process ( startTag . name ( \" img \" ) ) ; / / change < image > to < img > , unless in svg else tb . insert ( startTag ) ; } else if ( name . equals ( \" isindex \" ) ) { / / how much do we care about the early 90s ? tb . error ( this ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_38"}
{"buggy_code": "docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ;", "fixed_code": "docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; doc = null ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_39"}
{"buggy_code": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; Validate . notEmpty ( name ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "fixed_code": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_40"}
{"buggy_code": "Element element = ( Element ) o ; return this = = o ; } @ Override", "fixed_code": "Element element = ( Element ) o ; return tag . equals ( element . tag ) ; } @ Override", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_41"}
{"buggy_code": "/ / iterate the form control elements and accumulate their values for ( Element el : elements ) { if ( ! el . tag ( ) . isFormSubmittable ( ) ) continue ; / / contents are form listable , superset of submitable String name = el . attr ( \" name \" ) ; if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; } else if ( \" checkbox \" . equalsIgnoreCase ( type ) | | \" radio \" . equalsIgnoreCase ( type ) ) { / / only add checkbox or radio if they have the checked attribute if ( el . hasAttr ( \" checked \" ) ) { final String val = el . val ( ) ; data . add ( HttpConnection . KeyVal . create ( name , val ) ) ; } } else {", "fixed_code": "/ / iterate the form control elements and accumulate their values for ( Element el : elements ) { if ( ! el . tag ( ) . isFormSubmittable ( ) ) continue ; / / contents are form listable , superset of submitable if ( el . hasAttr ( \" disabled \" ) ) continue ; / / skip disabled form inputs String name = el . attr ( \" name \" ) ; if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; } else if ( \" checkbox \" . equalsIgnoreCase ( type ) | | \" radio \" . equalsIgnoreCase ( type ) ) { / / only add checkbox or radio if they have the checked attribute if ( el . hasAttr ( \" checked \" ) ) { final String val = el . val ( ) . length ( ) > 0 ? el . val ( ) : \" on \" ; data . add ( HttpConnection . KeyVal . create ( name , val ) ) ; } } else {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_42"}
{"buggy_code": "for ( int i = 0 ; i < elements . size ( ) ; i + + ) { E element = elements . get ( i ) ; if ( element . equals ( search ) ) return i ; } return null ;", "fixed_code": "for ( int i = 0 ; i < elements . size ( ) ; i + + ) { E element = elements . get ( i ) ; if ( element = = search ) return i ; } return null ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_43"}
{"buggy_code": "protected abstract boolean process ( Token token ) ; protected boolean processStartTag ( String name ) { return process ( start . reset ( ) . name ( name ) ) ; } public boolean processStartTag ( String name , Attributes attrs ) { start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; } protected boolean processEndTag ( String name ) { return process ( end . reset ( ) . name ( name ) ) ; }", "fixed_code": "protected abstract boolean process ( Token token ) ; protected boolean processStartTag ( String name ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . name ( name ) ) ; } return process ( start . reset ( ) . name ( name ) ) ; } public boolean processStartTag ( String name , Attributes attrs ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . nameAttr ( name , attrs ) ) ; } start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; } protected boolean processEndTag ( String name ) { if ( currentToken = = end ) { / / don ' t recycle an in - use token return process ( new Token . EndTag ( ) . name ( name ) ) ; } return process ( end . reset ( ) . name ( name ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_44"}
{"buggy_code": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" td \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "fixed_code": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" th \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_45"}
{"buggy_code": "if ( escapeMode ! = EscapeMode . xhtml ) accum . append ( \" & nbsp ; \" ) ; else accum . append ( c ) ; break ; case ' < ' : if ( ! inAttribute )", "fixed_code": "if ( escapeMode ! = EscapeMode . xhtml ) accum . append ( \" & nbsp ; \" ) ; else accum . append ( \" & # xa0 ; \" ) ; break ; case ' < ' : if ( ! inAttribute )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_46"}
{"buggy_code": "break ; case ' < ' : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! inAttribute ) accum . append ( \" & lt ; \" ) ; else accum . append ( c ) ;", "fixed_code": "break ; case ' < ' : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! inAttribute | | escapeMode = = EscapeMode . xhtml ) accum . append ( \" & lt ; \" ) ; else accum . append ( c ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_47"}
{"buggy_code": "cookie ( cookieName , cookieVal ) ; } } else { / / combine same header names with comma : http : / / www . w3 . org / Protocols / rfc2616 / rfc2616 - sec4 . html # sec4 . 2 if ( ! values . isEmpty ( ) ) header ( name , values . get ( 0 ) ) ; } } }", "fixed_code": "cookie ( cookieName , cookieVal ) ; } } else { / / combine same header names with comma : http : / / www . w3 . org / Protocols / rfc2616 / rfc2616 - sec4 . html # sec4 . 2 if ( values . size ( ) = = 1 ) header ( name , values . get ( 0 ) ) ; else if ( values . size ( ) > 1 ) { StringBuilder accum = new StringBuilder ( ) ; for ( int i = 0 ; i < values . size ( ) ; i + + ) { final String val = values . get ( i ) ; if ( i ! = 0 ) accum . append ( \" , \" ) ; accum . append ( val ) ; } header ( name , accum . toString ( ) ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_48"}
{"buggy_code": "Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; } reindexChildren ( index ) ; } protected void ensureChildNodes ( ) {", "fixed_code": "Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; reindexChildren ( index ) ; } } protected void ensureChildNodes ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_49"}
{"buggy_code": "initOptions ( options ) ; checkFirstModule ( modules ) ; this . externs = makeCompilerInput ( externs , true ) ; this . modules = modules ; * Fill any empty modules with a place holder file . It makes any cross module * motion easier . static final DiagnosticType DUPLICATE_INPUT_IN_MODULES = DiagnosticType . error ( \" JSC_DUPLICATE_INPUT_IN_MODULES_ERROR \" , if ( inputs . size ( ) > 0 ) { return inputs . get ( 0 ) . getAstRoot ( this ) ; } for ( JSModule m : getModuleGraph ( ) . getTransitiveDepsDeepestFirst ( module ) ) { inputs = m . getInputs ( ) ; if ( inputs . size ( ) > 0 ) { return inputs . get ( 0 ) . getAstRoot ( this ) ; } } throw new IllegalStateException ( \" Root module has no inputs \" ) ; }", "fixed_code": "initOptions ( options ) ; checkFirstModule ( modules ) ; fillEmptyModules ( modules ) ; this . externs = makeCompilerInput ( externs , true ) ; this . modules = modules ; * Fill any empty modules with a place holder file . It makes any cross module * motion easier . private void fillEmptyModules ( JSModule [ ] modules ) { for ( int i = 1 ; i < modules . length ; i + + ) { JSModule module = modules [ i ] ; if ( module . getInputs ( ) . isEmpty ( ) ) { module . add ( JSSourceFile . fromCode ( \" [ \" + module . getName ( ) + \" ] \" , \" \" ) ) ; } } } static final DiagnosticType DUPLICATE_INPUT_IN_MODULES = DiagnosticType . error ( \" JSC_DUPLICATE_INPUT_IN_MODULES_ERROR \" , if ( inputs . size ( ) > 0 ) { return inputs . get ( 0 ) . getAstRoot ( this ) ; } throw new IllegalStateException ( \" Root module has no inputs \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_5"}
{"buggy_code": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; }", "fixed_code": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { if ( value . length ( ) = = 0 ) / / no key , no val ; unknown char , keep popping so not get stuck tq . advance ( ) ; return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Jsoup_5"}
{"buggy_code": "Document doc = null ; / / look for BOM - overrides any other header or input if ( charsetName = = null ) { / / determine from meta . safe parse as UTF - 8 / / look for < meta http - equiv = \" Content - Type \" content = \" text / html ; charset = gb2312 \" > or HTML5 < meta charset = \" gb2312 \" > Validate . notEmpty ( charsetName , \" Must set charset arg to character set of file to parse . Set to null to attempt to detect from HTML \" ) ; docData = Charset . forName ( charsetName ) . decode ( byteData ) . toString ( ) ; } if ( docData . length ( ) > 0 & & docData . charAt ( 0 ) = = UNICODE_BOM ) { byteData . rewind ( ) ; docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; doc = null ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "fixed_code": "Document doc = null ; / / look for BOM - overrides any other header or input byteData . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; byteData . get ( bom ) ; byteData . rewind ( ) ; if ( bom [ 0 ] = = 0x00 & & bom [ 1 ] = = 0x00 & & bom [ 2 ] = = ( byte ) 0xFE & & bom [ 3 ] = = ( byte ) 0xFF | | / / BE bom [ 0 ] = = ( byte ) 0xFF & & bom [ 1 ] = = ( byte ) 0xFE & & bom [ 2 ] = = 0x00 & & bom [ 3 ] = = 0x00 ) { / / LE charsetName = \" UTF - 32 \" ; / / and I hope it ' s on your system } else if ( bom [ 0 ] = = ( byte ) 0xFE & & bom [ 1 ] = = ( byte ) 0xFF | | / / BE bom [ 0 ] = = ( byte ) 0xFF & & bom [ 1 ] = = ( byte ) 0xFE ) { charsetName = \" UTF - 16 \" ; / / in all Javas } else if ( bom [ 0 ] = = ( byte ) 0xEF & & bom [ 1 ] = = ( byte ) 0xBB & & bom [ 2 ] = = ( byte ) 0xBF ) { charsetName = \" UTF - 8 \" ; / / in all Javas byteData . position ( 3 ) ; / / 16 and 32 decoders consume the BOM to determine be / le ; utf - 8 should be consumed } if ( charsetName = = null ) { / / determine from meta . safe parse as UTF - 8 / / look for < meta http - equiv = \" Content - Type \" content = \" text / html ; charset = gb2312 \" > or HTML5 < meta charset = \" gb2312 \" > Validate . notEmpty ( charsetName , \" Must set charset arg to character set of file to parse . Set to null to attempt to detect from HTML \" ) ; docData = Charset . forName ( charsetName ) . decode ( byteData ) . toString ( ) ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_50"}
{"buggy_code": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ; } boolean matchesDigit ( ) {", "fixed_code": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) | | Character . isLetter ( c ) ; } boolean matchesDigit ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_51"}
{"buggy_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? > @ return XML declaration public String getWholeDeclaration ( ) { final String decl = this . name ; if ( decl . equals ( \" xml \" ) & & attributes . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( decl ) ; final String version = attributes . get ( \" version \" ) ; if ( version ! = null ) { sb . append ( \" version = \\ \" \" ) . append ( version ) . append ( \" \\ \" \" ) ; } final String encoding = attributes . get ( \" encoding \" ) ; if ( encoding ! = null ) { sb . append ( \" encoding = \\ \" \" ) . append ( encoding ) . append ( \" \\ \" \" ) ; } return sb . toString ( ) ; } else { return this . name ; } } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( getWholeDeclaration ( ) ) . append ( \" > \" ) ; } package org . jsoup . parser ; import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ;", "fixed_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? > @ return XML declaration public String getWholeDeclaration ( ) { return attributes . html ( ) . trim ( ) ; / / attr html starts with a \" \" } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( name ) ; attributes . html ( accum , out ) ; accum . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( \" > \" ) ; } package org . jsoup . parser ; import org . jsoup . Jsoup ; import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( el . tagName ( ) , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_52"}
{"buggy_code": "int end = - 1 ; int depth = 0 ; char last = 0 ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = 0 | | last ! = ESC ) { if ( c . equals ( open ) ) { depth + + ; if ( start = = - 1 )", "fixed_code": "int end = - 1 ; int depth = 0 ; char last = 0 ; boolean inQuote = false ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = 0 | | last ! = ESC ) { if ( c . equals ( ' \\ ' ' ) | | c . equals ( ' \" ' ) & & c ! = open ) inQuote = ! inQuote ; if ( inQuote ) continue ; if ( c . equals ( open ) ) { depth + + ; if ( start = = - 1 )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_53"}
{"buggy_code": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "fixed_code": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; if ( key . matches ( \" [ a - zA - Z_ : ] { 1 } [ - a - zA - Z0 - 9_ : . ] * \" ) ) el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_54"}
{"buggy_code": "public static final String PUBLIC_KEY = \" PUBLIC \" ; public static final String SYSTEM_KEY = \" SYSTEM \" ; private static final String NAME = \" name \" ; private static final String PUBLIC_ID = \" publicId \" ; private static final String SYSTEM_ID = \" systemId \" ; / / todo : quirk mode from publicId and systemId attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } * @ param systemId the doctype ' s system ID * @ param baseUri the doctype ' s base URI @ Override public String nodeName ( ) { } if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; / / todo : quirk state check on doctype ids Token . Doctype d = t . asDoctype ( ) ; DocumentType doctype = new DocumentType ( tb . settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , tb . getBaseUri ( ) ) ; tb . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) tb . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ; static final class Doctype extends Token { final StringBuilder name = new StringBuilder ( ) ; final StringBuilder publicIdentifier = new StringBuilder ( ) ; final StringBuilder systemIdentifier = new StringBuilder ( ) ; boolean forceQuirks = false ; @ Override Token reset ( ) { reset ( name ) ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return name . toString ( ) ; } String getPublicIdentifier ( ) { return publicIdentifier . toString ( ) ; t . emitDoctypePending ( ) ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . PUBLIC_KEY ) ) { t . transition ( AfterDoctypePublicKeyword ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . SYSTEM_KEY ) ) { t . transition ( AfterDoctypeSystemKeyword ) ; } else { t . error ( this ) ; } void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; }", "fixed_code": "public static final String PUBLIC_KEY = \" PUBLIC \" ; public static final String SYSTEM_KEY = \" SYSTEM \" ; private static final String NAME = \" name \" ; private static final String PUB_SYS_KEY = \" pubSysKey \" ; / / PUBLIC or SYSTEM private static final String PUBLIC_ID = \" publicId \" ; private static final String SYSTEM_ID = \" systemId \" ; / / todo : quirk mode from publicId and systemId attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; if ( has ( PUBLIC_ID ) ) { attr ( PUB_SYS_KEY , PUBLIC_KEY ) ; } attr ( SYSTEM_ID , systemId ) ; } * @ param systemId the doctype ' s system ID * @ param baseUri the doctype ' s base URI public DocumentType ( String name , String pubSysKey , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; if ( pubSysKey ! = null ) { attr ( PUB_SYS_KEY , pubSysKey ) ; } attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } @ Override public String nodeName ( ) { } if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUB_SYS_KEY ) ) accum . append ( \" \" ) . append ( attr ( PUB_SYS_KEY ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; / / todo : quirk state check on doctype ids Token . Doctype d = t . asDoctype ( ) ; DocumentType doctype = new DocumentType ( tb . settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , tb . getBaseUri ( ) ) ; tb . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) tb . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ; static final class Doctype extends Token { final StringBuilder name = new StringBuilder ( ) ; String pubSysKey = null ; final StringBuilder publicIdentifier = new StringBuilder ( ) ; final StringBuilder systemIdentifier = new StringBuilder ( ) ; boolean forceQuirks = false ; @ Override Token reset ( ) { reset ( name ) ; pubSysKey = null ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return name . toString ( ) ; } String getPubSysKey ( ) { return pubSysKey ; } String getPublicIdentifier ( ) { return publicIdentifier . toString ( ) ; t . emitDoctypePending ( ) ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . PUBLIC_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . PUBLIC_KEY ; t . transition ( AfterDoctypePublicKeyword ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . SYSTEM_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . SYSTEM_KEY ; t . transition ( AfterDoctypeSystemKeyword ) ; } else { t . error ( this ) ; } void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_56"}
{"buggy_code": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) attributes . remove ( attrKey ) ; } }", "fixed_code": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) it . remove ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_57"}
{"buggy_code": "@ see # clean ( String , org . jsoup . safety . Whitelist ) public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } } * * @ return list of nodes parsed from the input HTML . Note that the context element , if supplied , is not modified .", "fixed_code": "@ see # clean ( String , org . jsoup . safety . Whitelist ) public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } } * * @ return list of nodes parsed from the input HTML . Note that the context element , if supplied , is not modified . public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri , ParseErrorList errorList ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , errorList , treeBuilder . defaultSettings ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_58"}
{"buggy_code": "break ; default : t . error ( this ) ; t . transition ( BeforeAttributeName ) ; } }", "fixed_code": "break ; default : t . error ( this ) ; r . unconsume ( ) ; t . transition ( BeforeAttributeName ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Jsoup_58"}
{"buggy_code": "if ( pendingAttributeName ! = null ) { / / the tokeniser has skipped whitespace control chars , but trimming could collapse to empty for other control codes , so verify here pendingAttributeName = pendingAttributeName . trim ( ) ; Attribute attribute ; if ( hasPendingAttributeValue ) attribute = new Attribute ( pendingAttributeName , else attribute = new BooleanAttribute ( pendingAttributeName ) ; attributes . put ( attribute ) ; } pendingAttributeName = null ; hasEmptyAttributeValue = false ;", "fixed_code": "if ( pendingAttributeName ! = null ) { / / the tokeniser has skipped whitespace control chars , but trimming could collapse to empty for other control codes , so verify here pendingAttributeName = pendingAttributeName . trim ( ) ; if ( pendingAttributeName . length ( ) > 0 ) { Attribute attribute ; if ( hasPendingAttributeValue ) attribute = new Attribute ( pendingAttributeName , else attribute = new BooleanAttribute ( pendingAttributeName ) ; attributes . put ( attribute ) ; } } pendingAttributeName = null ; hasEmptyAttributeValue = false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_59"}
{"buggy_code": "if ( charval ! = - 1 | | charval > 0xFFFF ) { / / out of range String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , c ) ; } else { m . appendReplacement ( accum , m . group ( 0 ) ) ; } } m . appendTail ( accum ) ;", "fixed_code": "if ( charval ! = - 1 | | charval > 0xFFFF ) { / / out of range String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , Matcher . quoteReplacement ( c ) ) ; } else { m . appendReplacement ( accum , Matcher . quoteReplacement ( m . group ( 0 ) ) ) ; / / replace with original string } } m . appendTail ( accum ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_6"}
{"buggy_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; return out ; } * @ return Evaluator public static Evaluator parse ( String query ) { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; }", "fixed_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; if ( depth > 0 ) { / / ran out of queue before seeing enough ) Validate . fail ( \" Did not find balanced maker at \" + out ) ; } return out ; } * @ return Evaluator public static Evaluator parse ( String query ) { try { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } catch ( IllegalArgumentException e ) { throw new Selector . SelectorParseException ( e . getMessage ( ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_60"}
{"buggy_code": "/ / performance sensitive public boolean hasClass ( String className ) { final String classAttr = attributes . get ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "fixed_code": "/ / performance sensitive public boolean hasClass ( String className ) { final String classAttr = attributes . getIgnoreCase ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_61"}
{"buggy_code": "} boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ( ) ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ;", "fixed_code": "} boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . name ( ) ; / / matches with case sensitivity if enabled ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_62"}
{"buggy_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( tag . isSelfClosing ( ) ) tokeniser . acknowledgeSelfClosingFlag ( ) ; } else { tag . setSelfClosing ( ) ; tokeniser . acknowledgeSelfClosingFlag ( ) ; } } return el ; } Token . Doctype doctypePending = new Token . Doctype ( ) ; / / doctype building up Token . Comment commentPending = new Token . Comment ( ) ; / / comment building up private String lastStartTag ; / / the last start tag emitted , to test appropriate end tag private boolean selfClosingFlagAcknowledged = true ; Tokeniser ( CharacterReader reader , ParseErrorList errors ) { this . reader = reader ; } Token read ( ) { if ( ! selfClosingFlagAcknowledged ) { error ( \" Self closing flag not acknowledged \" ) ; selfClosingFlagAcknowledged = true ; } while ( ! isEmitPending ) state . read ( this , reader ) ; if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; if ( startTag . selfClosing ) selfClosingFlagAcknowledged = false ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) this . state = state ; } void acknowledgeSelfClosingFlag ( ) { selfClosingFlagAcknowledged = true ; } final private int [ ] codepointHolder = new int [ 1 ] ; / / holder to not have to keep creating arrays final private int [ ] multipointHolder = new int [ 2 ] ; int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) {", "fixed_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( \" Tag cannot be self closing ; not a void tag \" ) ; } else / / unknown tag , remember this is self closing for output tag . setSelfClosing ( ) ; } return el ; } Token . Doctype doctypePending = new Token . Doctype ( ) ; / / doctype building up Token . Comment commentPending = new Token . Comment ( ) ; / / comment building up private String lastStartTag ; / / the last start tag emitted , to test appropriate end tag Tokeniser ( CharacterReader reader , ParseErrorList errors ) { this . reader = reader ; } Token read ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) this . state = state ; } final private int [ ] codepointHolder = new int [ 1 ] ; / / holder to not have to keep creating arrays final private int [ ] multipointHolder = new int [ 2 ] ; int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_63"}
{"buggy_code": "} private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . insert ( startTag ) ; tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; } / / lists of tags to search through . A little harder to read here , but causes less GC than dynamic varargs .", "fixed_code": "} private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; tb . insert ( startTag ) ; } / / lists of tags to search through . A little harder to read here , but causes less GC than dynamic varargs .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_64"}
{"buggy_code": "} void clearStackToTableBodyContext ( ) { clearStackToContext ( \" tbody \" , \" tfoot \" , \" thead \" ) ; } void clearStackToTableRowContext ( ) { clearStackToContext ( \" tr \" ) ; } private void clearStackToContext ( String . . . nodeNames ) { case StartTag : Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( \" tr \" ) ) { tb . clearStackToTableBodyContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InRow ) ; Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( StringUtil . in ( name , \" th \" , \" td \" ) ) { tb . clearStackToTableRowContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InCell ) ;", "fixed_code": "} void clearStackToTableBodyContext ( ) { clearStackToContext ( \" tbody \" , \" tfoot \" , \" thead \" , \" template \" ) ; } void clearStackToTableRowContext ( ) { clearStackToContext ( \" tr \" , \" template \" ) ; } private void clearStackToContext ( String . . . nodeNames ) { case StartTag : Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( \" template \" ) ) { tb . insert ( startTag ) ; } else if ( name . equals ( \" tr \" ) ) { tb . clearStackToTableBodyContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InRow ) ; Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( \" template \" ) ) { tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , \" th \" , \" td \" ) ) { tb . clearStackToTableRowContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InCell ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_65"}
{"buggy_code": "protected List < Node > ensureChildNodes ( ) { if ( childNodes = = EMPTY_NODES ) { childNodes = new NodeList ( 4 ) ; } return childNodes ; } Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; } private final class NodeList extends ChangeNotifyingArrayList < Node > { NodeList ( int initialCapacity ) { super ( initialCapacity ) ; } public void onContentsChanged ( ) { nodelistChanged ( ) ; } } }", "fixed_code": "protected List < Node > ensureChildNodes ( ) { if ( childNodes = = EMPTY_NODES ) { childNodes = new NodeList ( this , 4 ) ; } return childNodes ; } Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( clone , childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; } private static final class NodeList extends ChangeNotifyingArrayList < Node > { private final Element owner ;  NodeList ( Element owner , int initialCapacity ) { super ( initialCapacity ) ; this . owner = owner ; } public void onContentsChanged ( ) { owner . nodelistChanged ( ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_66"}
{"buggy_code": "\" section \" , \" select \" , \" style \" , \" summary \" , \" table \" , \" tbody \" , \" td \" , \" textarea \" , \" tfoot \" , \" th \" , \" thead \" , \" title \" , \" tr \" , \" ul \" , \" wbr \" , \" xmp \" } ) ; private HtmlTreeBuilderState state ; / / the current state private HtmlTreeBuilderState originalState ; / / original / marked state private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { int depth = stack . size ( ) - 1 ; for ( int pos = depth ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ;", "fixed_code": "\" section \" , \" select \" , \" style \" , \" summary \" , \" table \" , \" tbody \" , \" td \" , \" textarea \" , \" tfoot \" , \" th \" , \" thead \" , \" title \" , \" tr \" , \" ul \" , \" wbr \" , \" xmp \" } ) ; public static final int MaxScopeSearchDepth = 100 ; / / prevents the parser bogging down in exceptionally broken pages private HtmlTreeBuilderState state ; / / the current state private HtmlTreeBuilderState originalState ; / / original / marked state private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { int depth = stack . size ( ) - 1 ; if ( depth > MaxScopeSearchDepth ) { depth = MaxScopeSearchDepth ; } for ( int pos = depth ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_67"}
{"buggy_code": "private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { / / https : / / html . spec . whatwg . org / multipage / parsing . html # has - an - element - in - the - specific - scope int bottom = stack . size ( ) - 1 ; if ( bottom > MaxScopeSearchDepth ) { bottom = MaxScopeSearchDepth ; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; / / don ' t walk too far up the tree", "fixed_code": "private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { / / https : / / html . spec . whatwg . org / multipage / parsing . html # has - an - element - in - the - specific - scope final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; / / don ' t walk too far up the tree", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_68"}
{"buggy_code": "return this ; }", "fixed_code": "return this ; } @ Override protected void removeChild ( Node out ) { super . removeChild ( out ) ; elements . remove ( out ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_69"}
{"buggy_code": "/ / limit ( no cache ) : if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; / / calculate hash : int hash = 0 ;", "fixed_code": "/ / limit ( no cache ) : if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return \" \" ; / / calculate hash : int hash = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_72"}
{"buggy_code": "/ / looks only at this element and five levels up , to prevent recursion & needless stack searches if ( node ! = null & & node instanceof Element ) { Element el = ( Element ) node ; if ( el . tag . preserveWhitespace ( ) ) return true ; else return el . parent ( ) ! = null & & el . parent ( ) . tag . preserveWhitespace ( ) ; } return false ; }", "fixed_code": "/ / looks only at this element and five levels up , to prevent recursion & needless stack searches if ( node ! = null & & node instanceof Element ) { Element el = ( Element ) node ; int i = 0 ; do { if ( el . tag . preserveWhitespace ( ) ) return true ; el = el . parent ( ) ; i + + ; } while ( i < 6 & & el ! = null ) ; } return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Jsoup_72"}
{"buggy_code": "import javax . xml . transform . stream . StreamResult ; import java . io . StringWriter ; import java . util . HashMap ;", "fixed_code": "import javax . xml . transform . stream . StreamResult ; import java . io . StringWriter ; import java . util . HashMap ; import java . util . Stack ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_73"}
{"buggy_code": "/ / 160 is & nbsp ; ( non - breaking space ) . Not in the spec but expected . } / / zero width sp , zw non join , zw join , soft hyphen", "fixed_code": "/ / 160 is & nbsp ; ( non - breaking space ) . Not in the spec but expected . } public static boolean isInvisibleChar ( int c ) { return Character . getType ( c ) = = 16 & & ( c = = 8203 | | c = = 8204 | | c = = 8205 | | c = = 173 ) ; / / zero width sp , zw non join , zw join , soft hyphen }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_74"}
{"buggy_code": "accum . append ( ' ' ) . append ( key ) ; / / collapse checked = null , checked = \" \" , checked = checked ; write out others if ( ! ( out . syntax ( ) = = Document . OutputSettings . Syntax . html & & ( val = = null | | val . equals ( key ) & & Attribute . isBooleanAttribute ( key ) ) ) ) { accum . append ( \" = \\ \" \" ) ; Entities . escape ( accum , val = = null ? EmptyString : val , out , true , false , false ) ; accum . append ( ' \" ' ) ;", "fixed_code": "accum . append ( ' ' ) . append ( key ) ; / / collapse checked = null , checked = \" \" , checked = checked ; write out others if ( ! Attribute . shouldCollapseAttribute ( key , val , out ) ) { accum . append ( \" = \\ \" \" ) ; Entities . escape ( accum , val = = null ? EmptyString : val , out , true , false , false ) ; accum . append ( ' \" ' ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_75"}
{"buggy_code": "tb . processEndTag ( \" p \" ) ; } tb . insert ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( \" form \" ) ) { if ( tb . getFormElement ( ) ! = null ) {", "fixed_code": "tb . processEndTag ( \" p \" ) ; } tb . insert ( startTag ) ; tb . reader . matchConsume ( \" \\ n \" ) ; / / ignore LF if next token tb . framesetOk ( false ) ; } else if ( name . equals ( \" form \" ) ) { if ( tb . getFormElement ( ) ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_76"}
{"buggy_code": "* @ param endTag tag to close private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . name ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) {", "fixed_code": "* @ param endTag tag to close private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . normalName ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_77"}
{"buggy_code": "package org . jsoup . helper ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; if ( charsetName = = null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; doc = parser . parseInput ( reader , baseUri ) ; / / io exception when parsing ( not seen before because reading the stream as we go ) doc . outputSettings ( ) . charset ( charsetName ) ; } input . close ( ) ;", "fixed_code": "package org . jsoup . helper ; import org . jsoup . UncheckedIOException ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; if ( charsetName = = null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; try { doc = parser . parseInput ( reader , baseUri ) ; } catch ( UncheckedIOException e ) { / / io exception when parsing ( not seen before because reading the stream as we go ) throw e . ioException ( ) ; } doc . outputSettings ( ) . charset ( charsetName ) ; } input . close ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_78"}
{"buggy_code": "import org . jsoup . helper . Validate ; import java . util . List ; abstract class LeafNode extends Node { Object value ; / / either a string value , or an attribute map ( in the rare case multiple attributes are set ) @ Override protected List < Node > ensureChildNodes ( ) { throw new UnsupportedOperationException ( \" Leaf Nodes do not have child nodes . \" ) ; } }", "fixed_code": "import org . jsoup . helper . Validate ; import java . util . Collections ; import java . util . List ; abstract class LeafNode extends Node { private static final List < Node > EmptyNodes = Collections . emptyList ( ) ; Object value ; / / either a string value , or an attribute map ( in the rare case multiple attributes are set ) @ Override protected List < Node > ensureChildNodes ( ) { return EmptyNodes ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_79"}
{"buggy_code": "} protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , ownerDocument ( ) . outputSettings ( ) ) ) . traverse ( this ) ; } / / if this node has no document ( or parent ) , retrieve the default output settings", "fixed_code": "} protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , getOutputSettings ( ) ) ) . traverse ( this ) ; } / / if this node has no document ( or parent ) , retrieve the default output settings private Document . OutputSettings getOutputSettings ( ) { return ownerDocument ( ) ! = null ? ownerDocument ( ) . outputSettings ( ) : ( new Document ( \" \" ) ) . outputSettings ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_8"}
{"buggy_code": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "fixed_code": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } / / else , we couldn ' t parse it as a decl , so leave as a comment } } insertNode ( insert ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_80"}
{"buggy_code": "import org . jsoup . UncheckedIOException ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; import org . jsoup . nodes . Node ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "fixed_code": "import org . jsoup . UncheckedIOException ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Comment ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; import org . jsoup . nodes . Node ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_81"}
{"buggy_code": "} Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; / / some charsets can read but not encode ; switch to an encodable charset and update the meta el } input . close ( ) ; return doc ;", "fixed_code": "} Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; if ( ! charset . canEncode ( ) ) { / / some charsets can read but not encode ; switch to an encodable charset and update the meta el doc . charset ( Charset . forName ( defaultCharset ) ) ; } } input . close ( ) ; return doc ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_82"}
{"buggy_code": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; } case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; / / intended fall through to next > case ' > ' : t . emitTagPending ( ) ; case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; / / intended fall through as if > case ' > ' : t . emitTagPending ( ) ; break ; case ' \" ' : case ' \\ ' ' : case ' < ' : case ' = ' : t . error ( this ) ; t . tagPending . newAttribute ( ) ;", "fixed_code": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = ' < ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; } case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; case ' < ' : / / NOTE : out of spec , but clear author intent t . error ( this ) ; r . unconsume ( ) ; / / intended fall through to next > case ' > ' : t . emitTagPending ( ) ; case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; case ' < ' : / / NOTE : out of spec , but clear ( spec has this as a part of the attribute name ) t . error ( this ) ; r . unconsume ( ) ; / / intended fall through as if > case ' > ' : t . emitTagPending ( ) ; break ; case ' \" ' : case ' \\ ' ' : case ' = ' : t . error ( this ) ; t . tagPending . newAttribute ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_83"}
{"buggy_code": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "fixed_code": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace = = null & & tagName . contains ( \" : \" ) ? doc . createElementNS ( \" \" , tagName ) : / / doesn ' t have a real namespace defined doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_84"}
{"buggy_code": "public Attribute ( String key , String val , Attributes parent ) { Validate . notNull ( key ) ; this . key = key . trim ( ) ; Validate . notEmpty ( key ) ; / / trimming could potentially make empty , so validate here this . val = val ; this . parent = parent ; }", "fixed_code": "public Attribute ( String key , String val , Attributes parent ) { Validate . notNull ( key ) ; key = key . trim ( ) ; Validate . notEmpty ( key ) ; / / trimming could potentially make empty , so validate here this . key = key ; this . val = val ; this . parent = parent ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_85"}
{"buggy_code": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "fixed_code": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_86"}
{"buggy_code": "* of the tag case preserving setting of the parser . * @ return void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . nodeName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . nodeName ( ) , TagSearchEndTags ) ) pop ( ) ; } boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . nodeName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . nodeName ( ) . equals ( b . nodeName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . nodeName ( ) ) ; / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . nodeName ( ) . equals ( nodeName ) ) return next ; } return null ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( el . nodeName ( ) . equals ( \" li \" ) ) { tb . processEndTag ( \" li \" ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . nodeName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . nodeName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else { } else if ( name . equals ( \" frameset \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . nodeName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else if ( ! tb . framesetOk ( ) ) { if ( tb . inButtonScope ( \" p \" ) ) { tb . processEndTag ( \" p \" ) ; } if ( StringUtil . inSorted ( tb . currentElement ( ) . nodeName ( ) , Constants . Headings ) ) { tb . error ( this ) ; tb . pop ( ) ; } ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( StringUtil . inSorted ( el . nodeName ( ) , Constants . DdDt ) ) { tb . processEndTag ( el . nodeName ( ) ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . nodeName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { else tb . transition ( InSelect ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartOptions ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartRuby ) ) { if ( tb . inScope ( \" ruby \" ) ) { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" ruby \" ) ) { tb . error ( this ) ; tb . popStackToBefore ( \" ruby \" ) ; / / i . e . close up to but not include name } tb . error ( this ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } else if ( ! tb . inScope ( formatEl . nodeName ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement ( ) ! = formatEl ) } } if ( furthestBlock = = null ) { tb . popStackToClose ( formatEl . nodeName ( ) ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } lastNode = node ; } if ( StringUtil . inSorted ( commonAncestor . nodeName ( ) , Constants . InBodyEndTableFosters ) ) { if ( lastNode . parent ( ) ! = null ) lastNode . remove ( ) ; tb . insertInFosterParent ( lastNode ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; / / remove currentForm from stack . will shift anything under up . tb . removeFromStack ( currentForm ) ; return tb . process ( endTag ) ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( Constants . Headings ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; } boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = tb . settings . normalizeTag ( t . asEndTag ( ) . name ( ) ) ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ; if ( node . nodeName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . nodeName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } return true ; / / todo : as above todo } else if ( t . isEOF ( ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; return true ; / / stops parsing } boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . nodeName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; if ( ! isWhitespace ( character ) ) { / / InTable anything else section : tb . error ( this ) ; if ( StringUtil . in ( tb . currentElement ( ) . nodeName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; tb . process ( new Token . Character ( ) . data ( character ) , InBody ) ; tb . setFosterInserts ( false ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" caption \" ) ) tb . error ( this ) ; tb . popStackToClose ( \" caption \" ) ; tb . clearFormattingElementsToLastMarker ( ) ; case EndTag : Token . EndTag endTag = t . asEndTag ( ) ; if ( endTag . normalName . equals ( \" colgroup \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; break ; case EOF : if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) return true ; / / stop parsing ; frag case else return anythingElse ( t , tb ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . nodeName ( ) ) ; return tb . process ( t ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; if ( name . equals ( \" html \" ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( \" option \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" optgroup \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; else if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" optgroup \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" select \" ) ) { name = end . normalName ( ) ; switch ( name ) { case \" optgroup \" : if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) & & tb . aboveOnStack ( tb . currentElement ( ) ) ! = null & & tb . aboveOnStack ( tb . currentElement ( ) ) . nodeName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" option \" ) ; if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" optgroup \" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case \" option \" : if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . pop ( ) ; else tb . error ( this ) ; } break ; case EOF : if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; break ; default : return false ; } } else if ( t . isEndTag ( ) & & t . asEndTag ( ) . normalName ( ) . equals ( \" frameset \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return false ; } else { tb . pop ( ) ; if ( ! tb . isFragmentParsing ( ) & & ! tb . currentElement ( ) . nodeName ( ) . equals ( \" frameset \" ) ) { tb . transition ( AfterFrameset ) ; } } } else if ( t . isEOF ( ) ) { if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return true ; } package org . jsoup . parser ; import org . jsoup . helper . Validate ; import java . util . HashMap ; import java . util . Map ; private static final Map < String , Tag > tags = new HashMap < > ( ) ; / / map of known tags private String tagName ; private boolean isBlock = true ; / / block or inline private boolean formatAsBlock = true ; / / should be formatted as a block private boolean canContainInline = true ; / / only pcdata if not private Tag ( String tagName ) { this . tagName = tagName ; }", "fixed_code": "* of the tag case preserving setting of the parser . * @ return public String normalName ( ) { return tag . normalName ( ) ; } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; } boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . normalName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . normalName ( ) . equals ( b . normalName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . normalName ( ) ) ; / / todo : avoid fostering here ? / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . normalName ( ) . equals ( nodeName ) ) return next ; } return null ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( el . normalName ( ) . equals ( \" li \" ) ) { tb . processEndTag ( \" li \" ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . normalName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . normalName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else { } else if ( name . equals ( \" frameset \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . normalName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else if ( ! tb . framesetOk ( ) ) { if ( tb . inButtonScope ( \" p \" ) ) { tb . processEndTag ( \" p \" ) ; } if ( StringUtil . inSorted ( tb . currentElement ( ) . normalName ( ) , Constants . Headings ) ) { tb . error ( this ) ; tb . pop ( ) ; } ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( StringUtil . inSorted ( el . normalName ( ) , Constants . DdDt ) ) { tb . processEndTag ( el . normalName ( ) ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . normalName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { else tb . transition ( InSelect ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartOptions ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartRuby ) ) { if ( tb . inScope ( \" ruby \" ) ) { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" ruby \" ) ) { tb . error ( this ) ; tb . popStackToBefore ( \" ruby \" ) ; / / i . e . close up to but not include name } tb . error ( this ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } else if ( ! tb . inScope ( formatEl . normalName ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement ( ) ! = formatEl ) } } if ( furthestBlock = = null ) { tb . popStackToClose ( formatEl . normalName ( ) ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } lastNode = node ; } if ( StringUtil . inSorted ( commonAncestor . normalName ( ) , Constants . InBodyEndTableFosters ) ) { if ( lastNode . parent ( ) ! = null ) lastNode . remove ( ) ; tb . insertInFosterParent ( lastNode ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; / / remove currentForm from stack . will shift anything under up . tb . removeFromStack ( currentForm ) ; return tb . process ( endTag ) ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( Constants . Headings ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; } boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; / / case insensitive search - goal is to preserve output case , not for the parse to be case sensitive ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } return true ; / / todo : as above todo } else if ( t . isEOF ( ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; return true ; / / stops parsing } boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; if ( ! isWhitespace ( character ) ) { / / InTable anything else section : tb . error ( this ) ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; tb . process ( new Token . Character ( ) . data ( character ) , InBody ) ; tb . setFosterInserts ( false ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" caption \" ) ) tb . error ( this ) ; tb . popStackToClose ( \" caption \" ) ; tb . clearFormattingElementsToLastMarker ( ) ; case EndTag : Token . EndTag endTag = t . asEndTag ( ) ; if ( endTag . normalName . equals ( \" colgroup \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) { / / frag case tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; break ; case EOF : if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) return true ; / / stop parsing ; frag case else return anythingElse ( t , tb ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; / / tbody , tfoot , thead return tb . process ( t ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; if ( name . equals ( \" html \" ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( \" option \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" optgroup \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; else if ( tb . currentElement ( ) . normalName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" optgroup \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" select \" ) ) { name = end . normalName ( ) ; switch ( name ) { case \" optgroup \" : if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) & & tb . aboveOnStack ( tb . currentElement ( ) ) ! = null & & tb . aboveOnStack ( tb . currentElement ( ) ) . normalName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" option \" ) ; if ( tb . currentElement ( ) . normalName ( ) . equals ( \" optgroup \" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case \" option \" : if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . pop ( ) ; else tb . error ( this ) ; } break ; case EOF : if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; break ; default : return false ; } } else if ( t . isEndTag ( ) & & t . asEndTag ( ) . normalName ( ) . equals ( \" frameset \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) { / / frag tb . error ( this ) ; return false ; } else { tb . pop ( ) ; if ( ! tb . isFragmentParsing ( ) & & ! tb . currentElement ( ) . normalName ( ) . equals ( \" frameset \" ) ) { tb . transition ( AfterFrameset ) ; } } } else if ( t . isEOF ( ) ) { if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return true ; } package org . jsoup . parser ; import org . jsoup . helper . Validate ; import org . jsoup . internal . Normalizer ; import java . util . HashMap ; import java . util . Map ; private static final Map < String , Tag > tags = new HashMap < > ( ) ; / / map of known tags private String tagName ; private String normalName ; / / always the lower case version of this tag , regardless of case preservation mode private boolean isBlock = true ; / / block or inline private boolean formatAsBlock = true ; / / should be formatted as a block private boolean canContainInline = true ; / / only pcdata if not private Tag ( String tagName ) { this . tagName = tagName ; normalName = Normalizer . lowerCase ( tagName ) ; } public String normalName ( ) { return normalName ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_87"}
{"buggy_code": "@ return the attribute value public String getValue ( ) { return val ; }", "fixed_code": "@ return the attribute value public String getValue ( ) { return Attributes . checkNotNull ( val ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_88"}
{"buggy_code": "@ param val the new attribute value ; must not be null public String setValue ( String val ) { String oldVal = parent . get ( this . key ) ; if ( parent ! = null ) { int i = parent . indexOfKey ( this . key ) ; if ( i ! = Attributes . NotFound ) parent . vals [ i ] = val ;", "fixed_code": "@ param val the new attribute value ; must not be null public String setValue ( String val ) { String oldVal = this . val ; if ( parent ! = null ) { oldVal = parent . get ( this . key ) ; / / trust the container more int i = parent . indexOfKey ( this . key ) ; if ( i ! = Attributes . NotFound ) parent . vals [ i ] = val ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_89"}
{"buggy_code": "private static final Map < Character , String > xhtmlByVal ; private static final Map < Character , String > baseByVal ; private static final Map < Character , String > fullByVal ; private static final Pattern unescapePattern = Pattern . compile ( \" & ( # ( x | X ) ? ( [ 0 - 9a - fA - F ] + ) | [ a - zA - Z ] + ) ; ? \" ) ; static String escape ( String string , Document . OutputSettings out ) { return escape ( string , out . encoder ( ) , out . escapeMode ( ) ) ;", "fixed_code": "private static final Map < Character , String > xhtmlByVal ; private static final Map < Character , String > baseByVal ; private static final Map < Character , String > fullByVal ; private static final Pattern unescapePattern = Pattern . compile ( \" & ( # ( x | X ) ? ( [ 0 - 9a - fA - F ] + ) | [ a - zA - Z ] + \\ \\ d * ) ; ? \" ) ; static String escape ( String string , Document . OutputSettings out ) { return escape ( string , out . encoder ( ) , out . escapeMode ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_9"}
{"buggy_code": "return false ; } while ( i < end ) { i + + ;", "fixed_code": "return false ; } if ( end > = input . length ) return false ; while ( i < end ) { i + + ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_90"}
{"buggy_code": "super ( cause ) ; } public IOException ioException ( ) { return ( IOException ) getCause ( ) ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; } public CharacterReader ( Reader input ) { return ( nextIndexOf ( loScan ) > - 1 ) | | ( nextIndexOf ( hiScan ) > - 1 ) ; } @ Override public String toString ( ) {", "fixed_code": "super ( cause ) ; } public UncheckedIOException ( String message ) { super ( new IOException ( message ) ) ; } public IOException ioException ( ) { return ( IOException ) getCause ( ) ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; if ( isBinary ( ) ) { throw new UncheckedIOException ( \" Input is binary and unsupported \" ) ; } } public CharacterReader ( Reader input ) { return ( nextIndexOf ( loScan ) > - 1 ) | | ( nextIndexOf ( hiScan ) > - 1 ) ; } private static final int numNullsConsideredBinary = 10 ; / / conservative boolean isBinary ( ) { int nullsSeen = 0 ; for ( int i = bufPos ; i < bufLength ; i + + ) { if ( charBuf [ i ] = = ' \\ 0 ' ) nullsSeen + + ; } return nullsSeen > = numNullsConsideredBinary ; } @ Override public String toString ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_91"}
{"buggy_code": "if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; if ( \" select \" . equals ( el . normalName ( ) ) ) { Elements options = el . select ( \" option [ selected ] \" ) ;", "fixed_code": "if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; if ( type . equalsIgnoreCase ( \" button \" ) ) continue ; / / browsers don ' t submit these if ( \" select \" . equals ( el . normalName ( ) ) ) { Elements options = el . select ( \" option [ selected ] \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Jsoup_93"}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return node instanceof Element ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_1"}
{"buggy_code": "} public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . computeValue ( context ) , args [ 1 ] . computeValue ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; }", "fixed_code": "} public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . compute ( context ) , args [ 1 ] . compute ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_10"}
{"buggy_code": "import java . util . ArrayList ; import java . util . List ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } if ( testNS ! = null ) { import java . util . Collections ; import java . util . List ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; ns = Namespace . XML_NAMESPACE ; } else { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } else { this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } \\ No newline at end of file }", "fixed_code": "import java . util . ArrayList ; import java . util . List ; import org . apache . commons . jxpath . ri . NamespaceResolver ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; String testNS = null ; if ( testPrefix ! = null ) { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; testNS = nsr = = null ? null : nsr . getNamespaceURI ( testPrefix ) ; testNS = testNS = = null ? parent . getNamespaceURI ( testPrefix ) : testNS ; } if ( testNS ! = null ) { import java . util . Collections ; import java . util . List ; import org . apache . commons . jxpath . ri . NamespaceResolver ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; ns = Namespace . XML_NAMESPACE ; } else { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; if ( nsr ! = null ) { String uri = nsr . getNamespaceURI ( prefix ) ; if ( uri ! = null ) { ns = Namespace . getNamespace ( prefix , uri ) ; } } if ( ns = = null ) { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } } else { this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_11"}
{"buggy_code": "| | testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) ; } return false ; }", "fixed_code": "| | testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) | | nodeNS = = null & & equalStrings ( testPrefix , getPrefix ( node ) ) ; } return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_12"}
{"buggy_code": "protected Object functionFloor ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . floor ( v ) ) ; } protected Object functionCeiling ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . ceil ( v ) ) ; } protected Object functionRound ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . round ( v ) ) ; }", "fixed_code": "protected Object functionFloor ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . floor ( v ) ) ; } protected Object functionCeiling ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . ceil ( v ) ) ; } protected Object functionRound ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . round ( v ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_14"}
{"buggy_code": "* @ return prefix if found * @ since JXPath 1 . 3 public synchronized String getNamespaceURI ( String prefix ) { String uri = ( String ) namespaceMap . get ( prefix ) ; if ( uri = = null & & pointer ! = null ) { uri = pointer . getNamespaceURI ( prefix ) ; } if ( uri = = null & & parent ! = null ) { return parent . getNamespaceURI ( prefix ) ; } return uri ; } public synchronized String getPrefix ( String namespaceURI ) { if ( reverseMap = = null ) { reverseMap = new HashMap ( ) ; NodeIterator ni = pointer . namespaceIterator ( ) ; if ( ni ! = null ) { for ( int position = 1 ; ni . setPosition ( position ) ; position + + ) { NodePointer nsPointer = ni . getNodePointer ( ) ; String uri = nsPointer . getNamespaceURI ( ) ; String prefix = nsPointer . getName ( ) . getName ( ) ; if ( ! \" \" . equals ( prefix ) ) { reverseMap . put ( uri , prefix ) ; } } } Iterator it = namespaceMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; } } String prefix = ( String ) reverseMap . get ( namespaceURI ) ; if ( prefix = = null & & parent ! = null ) { return parent . getPrefix ( namespaceURI ) ; } return prefix ; } public String getNamespaceURI ( String prefix ) { if ( prefix = = null | | prefix . equals ( \" \" ) ) { Element element = ( Element ) node ; String prefix = name . getPrefix ( ) ; if ( prefix ! = null ) { String ns = getNamespaceURI ( prefix ) ; if ( ns = = null ) { throw new JXPathException ( \" Unknown namespace prefix : \" + prefix ) ;", "fixed_code": "* @ return prefix if found * @ since JXPath 1 . 3 protected static String getPrefix ( NodePointer pointer , String namespaceURI ) { NodePointer currentPointer = pointer ; while ( currentPointer ! = null ) { NodeIterator ni = currentPointer . namespaceIterator ( ) ; for ( int position = 1 ; ni ! = null & & ni . setPosition ( position ) ; position + + ) { NodePointer nsPointer = ni . getNodePointer ( ) ; String uri = nsPointer . getNamespaceURI ( ) ; if ( uri . equals ( namespaceURI ) ) { String prefix = nsPointer . getName ( ) . getName ( ) ; if ( ! \" \" . equals ( prefix ) ) { return prefix ; } } } currentPointer = pointer . getParent ( ) ; } return null ; } public synchronized String getNamespaceURI ( String prefix ) { String uri = getExternallyRegisteredNamespaceURI ( prefix ) ; return uri = = null & & pointer ! = null ? pointer . getNamespaceURI ( prefix ) : uri ; } protected synchronized String getExternallyRegisteredNamespaceURI ( String prefix ) { String uri = ( String ) namespaceMap . get ( prefix ) ; return uri = = null & & parent ! = null ? parent . getExternallyRegisteredNamespaceURI ( prefix ) : uri ; } public synchronized String getPrefix ( String namespaceURI ) { String prefix = getExternallyRegisteredPrefix ( namespaceURI ) ; return prefix = = null & & pointer ! = null ? getPrefix ( pointer , namespaceURI ) : prefix ; } protected synchronized String getExternallyRegisteredPrefix ( String namespaceURI ) { if ( reverseMap = = null ) { reverseMap = new HashMap ( ) ; Iterator it = namespaceMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; } } String prefix = ( String ) reverseMap . get ( namespaceURI ) ; return prefix = = null & & parent ! = null ? parent . getExternallyRegisteredPrefix ( namespaceURI ) : prefix ; } public synchronized NamespaceResolver getNamespaceResolver ( ) { if ( localNamespaceResolver = = null ) { localNamespaceResolver = new NamespaceResolver ( super . getNamespaceResolver ( ) ) ; localNamespaceResolver . setNamespaceContextPointer ( this ) ; } return localNamespaceResolver ; } public String getNamespaceURI ( String prefix ) { if ( prefix = = null | | prefix . equals ( \" \" ) ) { Element element = ( Element ) node ; String prefix = name . getPrefix ( ) ; if ( prefix ! = null ) { String ns = null ; NamespaceResolver nsr = getNamespaceResolver ( ) ; if ( nsr ! = null ) { ns = nsr . getNamespaceURI ( prefix ) ; } if ( ns = = null ) { throw new JXPathException ( \" Unknown namespace prefix : \" + prefix ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JxPath_14"}
{"buggy_code": "package org . apache . commons . jxpath . ri . axes ; import java . util . ArrayList ; import org . apache . commons . jxpath . BasicNodeSet ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; while ( ctx . nextNode ( ) ) { NodePointer ptr = ctx . getCurrentNodePointer ( ) ; if ( ! pointers . contains ( ptr ) ) { nodeSet . add ( ptr ) ; pointers . add ( ptr ) ; } } } } } return super . setPosition ( position ) ; } \\ No newline at end of file }", "fixed_code": "package org . apache . commons . jxpath . ri . axes ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . commons . jxpath . BasicNodeSet ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; while ( ctx . nextNode ( ) ) { NodePointer ptr = ctx . getCurrentNodePointer ( ) ; if ( ! pointers . contains ( ptr ) ) { pointers . add ( ptr ) ; } } } } sortPointers ( pointers ) ;  for ( Iterator it = pointers . iterator ( ) ; it . hasNext ( ) ; ) { nodeSet . add ( ( Pointer ) it . next ( ) ) ; } } return super . setPosition ( position ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_15"}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_16"}
{"buggy_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( equalStrings ( testPrefix , nodePrefix ) ) { return true ; } String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } String nodeNS = null ; if ( nodePrefix ! = null ) { nodeNS = parent . getNamespaceURI ( nodePrefix ) ; } return equalStrings ( testNS , nodeNS ) ; } return false ; } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } \\ No newline at end of file } String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; if ( ns ! = null ) { Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } \\ No newline at end of file }", "fixed_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( testPrefix = = null | | equalStrings ( testPrefix , nodePrefix ) ) { return true ; } if ( nodePrefix = = null ) { return false ; } return equalStrings ( parent . getNamespaceURI ( testPrefix ) , parent . getNamespaceURI ( nodePrefix ) ) ; } return false ; } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( ns = = Namespace . NO_NAMESPACE | | attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_17"}
{"buggy_code": "package org . apache . commons . jxpath . ri . axes ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . compiler . NodeNameTest ; import org . apache . commons . jxpath . ri . compiler . NodeTest ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; * @ version $ Revision $ $ Date $ public class AttributeContext extends EvalContext { private NodeTest nodeTest ; private boolean setStarted = false ; super . setPosition ( getCurrentPosition ( ) + 1 ) ; if ( ! setStarted ) { setStarted = true ; if ( ! ( nodeTest instanceof NodeNameTest ) ) { return false ; } QName name = ( ( NodeNameTest ) nodeTest ) . getNodeName ( ) ; iterator = parentContext . getCurrentNodePointer ( ) . attributeIterator ( name ) ; } if ( iterator = = null ) { return false ; currentNodePointer = iterator . getNodePointer ( ) ; return true ; } \\ No newline at end of file }", "fixed_code": "package org . apache . commons . jxpath . ri . axes ; import org . apache . commons . jxpath . ri . Compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . compiler . NodeNameTest ; import org . apache . commons . jxpath . ri . compiler . NodeTest ; import org . apache . commons . jxpath . ri . compiler . NodeTypeTest ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; * @ version $ Revision $ $ Date $ public class AttributeContext extends EvalContext { private static final NodeNameTest WILDCARD_TEST = new NodeNameTest ( new QName ( null , \" * \" ) ) ; private NodeTest nodeTest ; private boolean setStarted = false ; super . setPosition ( getCurrentPosition ( ) + 1 ) ; if ( ! setStarted ) { setStarted = true ; NodeNameTest nodeNameTest = null ; if ( nodeTest instanceof NodeTypeTest ) { if ( ( ( NodeTypeTest ) nodeTest ) . getNodeType ( ) = = Compiler . NODE_TYPE_NODE ) { nodeNameTest = WILDCARD_TEST ; } } else if ( nodeTest instanceof NodeNameTest ) { nodeNameTest = ( NodeNameTest ) nodeTest ; } if ( nodeNameTest = = null ) { return false ; } iterator = parentContext . getCurrentNodePointer ( ) . attributeIterator ( nodeNameTest . getNodeName ( ) ) ; } if ( iterator = = null ) { return false ; currentNodePointer = iterator . getNodePointer ( ) ; return true ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_18"}
{"buggy_code": "int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { String nm = n . getNodeName ( ) ; if ( nm . equals ( node . getNodeName ( ) ) ) { count + + ; } } n = n . getPreviousSibling ( ) ; } return count ; }", "fixed_code": "int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE & & matchesQName ( n ) ) { count + + ; } n = n . getPreviousSibling ( ) ; } return count ; } private boolean matchesQName ( Node n ) { if ( getNamespaceURI ( ) ! = null ) { return equalStrings ( getNamespaceURI ( n ) , getNamespaceURI ( ) ) & & equalStrings ( node . getLocalName ( ) , n . getLocalName ( ) ) ; } return equalStrings ( node . getNodeName ( ) , n . getNodeName ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_19"}
{"buggy_code": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { * @ param value to look for * @ return whether a match was found", "fixed_code": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( left , ( Iterator ) right ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { * @ param value to look for * @ return whether a match was found private boolean containsMatch ( Object value , Iterator it ) { while ( it . hasNext ( ) ) { Object element = it . next ( ) ; if ( compute ( value , element ) ) { return true ; } } return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_20"}
{"buggy_code": "* @ return int length public int getLength ( ) { return ValueUtils . getLength ( getBaseValue ( ) ) ; }", "fixed_code": "* @ return int length public int getLength ( ) { Object baseValue = getBaseValue ( ) ; return baseValue = = null ? 1 : ValueUtils . getLength ( baseValue ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_21"}
{"buggy_code": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { return attr . getValue ( ) ; } } aNode = aNode . getParentNode ( ) ; } return null ; } return uri ; } public Object getValue ( ) {", "fixed_code": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { uri = attr . getValue ( ) ; break ; } } aNode = aNode . getParentNode ( ) ; } } return \" \" . equals ( uri ) ? null : uri ; } public Object getValue ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_22"}
{"buggy_code": "package org . apache . commons . jxpath . ri . model . beans ; import org . apache . commons . jxpath . JXPathContext ; import org . apache . commons . jxpath . JXPathInvalidAccessException ; import org . apache . commons . jxpath . ri . QName ; return newParent . createAttribute ( context , getName ( ) ) ; } else { / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return pointer ; } else { if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; } return string ; } \\ No newline at end of file }", "fixed_code": "package org . apache . commons . jxpath . ri . model . beans ; import org . apache . commons . jxpath . AbstractFactory ; import org . apache . commons . jxpath . JXPathAbstractFactoryException ; import org . apache . commons . jxpath . JXPathContext ; import org . apache . commons . jxpath . JXPathInvalidAccessException ; import org . apache . commons . jxpath . ri . QName ; return newParent . createAttribute ( context , getName ( ) ) ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return pointer ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; } return string ; }  private JXPathAbstractFactoryException createBadFactoryException ( AbstractFactory factory ) { return new JXPathAbstractFactoryException ( \" Factory \" + factory + \" reported success creating object for path : \" + asPath ( ) + \" but object was null . Terminating to avoid stack recursion . \" ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_3"}
{"buggy_code": ": current . toUpperCase ( ) . startsWith ( lang . toUpperCase ( ) ) ; } protected String getLanguage ( ) { Node n = node ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element e = ( Element ) n ; String attr = e . getAttribute ( \" xml : lang \" ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } return null ; }", "fixed_code": ": current . toUpperCase ( ) . startsWith ( lang . toUpperCase ( ) ) ; } protected static String findEnclosingAttribute ( Node n , String attrName ) { while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element e = ( Element ) n ; String attr = e . getAttribute ( attrName ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } return null ; } protected String getLanguage ( ) { return findEnclosingAttribute ( node , \" xml : lang \" ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_4"}
{"buggy_code": "} if ( depth1 = = 1 ) { throw new JXPathException ( \" Cannot compare pointers that do not belong to the same tree : ' \" + p1 + \" ' and ' \" + p2 + \" ' \" ) ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "fixed_code": "} if ( depth1 = = 1 ) { return 0 ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_5"}
{"buggy_code": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext | | l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext | | r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "fixed_code": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext ) { ( ( EvalContext ) l ) . reset ( ) ; }  if ( l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext ) { ( ( EvalContext ) r ) . reset ( ) ; }  if ( r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_6"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ; package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ; package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ; package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ; package org . apache . commons . jxpath . ri . compiler ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ; package org . apache . commons . jxpath . ri . compiler ; package org . apache . commons . jxpath . ri . compiler ; package org . apache . commons . jxpath . ri . compiler ; package org . apache . commons . jxpath . ri . compiler ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ;  import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ; import org . apache . commons . jxpath . ri . axes . InitialContext ; import org . apache . commons . jxpath . ri . axes . SelfContext ; ", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_7"}
{"buggy_code": "return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; double rd = InfoSetUtil . doubleValue ( right ) ; return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; }", "fixed_code": "return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( right ) ; if ( Double . isNaN ( rd ) ) { return false ; } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_8"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; if ( result instanceof EvalContext ) { return new ValueIterator ( ( EvalContext ) result ) ; } return ValueUtils . iterate ( result ) ; } if ( result instanceof EvalContext ) { return ( EvalContext ) result ; } return new PointerIterator ( ValueUtils . iterate ( result ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; throw new UnsupportedOperationException ( ) ; } } \\ No newline at end of file }", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . NodeSet ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; if ( result instanceof EvalContext ) { return new ValueIterator ( ( EvalContext ) result ) ; } if ( result instanceof NodeSet ) { return new ValueIterator ( ( ( NodeSet ) result ) . getPointers ( ) . iterator ( ) ) ; } return ValueUtils . iterate ( result ) ; } if ( result instanceof EvalContext ) { return ( EvalContext ) result ; } if ( result instanceof NodeSet ) { return new PointerIterator ( ( ( NodeSet ) result ) . getPointers ( ) . iterator ( ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; } return new PointerIterator ( ValueUtils . iterate ( result ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; throw new UnsupportedOperationException ( ) ; } } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "JxPath_9"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public abstract class CoreOperationCompare extends CoreOperation { public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { super ( new Expression [ ] { arg1 , arg2 } ) ; } protected int getPrecedence ( ) { } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer & & r instanceof Pointer ) { if ( l . equals ( r ) ) { return true ; } } if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } if ( l = = r ) { return true ; } if ( l instanceof Boolean | | r instanceof Boolean ) { return ( InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ) ; } if ( l instanceof Number | | r instanceof Number ) { return ( InfoSetUtil . doubleValue ( l ) = = InfoSetUtil . doubleValue ( r ) ) ; } if ( l instanceof String | | r instanceof String ) { return ( InfoSetUtil . stringValue ( l ) . equals ( InfoSetUtil . stringValue ( r ) ) ) ; } return l ! = null & & l . equals ( r ) ; } } package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ;", "fixed_code": "* @ version $ Revision $ $ Date $ public abstract class CoreOperationCompare extends CoreOperation { private boolean invert ; public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { this ( arg1 , arg2 , false ) ; }  protected CoreOperationCompare ( Expression arg1 , Expression arg2 , boolean invert ) { super ( new Expression [ ] { arg1 , arg2 } ) ; this . invert = invert ; }  public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } protected int getPrecedence ( ) { } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } boolean result ; if ( l instanceof Boolean | | r instanceof Boolean ) { result = l = = r | | InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ; } else if ( l instanceof Number | | r instanceof Number ) { double ld = InfoSetUtil . doubleValue ( l ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( r ) ; if ( Double . isNaN ( rd ) ) { return false ; } result = ld = = rd ; } else { if ( l instanceof String | | r instanceof String ) { l = InfoSetUtil . stringValue ( l ) ; r = InfoSetUtil . stringValue ( r ) ; } result = l = = r | | l ! = null & & l . equals ( r ) ; } return result ^ invert ; } } package org . apache . commons . jxpath . ri . compiler ; package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "JxPath_9"}
{"buggy_code": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "fixed_code": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "fixed_code": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_1"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return createLong ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_1"}
{"buggy_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "start = ' ' ; } } } else { if ( end < = start ) { throw new IllegalArgumentException ( \" Parameter end ( \" + end + \" ) must be greater than start ( \" + start + \" ) \" ) ; } } char [ ] buffer = new char [ count ] ;", "fixed_code": "start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_11"}
{"buggy_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars ! = null & & chars . length = = 0 ) { throw new IllegalArgumentException ( \" The chars array must not be empty \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "fixed_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_12"}
{"buggy_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private static final Map < String , Class < ? > > primitiveTypes = new HashMap < String , Class < ? > > ( ) ; private ClassLoader classLoader ;", "fixed_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private ClassLoader classLoader ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "fixed_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_14"}
{"buggy_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "fixed_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_14"}
{"buggy_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; }", "fixed_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_15"}
{"buggy_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; }", "fixed_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_15"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "fixed_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "fixed_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_16"}
{"buggy_code": "return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "return ; } int pos = 0 ; int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; } else { / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { if ( pos < len - 2 ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_17"}
{"buggy_code": "return ; } int pos = 0 ; int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; } else { / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { if ( pos < len - 2 ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } }", "fixed_code": "return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_17"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_18"}
{"buggy_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "fixed_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_19"}
{"buggy_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "fixed_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_19"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . contains ( \" # \" ) ) { / / LANG - 879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final int len = str . length ( ) ; if ( len < 2 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "if ( str = = null ) { return null ; } final int len = str . length ( ) ; if ( len < 2 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_2"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_20"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . float sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw new ArithmeticException ( \" overflow : gcd is 2 ^ 31 \" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw new ArithmeticException ( \" overflow : gcd is 2 ^ 31 \" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final int HASH_SEED = 31 ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false @ Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ObjectUtils . notEqual ( getClass ( ) , obj . getClass ( ) ) ) { return false ; } ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ; if ( ObjectUtils . notEqual ( toPattern , rhs . toPattern ) ) { return false ; } if ( ObjectUtils . notEqual ( registry , rhs . registry ) ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( registry ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( toPattern ) ; return result ; }", "fixed_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_23"}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp & & ! hasDecPoint ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp & & ! hasDecPoint ; } / / last character is illegal return false ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_24"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_24"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_26"}
{"buggy_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos | | expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos | | expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "return 0 ; } if ( entityValue > 0xFFFF ) { char [ ] chrs = Character . toChars ( entityValue ) ; out . write ( chrs [ 0 ] ) ; out . write ( chrs [ 1 ] ) ; } else { out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "fixed_code": "return 0 ; } out . write ( entityValue ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_28"}
{"buggy_code": "* @ param option the Option associated with the values * @ return a list of values or an empty List if none are found", "fixed_code": "* @ param option the Option associated with the values * @ return a list of values or an empty List if none are found List getUndefaultedValues ( final Option option ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_28"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_29"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_29"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String s ) { return Float . parseFloat ( s ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_29"}
{"buggy_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { if ( numDecimals < = 7 ) { / / If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { if ( numDecimals < = 16 ) { / / If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "fixed_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_3"}
{"buggy_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return i ; } } else { return i ; } } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return true ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { continue outer ; } } else { continue outer ; } } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; boolean chFound = searchChars . indexOf ( ch ) > = 0 ; if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { char ch2 = str . charAt ( i + 1 ) ; if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return false ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return false ; } } else { / / ch is in the Basic Multilingual Plane return false ; } } } }", "fixed_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character return i ; } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / missing low surrogate , fine , like String . indexOf ( String ) if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { continue outer ; } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; if ( searchChars . indexOf ( ch ) < 0 ) { return i ; } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / missing low surrogate , fine , like String . indexOf ( String ) / / ch is in the Basic Multilingual Plane return false ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_30"}
{"buggy_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character return i ; } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / missing low surrogate , fine , like String . indexOf ( String ) if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { continue outer ; } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; if ( searchChars . indexOf ( ch ) < 0 ) { return i ; } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / missing low surrogate , fine , like String . indexOf ( String ) / / ch is in the Basic Multilingual Plane return false ; } } }", "fixed_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return i ; } } else { return i ; } } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return true ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { continue outer ; } } else { continue outer ; } } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; boolean chFound = searchChars . indexOf ( ch ) > = 0 ; if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { char ch2 = str . charAt ( i + 1 ) ; if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return false ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return false ; } } else { / / ch is in the Basic Multilingual Plane return false ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_30"}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLastIndex = csLength - 1 ; int searchLastIndex = searchLength - 1 ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { / / ch is in the Basic Multilingual Plane return true ; } } } }", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character / / ch is in the Basic Multilingual Plane return true ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_31"}
{"buggy_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } }", "fixed_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) { @ Override protected Set < IDKey > initialValue ( ) { return new HashSet < IDKey > ( ) ; } } ; static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_32"}
{"buggy_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) { @ Override protected Set < IDKey > initialValue ( ) { return new HashSet < IDKey > ( ) ; } } ; static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; }", "fixed_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_32"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m ! = null & & m . containsKey ( value ) ; }", "fixed_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m . containsKey ( value ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_34"}
{"buggy_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m . containsKey ( value ) ; }", "fixed_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m ! = null & & m . containsKey ( value ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_34"}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Arguments cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Array and element cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Arguments cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Array and element cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_35"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_35"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "fixed_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_36"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "fixed_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_36"}
{"buggy_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; try { System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; } catch ( ArrayStoreException ase ) { / / Check if problem is incompatible types final Class < ? > type2 = array2 . getClass ( ) . getComponentType ( ) ; if ( ! type1 . isAssignableFrom ( type2 ) ) { throw new IllegalArgumentException ( \" Cannot store \" + type2 . getName ( ) + \" in an array of \" + type1 . getName ( ) ) ; } throw ase ; / / No , so rethrow original } return joinedArray ; }", "fixed_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; / / Check if problem is incompatible types return joinedArray ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_37"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_39"}
{"buggy_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < String , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "fixed_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < CharSequence , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_4"}
{"buggy_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < CharSequence , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "fixed_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < String , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_4"}
{"buggy_code": "if ( str = = null | | searchStr = = null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = 0 ; i < = max ; i + + ) { if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { return true ; } } return false ; } / / IndexOfAny chars", "fixed_code": "if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_40"}
{"buggy_code": "if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "fixed_code": "if ( str = = null | | searchStr = = null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = 0 ; i < = max ; i + + ) { if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { return true ; } } return false ; } / / IndexOfAny chars", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_40"}
{"buggy_code": "* @ return true if the String contains the search String irrespective of * case or false if not or < code > null < / code > string input public static boolean containsIgnoreCase ( String str , String searchStr ) { if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "fixed_code": "* @ return true if the String contains the search String irrespective of * case or false if not or < code > null < / code > string input public static boolean containsIgnoreCase ( String name , String desc ) { if ( name . equals ( \" targetClass \" ) ) { if ( desc . equals ( \" ( ) Ljava / lang / Class ; \" ) ) { return true ; } } return false ; } / / IndexOfAny chars", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_40"}
{"buggy_code": "return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / Strip array encoding while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "fixed_code": "return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } / / Strip array encoding / / Strip Object type encoding int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } / / Strip array encoding / / Strip Object type encoding int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "fixed_code": "return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / Strip array encoding while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_41"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( rhs ! = minRatio ) { if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_41"}
{"buggy_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { int c = Character . codePointAt ( str , i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > = 0x010000 & & i < len - 1 ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ; i + + ; } else if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "fixed_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { char c = str . charAt ( i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_42"}
{"buggy_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { char c = str . charAt ( i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "fixed_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { int c = Character . codePointAt ( str , i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > = 0x010000 & & i < len - 1 ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ; i + + ; } else if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_42"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . length ( ) = = 1 & & ! Character . isDigit ( val . charAt ( 0 ) ) ) { throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "fixed_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string if ( lower > str . length ( ) ) { lower = str . length ( ) ; } / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "fixed_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "fixed_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "fixed_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_46"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_46"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal ) { isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; } else { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "fixed_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_48"}
{"buggy_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { if ( numerator = = 0 ) { return equals ( ZERO ) ? this : ZERO ; } int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "fixed_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_49"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; if ( ch0 = = ' _ ' ) { if ( len < 3 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ! Character . isUpperCase ( ch1 ) | | ! Character . isUpperCase ( ch2 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( len = = 3 ) { return new Locale ( \" \" , str . substring ( 1 , 3 ) ) ; } if ( len < 5 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( str . charAt ( 3 ) ! = ' _ ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( \" \" , str . substring ( 1 , 3 ) , str . substring ( 4 ) ) ; } else { final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_5"}
{"buggy_code": "key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "fixed_code": "key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "fixed_code": "key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_50"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } this . splitState = STATE_UNSPLIT ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; default : out . write ( ch ) ; break ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_52"}
{"buggy_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; } if ( field = = Calendar . SECOND ) { done = true ; } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field = = Calendar . MINUTE ) { done = true ; } / / truncate minutes", "fixed_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; if ( ch3 = = ' _ ' ) { return new Locale ( str . substring ( 0 , 2 ) , \" \" , str . substring ( 4 ) ) ; } char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_54"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_55"}
{"buggy_code": "private transient Rule [ ] mRules ; private transient int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "private Rule [ ] mRules ; private int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_56"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "xNorm = Math . sqrt ( xNorm ) ; } else { / / failed iteration , reset the previous values cost = previousCost ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "fixed_code": "xNorm = Math . sqrt ( xNorm ) ; } else { / / failed iteration , reset the previous values if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } cost = previousCost ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_58"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < this . size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < this . size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_60"}
{"buggy_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < field ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_60"}
{"buggy_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = size - strLen + 1 ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "fixed_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "fixed_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = size - strLen + 1 ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_61"}
{"buggy_code": "if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) {", "fixed_code": "if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) { first = state ; } } else { if ( state . getEventTime ( ) > first . getEventTime ( ) ) { first = state ; } } } } } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_61"}
{"buggy_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; break ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException e ) { entityValue = - 1 ; } } } else { / / escaped value content is an entity name", "fixed_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } } catch ( NumberFormatException e ) { } } } else { / / escaped value content is an entity name", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_62"}
{"buggy_code": "days - = 1 ; } while ( days < 0 ) { end . add ( Calendar . MONTH , - 1 ) ; days + = end . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; end . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static final Object y = \" y \" ; static final Object M = \" M \" ;", "fixed_code": "days - = 1 ; } while ( days < 0 ) { days + = 31 ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } milliseconds - = reduceAndCorrect ( start , end , Calendar . MILLISECOND , milliseconds ) ; seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static int reduceAndCorrect ( Calendar start , Calendar end , int field , int difference ) { end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; } } static final Object y = \" y \" ; static final Object M = \" M \" ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "days - = 1 ; } while ( days < 0 ) { days + = 31 ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } milliseconds - = reduceAndCorrect ( start , end , Calendar . MILLISECOND , milliseconds ) ; seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static int reduceAndCorrect ( Calendar start , Calendar end , int field , int difference ) { end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; } } static final Object y = \" y \" ; static final Object M = \" M \" ;", "fixed_code": "days - = 1 ; } while ( days < 0 ) { end . add ( Calendar . MONTH , - 1 ) ; days + = end . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; end . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static final Object y = \" y \" ; static final Object M = \" M \" ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_63"}
{"buggy_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { if ( other = = this ) { return 0 ; } if ( other . getClass ( ) ! = this . getClass ( ) ) { if ( other . getClass ( ) . getName ( ) . equals ( this . getClass ( ) . getName ( ) ) ) { return iValue - getValueInOtherClassLoader ( other ) ; } throw new ClassCastException ( \" Different enum class ' \" + ClassUtils . getShortClassName ( other . getClass ( ) ) + \" ' \" ) ; } return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value private int getValueInOtherClassLoader ( Object other ) { try { Method mth = other . getClass ( ) . getMethod ( \" getValue \" , null ) ; Integer value = ( Integer ) mth . invoke ( other , null ) ; return value . intValue ( ) ; } catch ( NoSuchMethodException e ) { / / ignore - should never happen } catch ( IllegalAccessException e ) { / / ignore - should never happen } catch ( InvocationTargetException e ) { / / ignore - should never happen } throw new IllegalStateException ( \" This should not happen \" ) ; }", "fixed_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value / / ignore - should never happen / / ignore - should never happen / / ignore - should never happen", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_64"}
{"buggy_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } if ( field = = Calendar . MILLISECOND ) { return ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . Date date = val . getTime ( ) ; long time = date . getTime ( ) ; boolean done = false ; / / truncate milliseconds int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done & & ( ! round | | minutes < 30 ) ) { time = time - ( minutes * 60000L ) ; } / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field if ( offset ! = 0 ) { val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "fixed_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . / / truncate milliseconds / / truncate seconds / / truncate minutes / / reset time / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_65"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { TimeZone zone = calendar . getTimeZone ( ) ; if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "fixed_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final TimeZone zone ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; zone = timeZone ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_8"}
{"buggy_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( patternMatcher . regionStart ( ) ! = patternMatcher . regionEnd ( ) ) { throw new IllegalArgumentException ( \" Failed to parse \\ \" \" + pattern + \" \\ \" ; gave up at index \" + patternMatcher . regionStart ( ) ) ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "fixed_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Lang_9"}
{"buggy_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; } if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; } if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_1"}
{"buggy_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; } if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; } if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_1"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_1"}
{"buggy_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; }", "fixed_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_10"}
{"buggy_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getUnboundParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getUnboundParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "fixed_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getAllParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getAllParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_100"}
{"buggy_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getAllParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getAllParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "fixed_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getUnboundParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getUnboundParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_100"}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( startIndex > = source . length ( ) ) | | ( endIndex > source . length ( ) ) | | source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_101"}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( startIndex > = source . length ( ) ) | | ( endIndex > source . length ( ) ) | | source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_101"}
{"buggy_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumExpected = 0d ; double sumObserved = 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { sumExpected + = expected [ i ] ; sumObserved + = observed [ i ] ; } double ratio = 1 . 0d ; boolean rescale = false ; if ( Math . abs ( sumExpected - sumObserved ) > 10E - 6 ) { ratio = sumObserved / sumExpected ; rescale = true ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { if ( rescale ) { dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; sumSq + = dev * dev / ( ratio * expected [ i ] ) ; } else { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } } return sumSq ; }", "fixed_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } return sumSq ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_102"}
{"buggy_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 . 0d ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 . 0d ; } else { throw ex ; } } }", "fixed_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 15 ; private static double [ ] lanczos =", "fixed_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 9 ; private static double [ ] lanczos =", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 9 ; private static double [ ] lanczos =", "fixed_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 15 ; private static double [ ] lanczos =", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_104"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_104"}
{"buggy_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; }", "fixed_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; }", "fixed_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_105"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_105"}
{"buggy_code": "return null ; } if ( num . intValue ( ) < 0 ) { / / minus signs should be leading , invalid expression pos . setIndex ( initialIndex ) ; return null ; } / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } if ( den . intValue ( ) < 0 ) { / / minus signs must be leading , invalid pos . setIndex ( initialIndex ) ; return null ; } int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "fixed_code": "return null ; } / / minus signs should be leading , invalid expression / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } / / minus signs must be leading , invalid int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_106"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_11"}
{"buggy_code": "package org . apache . commons . math3 . random ; import java . io . Serializable ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator , Serializable { private static final long serialVersionUID = 20130104L ; private double nextGaussian ;", "fixed_code": "package org . apache . commons . math3 . random ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator { private double nextGaussian ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_12"}
{"buggy_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "fixed_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_13"}
{"buggy_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = new DiagonalMatrix ( weight ) ; } private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "fixed_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; for ( int i = 0 ; i < dim ; i + + ) { weightMatrix . setEntry ( i , i , weight [ i ] ) ; } } private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_14"}
{"buggy_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double TWO_POWER_53 = 2 * TWO_POWER_52 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { return pow ( - x , y ) ; }", "fixed_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double TWO_POWER_53 = 2 * TWO_POWER_52 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_15"}
{"buggy_code": "public class FastMath { private static final double LOG_MAX_VALUE = StrictMath . log ( Double . MAX_VALUE ) ; public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) {", "fixed_code": "public class FastMath { public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( - x ) ; } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_16"}
{"buggy_code": "public class FastMath { public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( - x ) ; } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) {", "fixed_code": "public class FastMath { private static final double LOG_MAX_VALUE = StrictMath . log ( Double . MAX_VALUE ) ; public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_16"}
{"buggy_code": "* @ param x number on which evaluation is done * @ return hyperbolic cosine of x public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; }", "fixed_code": "* @ param x number on which evaluation is done * @ return hyperbolic cosine of x public static double cosh ( double d1 ) { return d1 * d1 * d1 * ( d1 * ( d1 * 6D - 15D ) + 10D ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_16"}
{"buggy_code": "* @ return product of this and x public Dfp multiply ( final int x ) { if ( x > = 0 & & x < RADIX ) { return multiplyFast ( x ) ; } else { return multiply ( newInstance ( x ) ) ; } }", "fixed_code": "* @ return product of this and x public Dfp multiply ( final int x ) { return multiplyFast ( x ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_17"}
{"buggy_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = x [ i ] / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; } return true ; } final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < bLoEnc [ i ] ) { return false ; } if ( x [ i ] > bHiEnc [ i ] ) { return false ; } }", "fixed_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; } return true ; } for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < 0 ) { return false ; } if ( x [ i ] > 1 . 0 ) { return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; } return true ; } for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < 0 ) { return false ; } if ( x [ i ] > 1 . 0 ) { return false ; } }", "fixed_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = x [ i ] / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; } return true ; } final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < bLoEnc [ i ] ) { return false ; } if ( x [ i ] > bHiEnc [ i ] ) { return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_18"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_18"}
{"buggy_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "fixed_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_19"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "* { @ inheritDoc } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; * @ return the total size of the unidimensional counter . public int getSize ( ) { return totalSize ; }", "fixed_code": "* { @ inheritDoc } public boolean hasNext ( ) { for ( int i = last ; i > = 0 ; i - - ) { if ( counter [ i ] = = size [ i ] - 1 ) { counter [ i ] = 0 ; } else { + + counter [ i ] ; break ; } } return false ; * @ return the total size of the unidimensional counter . public int getSize ( ) { return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_2"}
{"buggy_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return boundaries ! = null & & isRepairMode ? decode ( repair ( x ) ) : decode ( x ) ; }", "fixed_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return decode ( x ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return decode ( x ) ; }", "fixed_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return boundaries ! = null & & isRepairMode ? decode ( repair ( x ) ) : decode ( x ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_20"}
{"buggy_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element int swapR = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isr = index [ swapR ] ; if ( c [ ii ] [ ii ] > c [ isr ] [ isr ] ) { swapR = i ; } } / / swap elements if ( swapR ! = r ) { final int tmpIndex = index [ r ] ; index [ r ] = index [ swapR ] ; index [ swapR ] = tmpIndex ; final double [ ] tmpRow = b [ r ] ; b [ r ] = b [ swapR ] ; b [ swapR ] = tmpRow ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; final double inverse2 = 1 / c [ ir ] [ ir ] ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = c [ ii ] [ ir ] * c [ ii ] [ ir ] * inverse2 ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "fixed_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] swap = new int [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element swap [ r ] = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isi = index [ swap [ i ] ] ; if ( c [ ii ] [ ii ] > c [ isi ] [ isi ] ) { swap [ r ] = i ; } } / / swap elements if ( swap [ r ] ! = r ) { int tmp = index [ r ] ; index [ r ] = index [ swap [ r ] ] ; index [ swap [ r ] ] = tmp ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = e * e ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_21"}
{"buggy_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] swap = new int [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element swap [ r ] = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isi = index [ swap [ i ] ] ; if ( c [ ii ] [ ii ] > c [ isi ] [ isi ] ) { swap [ r ] = i ; } } / / swap elements if ( swap [ r ] ! = r ) { int tmp = index [ r ] ; index [ r ] = index [ swap [ r ] ] ; index [ swap [ r ] ] = tmp ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = e * e ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "fixed_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element int swapR = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isr = index [ swapR ] ; if ( c [ ii ] [ ii ] > c [ isr ] [ isr ] ) { swapR = i ; } } / / swap elements if ( swapR ! = r ) { final int tmpIndex = index [ r ] ; index [ r ] = index [ swapR ] ; index [ swapR ] = tmpIndex ; final double [ ] tmpRow = b [ r ] ; b [ r ] = b [ swapR ] ; b [ swapR ] = tmpRow ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; final double inverse2 = 1 / c [ ir ] [ ir ] ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = c [ ii ] [ ir ] * c [ ii ] [ ir ] * inverse2 ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_21"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; } public boolean isSupportUpperBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; } public boolean isSupportUpperBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; } public boolean isSupportUpperBoundInclusive ( ) { return false ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; } public boolean isSupportUpperBoundInclusive ( ) { return true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_22"}
{"buggy_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; }", "fixed_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_23"}
{"buggy_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; }", "fixed_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; } + iter ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_23"}
{"buggy_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } }", "fixed_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return current ; } + iter ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return current ; } }", "fixed_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_24"}
{"buggy_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { if ( c2 = = 0 ) { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . throw new MathIllegalStateException ( LocalizedFormats . ZERO_DENOMINATOR ) ; } a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "fixed_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_26"}
{"buggy_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_26"}
{"buggy_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return 100 * doubleValue ( ) ; }", "fixed_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_27"}
{"buggy_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; }", "fixed_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return 100 * doubleValue ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_27"}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis if ( tableau . getNumArtificialVariables ( ) > 0 ) { for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; } return res ; } * * These special cases are handled below . if ( v . isNaN ( ) | | v . isInfinite ( ) ) { final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { final double y = v . getEntry ( i ) ; if ( Double . isNaN ( y ) ) { res . setEntry ( i , Double . NaN ) ; } else if ( Double . isInfinite ( y ) ) { final double x = this . getEntry ( i ) ; res . setEntry ( i , x * y ) ; } } } return res ; }", "fixed_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; } return res ; } * * These special cases are handled below . return res ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; } return res ; } * * These special cases are handled below . return res ; }", "fixed_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; } return res ; } * * These special cases are handled below . if ( v . isNaN ( ) | | v . isInfinite ( ) ) { final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { final double y = v . getEntry ( i ) ; if ( Double . isNaN ( y ) ) { res . setEntry ( i , Double . NaN ) ; } else if ( Double . isInfinite ( y ) ) { final double x = this . getEntry ( i ) ; res . setEntry ( i , x * y ) ; } } } return res ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_29"}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( minRatio , 0 . 0 ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_29"}
{"buggy_code": "throw new DimensionMismatchException ( len , b . length ) ; } if ( len = = 1 ) { / / Revert to scalar multiplication . return a [ 0 ] * b [ 0 ] ; } final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "fixed_code": "throw new DimensionMismatchException ( len , b . length ) ; } / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_3"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "int n = 1 ; double dPrev = 0 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double dN = a + b * dPrev ; if ( Precision . equals ( dN , 0 . 0 , small ) ) { dN = small ; } double cN = a + b / cPrev ; if ( Precision . equals ( cN , 0 . 0 , small ) ) { cN = small ; } dN = 1 / dN ; final double deltaN = cN * dN ; hN = hPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = dN ; cPrev = cN ; hPrev = hN ; n + + ; }", "fixed_code": "int n = 1 ; double dPrev = 0 . 0 ; double p0 = 1 . 0 ; double q1 = 1 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double cN = a * hPrev + b * p0 ; double q2 = a * q1 + b * dPrev ; if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { double scaleFactor = 1d ; double lastScaleFactor = 1d ; final int maxPower = 5 ; final double scale = FastMath . max ( a , b ) ; if ( scale < = 0 ) { / / Can ' t scale throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; } for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; } else if ( b ! = 0 ) { cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; } if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { break ; } } } final double deltaN = cN / q2 / cPrev ; hN = cPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = q1 ; cPrev = cN / q2 ; p0 = hPrev ; hPrev = cN ; q1 = q2 ; n + + ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "int n = 1 ; double dPrev = 0 . 0 ; double p0 = 1 . 0 ; double q1 = 1 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double cN = a * hPrev + b * p0 ; double q2 = a * q1 + b * dPrev ; if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { double scaleFactor = 1d ; double lastScaleFactor = 1d ; final int maxPower = 5 ; final double scale = FastMath . max ( a , b ) ; if ( scale < = 0 ) { / / Can ' t scale throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; } for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; } else if ( b ! = 0 ) { cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; } if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { break ; } } } final double deltaN = cN / q2 / cPrev ; hN = cPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = q1 ; cPrev = cN / q2 ; p0 = hPrev ; hPrev = cN ; q1 = q2 ; n + + ; }", "fixed_code": "int n = 1 ; double dPrev = 0 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double dN = a + b * dPrev ; if ( Precision . equals ( dN , 0 . 0 , small ) ) { dN = small ; } double cN = a + b / cPrev ; if ( Precision . equals ( cN , 0 . 0 , small ) ) { cN = small ; } dN = 1 / dN ; final double deltaN = cN * dN ; hN = hPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = dN ; cPrev = cN ; hPrev = hN ; n + + ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_31"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_33"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_34"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_35"}
{"buggy_code": "{ \" \\ u00C7 \" , \" & Ccedil ; \" } , / / \ufffd - uppercase C , cedilla { \" \\ u00C8 \" , \" & Egrave ; \" } , / / \ufffd - uppercase E , grave accent { \" \\ u00C9 \" , \" & Eacute ; \" } , / / \ufffd - uppercase E , acute accent { \" \\ u00CB \" , \" & Ecirc ; \" } , / / \ufffd - uppercase E , circumflex accent { \" \\ u00CC \" , \" & Euml ; \" } , / / \ufffd - uppercase E , umlaut { \" \\ u00CD \" , \" & Igrave ; \" } , / / \ufffd - uppercase I , grave accent { \" \\ u00CE \" , \" & Iacute ; \" } , / / \ufffd - uppercase I , acute accent { \" \\ u00CF \" , \" & Icirc ; \" } , / / \ufffd - uppercase I , circumflex accent { \" \\ u00D0 \" , \" & Iuml ; \" } , / / \ufffd - uppercase I , umlaut { \" \\ u00D1 \" , \" & ETH ; \" } , / / \ufffd - uppercase Eth , Icelandic { \" \\ u00D2 \" , \" & Ntilde ; \" } , / / \ufffd - uppercase N , tilde { \" \\ u00D3 \" , \" & Ograve ; \" } , / / \ufffd - uppercase O , grave accent { \" \\ u00D4 \" , \" & Oacute ; \" } , / / \ufffd - uppercase O , acute accent { \" \\ u00D5 \" , \" & Ocirc ; \" } , / / \ufffd - uppercase O , circumflex accent { \" \\ u00D6 \" , \" & Otilde ; \" } , / / \ufffd - uppercase O , tilde { \" \\ u00D7 \" , \" & Ouml ; \" } , / / \ufffd - uppercase O , umlaut { \" \\ u00D8 \" , \" & times ; \" } , / / multiplication sign { \" \\ u00D9 \" , \" & Oslash ; \" } , / / \ufffd - uppercase O , slash { \" \\ u00DA \" , \" & Ugrave ; \" } , / / \ufffd - uppercase U , grave accent { \" \\ u00DB \" , \" & Uacute ; \" } , / / \ufffd - uppercase U , acute accent { \" \\ u00DC \" , \" & Ucirc ; \" } , / / \ufffd - uppercase U , circumflex accent { \" \\ u00DD \" , \" & Uuml ; \" } , / / \ufffd - uppercase U , umlaut { \" \\ u00DE \" , \" & Yacute ; \" } , / / \ufffd - uppercase Y , acute accent { \" \\ u00DF \" , \" & THORN ; \" } , / / \ufffd - uppercase THORN , Icelandic { \" \\ u00E0 \" , \" & szlig ; \" } , / / \ufffd - lowercase sharps , German { \" \\ u00E1 \" , \" & agrave ; \" } , / / \ufffd - lowercase a , grave accent { \" \\ u00E2 \" , \" & aacute ; \" } , / / \ufffd - lowercase a , acute accent { \" \\ u00E3 \" , \" & acirc ; \" } , / / \ufffd - lowercase a , circumflex accent { \" \\ u00E4 \" , \" & atilde ; \" } , / / \ufffd - lowercase a , tilde { \" \\ u00E5 \" , \" & auml ; \" } , / / \ufffd - lowercase a , umlaut { \" \\ u00E5 \" , \" & aring ; \" } , / / \ufffd - lowercase a , ring { \" \\ u00E6 \" , \" & aelig ; \" } , / / \ufffd - lowercase ae { \" \\ u00E7 \" , \" & ccedil ; \" } , / / \ufffd - lowercase c , cedilla", "fixed_code": "{ \" \\ u00C7 \" , \" & Ccedil ; \" } , / / \ufffd - uppercase C , cedilla { \" \\ u00C8 \" , \" & Egrave ; \" } , / / \ufffd - uppercase E , grave accent { \" \\ u00C9 \" , \" & Eacute ; \" } , / / \ufffd - uppercase E , acute accent { \" \\ u00CA \" , \" & Ecirc ; \" } , / / \ufffd - uppercase E , circumflex accent { \" \\ u00CB \" , \" & Euml ; \" } , / / \ufffd - uppercase E , umlaut { \" \\ u00CC \" , \" & Igrave ; \" } , / / \ufffd - uppercase I , grave accent { \" \\ u00CD \" , \" & Iacute ; \" } , / / \ufffd - uppercase I , acute accent { \" \\ u00CE \" , \" & Icirc ; \" } , / / \ufffd - uppercase I , circumflex accent { \" \\ u00CF \" , \" & Iuml ; \" } , / / \ufffd - uppercase I , umlaut { \" \\ u00D0 \" , \" & ETH ; \" } , / / \ufffd - uppercase Eth , Icelandic { \" \\ u00D1 \" , \" & Ntilde ; \" } , / / \ufffd - uppercase N , tilde { \" \\ u00D2 \" , \" & Ograve ; \" } , / / \ufffd - uppercase O , grave accent { \" \\ u00D3 \" , \" & Oacute ; \" } , / / \ufffd - uppercase O , acute accent { \" \\ u00D4 \" , \" & Ocirc ; \" } , / / \ufffd - uppercase O , circumflex accent { \" \\ u00D5 \" , \" & Otilde ; \" } , / / \ufffd - uppercase O , tilde { \" \\ u00D6 \" , \" & Ouml ; \" } , / / \ufffd - uppercase O , umlaut { \" \\ u00D7 \" , \" & times ; \" } , / / multiplication sign { \" \\ u00D8 \" , \" & Oslash ; \" } , / / \ufffd - uppercase O , slash { \" \\ u00D9 \" , \" & Ugrave ; \" } , / / \ufffd - uppercase U , grave accent { \" \\ u00DA \" , \" & Uacute ; \" } , / / \ufffd - uppercase U , acute accent { \" \\ u00DB \" , \" & Ucirc ; \" } , / / \ufffd - uppercase U , circumflex accent { \" \\ u00DC \" , \" & Uuml ; \" } , / / \ufffd - uppercase U , umlaut { \" \\ u00DD \" , \" & Yacute ; \" } , / / \ufffd - uppercase Y , acute accent { \" \\ u00DE \" , \" & THORN ; \" } , / / \ufffd - uppercase THORN , Icelandic { \" \\ u00DF \" , \" & szlig ; \" } , / / \ufffd - lowercase sharps , German { \" \\ u00E0 \" , \" & agrave ; \" } , / / \ufffd - lowercase a , grave accent { \" \\ u00E1 \" , \" & aacute ; \" } , / / \ufffd - lowercase a , acute accent { \" \\ u00E2 \" , \" & acirc ; \" } , / / \ufffd - lowercase a , circumflex accent { \" \\ u00E3 \" , \" & atilde ; \" } , / / \ufffd - lowercase a , tilde { \" \\ u00E4 \" , \" & auml ; \" } , / / \ufffd - lowercase a , umlaut { \" \\ u00E5 \" , \" & aring ; \" } , / / \ufffd - lowercase a , ring { \" \\ u00E6 \" , \" & aelig ; \" } , / / \ufffd - lowercase ae { \" \\ u00E7 \" , \" & ccedil ; \" } , / / \ufffd - lowercase c , cedilla", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_35"}
{"buggy_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; }", "fixed_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_36"}
{"buggy_code": "/ / needs validation ? boolean validate = option . isRequired ( ) | | option instanceof Group ; if ( validate ) { option . validate ( commandLine ) ; } / / if the child option is present then validate it if ( commandLine . hasOption ( option ) ) { break ; } option . validate ( commandLine ) ; } }", "fixed_code": "/ / needs validation ? boolean validate = option . isRequired ( ) | | option instanceof Group ; / / if the child option is present then validate it if ( commandLine . hasOption ( option ) ) { break ; } validate = true ; } if ( validate ) { option . validate ( commandLine ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_36"}
{"buggy_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN | | Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20 . 0 ) { return createComplex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < - 20 . 0 ) { return createComplex ( 0 . 0 , - 1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN | | Double . isInfinite ( imaginary ) ) { return NaN ; } if ( real > 20 . 0 ) { return createComplex ( 1 . 0 , 0 . 0 ) ; } if ( real < - 20 . 0 ) { return createComplex ( - 1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "fixed_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_37"}
{"buggy_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "fixed_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN | | Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20 . 0 ) { return createComplex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < - 20 . 0 ) { return createComplex ( 0 . 0 , - 1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN | | Double . isInfinite ( imaginary ) ) { return NaN ; } if ( real > 20 . 0 ) { return createComplex ( 1 . 0 , 0 . 0 ) ; } if ( real < - 20 . 0 ) { return createComplex ( - 1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_37"}
{"buggy_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int iptMinus1 = ipt - 1 ; final int jptMinus1 = jpt - 1 ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "fixed_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new PathIsExploredException ( ) ; / / XXX } final int iptMinus1 = ipt ; final int jptMinus1 = jpt ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; throw new PathIsExploredException ( ) ; / / XXX } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_38"}
{"buggy_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new PathIsExploredException ( ) ; / / XXX } final int iptMinus1 = ipt ; final int jptMinus1 = jpt ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; throw new PathIsExploredException ( ) ; / / XXX } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "fixed_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int iptMinus1 = ipt - 1 ; final int jptMinus1 = jpt - 1 ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_38"}
{"buggy_code": "} stepSize = hNew ; if ( forward ) { if ( stepStart + stepSize > = t ) { stepSize = t - stepStart ; } } else { if ( stepStart + stepSize < = t ) { stepSize = t - stepStart ; } } / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "fixed_code": "} stepSize = hNew ; / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_41"}
{"buggy_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "fixed_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "fixed_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_42"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( meanImpl ! = mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl ! = variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl ! = geoMean ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( meanImpl ! = mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl ! = variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl ! = geoMean ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_43"}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_43"}
{"buggy_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "fixed_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; resetOccurred = false ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "fixed_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_44"}
{"buggy_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; long lRow = ( long ) rowDimension ; long lCol = ( long ) columnDimension ; if ( lRow * lCol > = ( long ) Integer . MAX_VALUE ) { throw new NumberIsTooLargeException ( lRow * lCol , Integer . MAX_VALUE , false ) ; } this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "fixed_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_45"}
{"buggy_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "fixed_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_46"}
{"buggy_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "fixed_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_46"}
{"buggy_code": "private final transient boolean isInfinite ; private final transient boolean isZero ;", "fixed_code": "private final transient boolean isInfinite ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_47"}
{"buggy_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "fixed_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_48"}
{"buggy_code": "private final transient boolean isInfinite ;", "fixed_code": "private final transient boolean isInfinite ; private final transient boolean isZero ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_48"}
{"buggy_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_49"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { final double delta = FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ; / / Update formula cannot make any progress : Update the / / search interval . x0 = 0 . 5 * ( x0 + x1 - delta ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . throw new MathInternalError ( ) ; } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; / / Update formula cannot make any progress : Update the / / search interval . default : / / Should never happen . } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_51"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; final double inPlaneThreshold = 0 . 001 ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_52"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; final double inPlaneThreshold = 0 . 001 ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_52"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) = = true ) { x1 = x ; } else { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_52"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign if ( ( bits & 0x8000000000000000L ) ! = 0 ) { sign = - 1 ; } return ; } Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 = = 0 ) { return sign < 0 ? - 0 . 0 : + 0 . 0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; }", "fixed_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign return ; } Dfp y = this ; boolean negate = false ; if ( lessThan ( getZero ( ) ) ) { y = negate ( ) ; negate = true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_54"}
{"buggy_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign return ; } Dfp y = this ; boolean negate = false ; if ( lessThan ( getZero ( ) ) ) { y = negate ( ) ; negate = true ; }", "fixed_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign if ( ( bits & 0x8000000000000000L ) ! = 0 ) { sign = - 1 ; } return ; } Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 = = 0 ) { return sign < 0 ? - 0 . 0 : + 0 . 0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_54"}
{"buggy_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; }", "fixed_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_55"}
{"buggy_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; }", "fixed_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_55"}
{"buggy_code": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "fixed_code": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "fixed_code": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_56"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_58"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_59"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; } }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { lmPar = FastMath . max ( parl , lmPar + correction ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_59"}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_6"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_6"}
{"buggy_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; }", "fixed_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } }", "fixed_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_60"}
{"buggy_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_61"}
{"buggy_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , 0 ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , 0 ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_62"}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_62"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_63"}
{"buggy_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_64"}
{"buggy_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_64"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_64"}
{"buggy_code": "* @ return RMS value public double getRMS ( ) { return Math . sqrt ( getChiSquare ( ) / rows ) ; }", "fixed_code": "* @ return RMS value public double getRMS ( ) { double criterion = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residualsWeights [ i ] ; } return Math . sqrt ( criterion / rows ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "* @ return RMS value public double getRMS ( ) { double criterion = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residualsWeights [ i ] ; } return Math . sqrt ( criterion / rows ) ; }", "fixed_code": "* @ return RMS value public double getRMS ( ) { return Math . sqrt ( getChiSquare ( ) / rows ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_65"}
{"buggy_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( 1000 ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1e - 11 ) ; setRelativeAccuracy ( 1e - 9 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , getMin ( ) , getStartValue ( ) , getMax ( ) , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } private double localMin ( boolean isMinim , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; while ( true ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } } } } else { / / termination setFunctionValue ( isMinim ? fx : - fx ) ; return x ; } incrementIterationsCounter ( ) ; } } }", "fixed_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( Integer . MAX_VALUE ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1E - 10 ) ; setRelativeAccuracy ( 1 . 0e - 14 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { throw new UnsupportedOperationException ( ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { clearResult ( ) ; return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , f , goalType , min , startValue , max , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; } private double localMin ( boolean isMinim , UnivariateRealFunction f , GoalType goalType , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( f , x ) ; if ( goalType = = GoalType . MAXIMIZE ) { fx = - fx ; } double fv = fx ; double fw = fx ; int count = 0 ; while ( count < maximalIterationCount ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( f , u ) ; if ( goalType = = GoalType . MAXIMIZE ) { fu = - fu ; } } } } else { / / termination setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new MaxIterationsExceededException ( maximalIterationCount ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_66"}
{"buggy_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( Integer . MAX_VALUE ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1E - 10 ) ; setRelativeAccuracy ( 1 . 0e - 14 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { throw new UnsupportedOperationException ( ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { clearResult ( ) ; return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , f , goalType , min , startValue , max , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; } private double localMin ( boolean isMinim , UnivariateRealFunction f , GoalType goalType , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( f , x ) ; if ( goalType = = GoalType . MAXIMIZE ) { fx = - fx ; } double fv = fx ; double fw = fx ; int count = 0 ; while ( count < maximalIterationCount ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( f , u ) ; if ( goalType = = GoalType . MAXIMIZE ) { fu = - fu ; } } } } else { / / termination setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new MaxIterationsExceededException ( maximalIterationCount ) ; } }", "fixed_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( 1000 ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1e - 11 ) ; setRelativeAccuracy ( 1e - 9 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , getMin ( ) , getStartValue ( ) , getMax ( ) , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } private double localMin ( boolean isMinim , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; while ( true ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } } } } else { / / termination setFunctionValue ( isMinim ? fx : - fx ) ; return x ; } incrementIterationsCounter ( ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_66"}
{"buggy_code": "public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } public double getResult ( ) { return optima [ 0 ] ; }", "fixed_code": "public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } public double getResult ( ) { return optimizer . getResult ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_67"}
{"buggy_code": "public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } public double getResult ( ) { return optimizer . getResult ( ) ; }", "fixed_code": "public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } public double getResult ( ) { return optima [ 0 ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_67"}
{"buggy_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setConvergenceChecker ( null ) ; setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix VectorialPointValuePair previous = current ; updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } else { / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return new VectorialPointValuePair ( point , objective ) ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_68"}
{"buggy_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return new VectorialPointValuePair ( point , objective ) ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setConvergenceChecker ( null ) ; setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix VectorialPointValuePair previous = current ; updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } else { / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_68"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { buffer = new char [ str . length ( ) + CAPACITY ] ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_68"}
{"buggy_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "fixed_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "fixed_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_69"}
{"buggy_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_69"}
{"buggy_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventY ) ; isLastStep = isLastStep | | state . stop ( ) ; } / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset | | state . reset ( eventT , eventY ) ; } if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "fixed_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time currentEvent . stepAccepted ( eventT , eventY ) ; isLastStep = currentEvent . stop ( ) ; / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } boolean needReset = currentEvent . reset ( eventT , eventY ) ; if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time currentEvent . stepAccepted ( eventT , eventY ) ; isLastStep = currentEvent . stop ( ) ; / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } boolean needReset = currentEvent . reset ( eventT , eventY ) ; if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "fixed_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventY ) ; isLastStep = isLastStep | | state . stop ( ) ; } / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset | | state . reset ( eventT , eventY ) ; } if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_7"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_7"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_70"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; }", "fixed_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_70"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | fmin = = fm ) { / / max and m bracket the root . min = m ; } else {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_71"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_72"}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "} if ( firstTime ) { final double [ ] scale = new double [ y0 . length ] ; if ( vecAbsoluteTolerance = = null ) { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; } } else { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; } } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "fixed_code": "} if ( firstTime ) { final double [ ] scale ; if ( vecAbsoluteTolerance = = null ) { scale = new double [ y0 . length ] ; java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; } else { scale = vecAbsoluteTolerance ; } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "} if ( firstTime ) { final double [ ] scale ; if ( vecAbsoluteTolerance = = null ) { scale = new double [ y0 . length ] ; java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; } else { scale = vecAbsoluteTolerance ; } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "fixed_code": "} if ( firstTime ) { final double [ ] scale = new double [ y0 . length ] ; if ( vecAbsoluteTolerance = = null ) { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; } } else { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; } } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_74"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , n - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < n - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , m - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < m - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "fixed_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_76"}
{"buggy_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "fixed_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , n - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < n - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , m - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < m - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_76"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_76"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_77"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_77"}
{"buggy_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step if ( ga * gb > 0 ) { / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { ta + = epsilon ; interpolator . setInterpolatedTime ( ta ) ; ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; } if ( ga * gb > 0 ) { / / this should never happen throw MathRuntimeException . createInternalError ( null ) ; } } / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "fixed_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing / / this should never happen / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_79"}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_79"}
{"buggy_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_8"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null | | isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 3 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 3 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "fixed_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = getNumObjectiveFunctions ( ) ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_83"}
{"buggy_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex return ; } / / check convergence final int iter = getIterations ( ) ; boolean converged = true ; for ( int i = 0 ; i < simplex . length ; + + i ) { converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; } if ( converged ) { return ; }", "fixed_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence return ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } }", "fixed_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } private void applyCollapses ( ) { } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "final double [ ] lI = lTData [ i ] ; / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "fixed_code": "final double [ ] lI = lTData [ i ] ; if ( lTData [ i ] [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_86"}
{"buggy_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { return null ; } } return row ;", "fixed_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "fixed_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { return null ; } } return row ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_87"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_87"}
{"buggy_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "fixed_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_88"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; }", "fixed_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_9"}
{"buggy_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; }", "fixed_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_9"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } public void addValue ( Comparable < ? > v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "fixed_code": "@ Deprecated public void addValue ( Object v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { long nOd = ( ( long ) numerator ) * object . denominator ; long dOn = ( ( long ) denominator ) * object . numerator ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "fixed_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { double nOd = doubleValue ( ) ; double dOn = object . doubleValue ( ) ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_91"}
{"buggy_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { double nOd = doubleValue ( ) ; double dOn = object . doubleValue ( ) ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "fixed_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { long nOd = ( ( long ) numerator ) * object . denominator ; long dOn = ( ( long ) denominator ) * object . numerator ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_91"}
{"buggy_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } / / Use symmetry for large k if ( k > n / 2 ) return binomialCoefficient ( n , n - k ) ; / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k long result = 1 ; if ( n < = 61 ) { / / For n < = 61 , the naive implementation cannot overflow . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { result = result * i / j ; } } else if ( n < = 66 ) { / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . long d = gcd ( i , j ) ; result = ( result / ( j / d ) ) * ( i / d ) ; } } else { / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { long d = gcd ( i , j ) ; result = mulAndCheck ( ( result / ( j / d ) ) , ( i / d ) ) ; } } return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { if ( n < k ) { throw new IllegalArgumentException ( \" must have n > = k for binomial coefficient ( n , k ) \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for binomial coefficient ( n , k ) \" ) ; } if ( ( n = = k ) | | ( k = = 0 ) ) { return 1d ; } if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } if ( k > n / 2 ) { return binomialCoefficientDouble ( n , n - k ) ; } if ( n < 67 ) { return binomialCoefficient ( n , k ) ; } double result = 1d ; for ( int i = 1 ; i < = k ; i + + ) { result * = ( double ) ( n - k + i ) / ( double ) i ; } return Math . floor ( result + 0 . 5 ) ; } if ( n < 67 ) { return Math . log ( binomialCoefficient ( n , k ) ) ; } if ( n < 1030 ) { return Math . log ( binomialCoefficientDouble ( n , k ) ) ; }", "fixed_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } long result = Math . round ( binomialCoefficientDouble ( n , k ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" result too large to represent in a long integer \" ) ; } / / Use symmetry for large k / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k / / For n < = 61 , the naive implementation cannot overflow . / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { return Math . floor ( Math . exp ( binomialCoefficientLog ( n , k ) ) + 0 . 5 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_92"}
{"buggy_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } long result = Math . round ( binomialCoefficientDouble ( n , k ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" result too large to represent in a long integer \" ) ; } / / Use symmetry for large k / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k / / For n < = 61 , the naive implementation cannot overflow . / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { return Math . floor ( Math . exp ( binomialCoefficientLog ( n , k ) ) + 0 . 5 ) ; }", "fixed_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } / / Use symmetry for large k if ( k > n / 2 ) return binomialCoefficient ( n , n - k ) ; / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k long result = 1 ; if ( n < = 61 ) { / / For n < = 61 , the naive implementation cannot overflow . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { result = result * i / j ; } } else if ( n < = 66 ) { / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . long d = gcd ( i , j ) ; result = ( result / ( j / d ) ) * ( i / d ) ; } } else { / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { long d = gcd ( i , j ) ; result = mulAndCheck ( ( result / ( j / d ) ) , ( i / d ) ) ; } } return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { if ( n < k ) { throw new IllegalArgumentException ( \" must have n > = k for binomial coefficient ( n , k ) \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for binomial coefficient ( n , k ) \" ) ; } if ( ( n = = k ) | | ( k = = 0 ) ) { return 1d ; } if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } if ( k > n / 2 ) { return binomialCoefficientDouble ( n , n - k ) ; } if ( n < 67 ) { return binomialCoefficient ( n , k ) ; } double result = 1d ; for ( int i = 1 ; i < = k ; i + + ) { result * = ( double ) ( n - k + i ) / ( double ) i ; } return Math . floor ( result + 0 . 5 ) ; } if ( n < 67 ) { return Math . log ( binomialCoefficient ( n , k ) ) ; } if ( n < 1030 ) { return Math . log ( binomialCoefficientDouble ( n , k ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_92"}
{"buggy_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < 21 ) { return factorial ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } if ( n < 21 ) { return Math . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "fixed_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "fixed_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < 21 ) { return factorial ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } if ( n < 21 ) { return Math . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_93"}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_93"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_94"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_94"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( 1 . 0 * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_94"}
{"buggy_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret = 1 . 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; if ( d > 2 . 0 ) { / / use mean ret = d / ( d - 2 . 0 ) ; } return ret ; }", "fixed_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret = 1 . 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; if ( d > 2 . 0 ) { / / use mean ret = d / ( d - 2 . 0 ) ; } return ret ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "fixed_code": "FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; key = new Pair ( key , locale ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_95"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_96"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_96"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = 1 . 0 ; return ret ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_96"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > 0 ) { / / check if either value is close to a zero if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; ret = min ; } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; ret = max ; } else { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } } else if ( sign < 0 ) { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; } else { / / either min or max is a root if ( yMin = = 0 . 0 ) { ret = min ; } else { ret = max ; } } return ret ;", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } else { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; / / either min or max is a root } return ret ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } else { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; / / either min or max is a root } return ret ;", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > 0 ) { / / check if either value is close to a zero if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; ret = min ; } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; ret = max ; } else { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } } else if ( sign < 0 ) { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; } else { / / either min or max is a root if ( yMin = = 0 . 0 ) { ret = min ; } else { ret = max ; } } return ret ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_97"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( \" overflow : lcm is 2 ^ 31 \" ) ; } return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "public void captureArgumentsFrom ( Invocation invocation ) { if ( invocation . getMethod ( ) . isVarArgs ( ) ) { int indexOfVararg = invocation . getRawArguments ( ) . length - 1 ; throw new UnsupportedOperationException ( ) ; } else { for ( int position = 0 ; position < matchers . size ( ) ; position + + ) {", "fixed_code": "public void captureArgumentsFrom ( Invocation invocation ) { if ( invocation . getMethod ( ) . isVarArgs ( ) ) { int indexOfVararg = invocation . getRawArguments ( ) . length - 1 ; for ( int position = 0 ; position < indexOfVararg ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getRawArguments ( ) [ position - indexOfVararg ] ) ; } } } else { for ( int position = 0 ; position < matchers . size ( ) ; position + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_1"}
{"buggy_code": "package org . mockito . internal . util ; public class Timer { private long startTime = - 1 ; public Timer ( long durationMillis ) { this . durationMillis = durationMillis ; } startTime = System . currentTimeMillis ( ) ; } }", "fixed_code": "package org . mockito . internal . util ; import org . mockito . exceptions . Reporter ; public class Timer { private long startTime = - 1 ; public Timer ( long durationMillis ) { validateInput ( durationMillis ) ; this . durationMillis = durationMillis ; } startTime = System . currentTimeMillis ( ) ; } private void validateInput ( long durationMillis ) { if ( durationMillis < 0 ) { new Reporter ( ) . cannotCreateTimerWithNegativeDurationTime ( durationMillis ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Mockito_1"}
{"buggy_code": "import org . mockito . internal . util . MockUtil ; import org . mockito . internal . util . reflection . GenericMetadataSupport ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . io . IOException ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } * @ param parentMock The parent of the current deep stub mock . * @ return The mock private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata ) { return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ;", "fixed_code": "import org . mockito . internal . util . MockUtil ; import org . mockito . internal . util . reflection . GenericMetadataSupport ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . mock . MockCreationSettings ; import org . mockito . stubbing . Answer ; import java . io . IOException ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata , invocation . getMock ( ) ) , container ) ; } * @ param parentMock The parent of the current deep stub mock . * @ return The mock private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata , Object parentMock ) { MockCreationSettings parentMockSettings = new MockUtil ( ) . getMockSettings ( parentMock ) ; return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata , parentMockSettings ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata , MockCreationSettings parentMockSettings ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ; return propagateSerializationSettings ( mockSettings , parentMockSettings ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private MockSettings propagateSerializationSettings ( MockSettings mockSettings , MockCreationSettings parentMockSettings ) { return mockSettings . serializable ( parentMockSettings . getSerializableMode ( ) ) ; } private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_10"}
{"buggy_code": "@ Override public boolean equals ( Object o ) { return method . equals ( o ) ; } @ Override public int hashCode ( ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "@ Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o instanceof DelegatingMethod ) { DelegatingMethod that = ( DelegatingMethod ) o ; return method . equals ( that . method ) ; } else { return method . equals ( o ) ; } } @ Override public int hashCode ( ) { return method . hashCode ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_11"}
{"buggy_code": "Type generic = field . getGenericType ( ) ; if ( generic ! = null & & generic instanceof ParameterizedType ) { Type actual = ( ( ParameterizedType ) generic ) . getActualTypeArguments ( ) [ 0 ] ; return ( Class ) actual ; / / in case of nested generics we don ' t go deep } return Object . class ;", "fixed_code": "Type generic = field . getGenericType ( ) ; if ( generic ! = null & & generic instanceof ParameterizedType ) { Type actual = ( ( ParameterizedType ) generic ) . getActualTypeArguments ( ) [ 0 ] ; if ( actual instanceof Class ) { return ( Class ) actual ; } else if ( actual instanceof ParameterizedType ) { / / in case of nested generics we don ' t go deep return ( Class ) ( ( ParameterizedType ) actual ) . getRawType ( ) ; } } return Object . class ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_12"}
{"buggy_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) if ( verificationMode instanceof MockAwareVerificationMode & & ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; / / this means there is an invocation on a different mock . Re - adding verification mode / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) } }", "fixed_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) if ( ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } else { / / this means there is an invocation on a different mock . Re - adding verification mode / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) mockingProgress . verificationStarted ( verificationMode ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_13"}
{"buggy_code": "package org . mockito . internal . configuration . injection ; import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . reflection . FieldSetter ; import java . lang . reflect . Field ; return new OngoingInjecter ( ) { public boolean thenInject ( ) { try { new FieldSetter ( fieldInstance , field ) . set ( matchingMock ) ; } catch ( Exception e ) { throw new MockitoException ( \" Problems injecting dependency in \" + field . getName ( ) , e ) ; }", "fixed_code": "package org . mockito . internal . configuration . injection ; import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . reflection . BeanPropertySetter ; import org . mockito . internal . util . reflection . FieldSetter ; import java . lang . reflect . Field ; return new OngoingInjecter ( ) { public boolean thenInject ( ) { try { if ( ! new BeanPropertySetter ( fieldInstance , field ) . set ( matchingMock ) ) { new FieldSetter ( fieldInstance , field ) . set ( matchingMock ) ; } } catch ( Exception e ) { throw new MockitoException ( \" Problems injecting dependency in \" + field . getName ( ) , e ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_15"}
{"buggy_code": "import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubbedInvocationMatcher ; import org . mockito . internal . stubbing . VoidMethodStubbableImpl ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . stubbing . Answer ; import org . mockito . stubbing . VoidMethodStubbable ; if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ; import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubberImpl ; import org . mockito . internal . util . MockUtil ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . internal . verification . VerificationModeFactory ; import org . mockito . internal . verification . api . InOrderContext ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; return mock ; }", "fixed_code": "import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubbedInvocationMatcher ; import org . mockito . internal . stubbing . VoidMethodStubbableImpl ; import org . mockito . internal . verification . MockAwareVerificationMode ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . stubbing . Answer ; import org . mockito . stubbing . VoidMethodStubbable ; if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest if ( verificationMode instanceof MockAwareVerificationMode & & ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ; import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubberImpl ; import org . mockito . internal . util . MockUtil ; import org . mockito . internal . verification . MockAwareVerificationMode ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . internal . verification . VerificationModeFactory ; import org . mockito . internal . verification . api . InOrderContext ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , mode ) ) ; return mock ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Mockito_15"}
{"buggy_code": "private Object spiedInstance ; private Answer < Object > defaultAnswer ; private MockName mockName ; public MockSettings serializable ( ) { return this . extraInterfaces ( java . io . Serializable . class ) ; } public MockSettings extraInterfaces ( Class < ? > . . . extraInterfaces ) { } public boolean isSerializable ( ) { return extraInterfaces ! = null & & java . util . Arrays . asList ( extraInterfaces ) . contains ( java . io . Serializable . class ) ; } public void initiateMockName ( Class classToMock ) { import org . mockito . internal . creation . jmock . ClassImposterizer ; import org . mockito . internal . util . reflection . LenientCopyTool ; @ SuppressWarnings ( \" unchecked \" ) public class MockUtil { Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;", "fixed_code": "private Object spiedInstance ; private Answer < Object > defaultAnswer ; private MockName mockName ; private boolean serializable ; public MockSettings serializable ( ) { this . serializable = true ; return this ; } public MockSettings extraInterfaces ( Class < ? > . . . extraInterfaces ) { } public boolean isSerializable ( ) { return serializable ; } public void initiateMockName ( Class classToMock ) { import org . mockito . internal . creation . jmock . ClassImposterizer ; import org . mockito . internal . util . reflection . LenientCopyTool ; import java . io . Serializable ; @ SuppressWarnings ( \" unchecked \" ) public class MockUtil { Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; if ( settings . isSerializable ( ) ) { ancillaryTypes = interfaces = = null ? new Class < ? > [ ] { Serializable . class } : new ArrayUtils ( ) . concat ( interfaces , Serializable . class ) ; } else { ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; } Object spiedInstance = settings . getSpiedInstance ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_17"}
{"buggy_code": "return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; / / new instances are used instead of Collections . emptyList ( ) , etc . / / to avoid UnsupportedOperationException if code under test modifies returned collection } else if ( type = = Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type = = Set . class ) {", "fixed_code": "return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; / / new instances are used instead of Collections . emptyList ( ) , etc . / / to avoid UnsupportedOperationException if code under test modifies returned collection } else if ( type = = Iterable . class ) { return new ArrayList < Object > ( 0 ) ; } else if ( type = = Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type = = Set . class ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_18"}
{"buggy_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ; import java . lang . reflect . Field ; import java . util . Collection ; public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ; import java . lang . reflect . Field ; import java . util . Collection ; public interface MockCandidateFilter { OngoingInjecter filterCandidate ( Collection < Object > mocks , Field fieldToBeInjected , Object fieldInstance ) ; } } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fieldInstance ) ; } return next . filterCandidate ( mocks , field , fieldInstance ) ; } } this . next = next ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fieldInstance ) ; } }", "fixed_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , orderedInstanceFields , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ; import java . lang . reflect . Field ; import java . util . Collection ; import java . util . List ; public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , List < Field > fields , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ; import java . lang . reflect . Field ; import java . util . Collection ; import java . util . List ; public interface MockCandidateFilter { OngoingInjecter filterCandidate ( Collection < Object > mocks , Field fieldToBeInjected , List < Field > fields , Object instance ) ; } } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fields , fieldInstance ) ; } else if ( mocks . size ( ) = = 1 ) { String mockName = mockUtil . getMockName ( mocks . iterator ( ) . next ( ) ) . toString ( ) ;  for ( Field otherField : fields ) { if ( ! otherField . equals ( field ) & & otherField . getType ( ) . equals ( field . getType ( ) ) & & otherField . getName ( ) . equals ( mockName ) ) {  return new OngoingInjecter ( ) { public Object thenInject ( ) { return null ; } } ; } } } return next . filterCandidate ( mocks , field , fields , fieldInstance ) ; } } this . next = next ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fields , fieldInstance ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_19"}
{"buggy_code": "private static final long serialVersionUID = - 7105341425736035847L ; private MockitoCore mockitoCore = new MockitoCore ( ) ; private ReturnsEmptyValues delegate = new ReturnsEmptyValues ( ) ; public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ; Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; } return getMock ( invocation , returnTypeGenericMetadata ) ; } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } return mock ; } protected GenericMetadataSupport actualParameterizedType ( Object mock ) {", "fixed_code": "private static final long serialVersionUID = - 7105341425736035847L ; private transient MockitoCore mockitoCore ; private transient ReturnsEmptyValues delegate ; public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ; Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; instantiateMockitoCoreIfNeeded ( ) ; instantiateDelegateIfNeeded ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; } return getMock ( invocation , returnTypeGenericMetadata ) ; } private synchronized void instantiateMockitoCoreIfNeeded ( ) { if ( mockitoCore = = null ) { mockitoCore = new MockitoCore ( ) ; } } private synchronized void instantiateDelegateIfNeeded ( ) { if ( delegate = = null ) { delegate = new ReturnsEmptyValues ( ) ; } } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new SerializableAnswer ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } return mock ; } abstract class SerializableAnswer implements Answer < Object > , Serializable { } protected GenericMetadataSupport actualParameterizedType ( Object mock ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_24"}
{"buggy_code": "/ / see issue 184 . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compareTo ( ) method by the Comparable interface return 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ;", "fixed_code": "/ / see issue 184 . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compareTo ( ) method by the Comparable interface return invocation . getMock ( ) = = invocation . getArguments ( ) [ 0 ] ? 0 : 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Mockito_24"}
{"buggy_code": "( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getRawArguments ( ) [ position - indexOfVararg ] ) ; } } } else { } } public static List < InvocationMatcher > createFrom ( List < Invocation > invocations ) { LinkedList < InvocationMatcher > out = new LinkedList < InvocationMatcher > ( ) ;", "fixed_code": "( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( Matcher m : uniqueMatcherSet ( indexOfVararg ) ) { if ( m instanceof CapturesArguments ) { Object rawArgument = invocation . getRawArguments ( ) [ indexOfVararg ] ; for ( int i = 0 ; i < Array . getLength ( rawArgument ) ; i + + ) { ( ( CapturesArguments ) m ) . captureFrom ( Array . get ( rawArgument , i ) ) ; } } } } else { } } private Set < Matcher > uniqueMatcherSet ( int indexOfVararg ) { HashSet < Matcher > set = new HashSet < Matcher > ( ) ; for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher matcher = matchers . get ( position ) ; if ( matcher instanceof MatcherDecorator ) { set . add ( ( ( MatcherDecorator ) matcher ) . getActualMatcher ( ) ) ; } else { set . add ( matcher ) ; } } return set ; } public static List < InvocationMatcher > createFrom ( List < Invocation > invocations ) { LinkedList < InvocationMatcher > out = new LinkedList < InvocationMatcher > ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_3"}
{"buggy_code": ") ) ; } public void smartNullPointerException ( Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , \" Because this method was * not * stubbed correctly : \" , location , \" \" return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; }", "fixed_code": ") ) ; } public void smartNullPointerException ( Object obj , Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , obj , \" Because this method was * not * stubbed correctly : \" , location , \" \" return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( obj , location ) ; return null ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_30"}
{"buggy_code": "import java . io . Serializable ; import java . lang . reflect . Method ; import org . mockito . Mockito ; import org . mockito . cglib . proxy . MethodInterceptor ; } private String formatMethodCall ( ) { return invocation . getMethod ( ) . getName ( ) + \" ( ) \" ; } }", "fixed_code": "import java . io . Serializable ; import java . lang . reflect . Method ; import java . util . Arrays ; import org . mockito . Mockito ; import org . mockito . cglib . proxy . MethodInterceptor ; } private String formatMethodCall ( ) { String args = Arrays . toString ( invocation . getArguments ( ) ) ; return invocation . getMethod ( ) . getName ( ) + \" ( \" + args . substring ( 1 , args . length ( ) - 1 ) + \" ) \" ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_31"}
{"buggy_code": "import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . MockUtil ; @ SuppressWarnings ( { \" unchecked \" } ) public class SpyAnnotationEngine implements AnnotationEngine { / / instance has been spied earlier Mockito . reset ( instance ) ; } else { field . set ( testClass , Mockito . spy ( instance ) ) ; } } catch ( IllegalAccessException e ) { throw new MockitoException ( \" Problems initiating spied field \" + field . getName ( ) , e ) ;", "fixed_code": "import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . MockUtil ; import static org . mockito . Mockito . withSettings ; @ SuppressWarnings ( { \" unchecked \" } ) public class SpyAnnotationEngine implements AnnotationEngine { / / instance has been spied earlier Mockito . reset ( instance ) ; } else { field . set ( testClass , Mockito . mock ( instance . getClass ( ) , withSettings ( ) . spiedInstance ( instance ) . defaultAnswer ( Mockito . CALLS_REAL_METHODS ) . name ( field . getName ( ) ) ) ) ; } } catch ( IllegalAccessException e ) { throw new MockitoException ( \" Problems initiating spied field \" + field . getName ( ) , e ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_32"}
{"buggy_code": "Method m1 = invocation . getMethod ( ) ; Method m2 = candidate . getMethod ( ) ; return m1 . equals ( m2 ) ; } public Location getLocation ( ) {", "fixed_code": "Method m1 = invocation . getMethod ( ) ; Method m2 = candidate . getMethod ( ) ; if ( m1 . getName ( ) ! = null & & m1 . getName ( ) . equals ( m2 . getName ( ) ) ) { Class [ ] params1 = m1 . getParameterTypes ( ) ; Class [ ] params2 = m2 . getParameterTypes ( ) ; if ( params1 . length = = params2 . length ) { for ( int i = 0 ; i < params1 . length ; i + + ) { if ( params1 [ i ] ! = params2 [ i ] ) return false ; } return true ; } } return false ; } public Location getLocation ( ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_33"}
{"buggy_code": "public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k + + ;", "fixed_code": "public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments & & i . getArguments ( ) . length > k ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k + + ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_34"}
{"buggy_code": "import org . hamcrest . Matcher ; import org . mockito . exceptions . PrintableInvocation ; import org . mockito . internal . debugging . Location ; import org . mockito . internal . invocation . realmethod . RealMethod ; import org . mockito . internal . matchers . * ; } public Object callRealMethod ( ) throws Throwable { return realMethod . invoke ( mock , rawArguments ) ; }", "fixed_code": "import org . hamcrest . Matcher ; import org . mockito . exceptions . PrintableInvocation ; import org . mockito . exceptions . Reporter ; import org . mockito . internal . debugging . Location ; import org . mockito . internal . invocation . realmethod . RealMethod ; import org . mockito . internal . matchers . * ; } public Object callRealMethod ( ) throws Throwable { if ( this . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { new Reporter ( ) . cannotCallRealMethodOnInterface ( ) ; } return realMethod . invoke ( mock , rawArguments ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_36"}
{"buggy_code": "* @ return < code > null < / code > . public static < T > T isA ( Class < T > clazz ) { return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnNull ( ) ; } public static < T > T eq ( T value ) { return reportMatcher ( new Equals ( value ) ) . < T > returnNull ( ) ; } public static < T > T same ( T value ) { return reportMatcher ( new Same ( value ) ) . < T > returnNull ( ) ; }", "fixed_code": "* @ return < code > null < / code > . public static < T > T isA ( Class < T > clazz ) { return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnFor ( clazz ) ; } public static < T > T eq ( T value ) { return ( T ) reportMatcher ( new Equals ( value ) ) . < T > returnFor ( ( Class ) value . getClass ( ) ) ; } public static < T > T same ( T value ) { return ( T ) reportMatcher ( new Same ( value ) ) . < T > returnFor ( ( Class ) value . getClass ( ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Mockito_36"}
{"buggy_code": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } } private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { if ( ! invocation . isVoid ( ) ) {", "fixed_code": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } if ( answer instanceof CallsRealMethods ) { validateMockingConcreteClass ( ( CallsRealMethods ) answer , invocation ) ; } } private void validateMockingConcreteClass ( CallsRealMethods answer , Invocation invocation ) { if ( invocation . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { reporter . cannotCallRealMethodOnInterface ( ) ; } } private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { if ( ! invocation . isVoid ( ) ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_37"}
{"buggy_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } }", "fixed_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg = = null ? \" null \" : arg . toString ( ) ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_38"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Mockito_38"}
{"buggy_code": "throw new NoInteractionsWanted ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + undesired . getMock ( ) + \" ' : \" , undesired . getLocation ( ) , scenario ) ) ; throw new VerificationInOrderFailure ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + undesired . getMock ( ) + \" ' : \" , undesired . getLocation ( ) ) ) ; } } private String exceptionCauseMessageIfAvailable ( Exception details ) { return details . getCause ( ) . getMessage ( ) ; }", "fixed_code": "throw new NoInteractionsWanted ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + safelyGetMockName ( undesired . getMock ( ) ) + \" ' : \" , undesired . getLocation ( ) , scenario ) ) ; throw new VerificationInOrderFailure ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + safelyGetMockName ( undesired . getMock ( ) ) + \" ' : \" , undesired . getLocation ( ) ) ) ; } } private String exceptionCauseMessageIfAvailable ( Exception details ) { if ( details . getCause ( ) = = null ) { return details . getMessage ( ) ; } return details . getCause ( ) . getMessage ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_4"}
{"buggy_code": "} catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( org . mockito . exceptions . verification . junit . ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; } }", "fixed_code": "} catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( AssertionError e ) { error = handleVerifyException ( e ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_5"}
{"buggy_code": "* @ return < code > false < / code > . public static boolean anyBoolean ( ) { return reportMatcher ( Any . ANY ) . returnFalse ( ) ; } public static byte anyByte ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static char anyChar ( ) { return reportMatcher ( Any . ANY ) . returnChar ( ) ; } public static int anyInt ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static long anyLong ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static float anyFloat ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static double anyDouble ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static short anyShort ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static < T > T anyObject ( ) { return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; } public static < T > T any ( Class < T > clazz ) { return ( T ) reportMatcher ( Any . ANY ) . returnFor ( clazz ) ; } public static < T > T any ( ) { return ( T ) anyObject ( ) ; } public static String anyString ( ) { return reportMatcher ( Any . ANY ) . returnString ( ) ; } public static List anyList ( ) { return reportMatcher ( Any . ANY ) . returnList ( ) ; } public static < T > List < T > anyListOf ( Class < T > clazz ) { return ( List ) reportMatcher ( Any . ANY ) . returnList ( ) ; } public static Set anySet ( ) { return reportMatcher ( Any . ANY ) . returnSet ( ) ; } public static < T > Set < T > anySetOf ( Class < T > clazz ) { return ( Set ) reportMatcher ( Any . ANY ) . returnSet ( ) ; } public static Map anyMap ( ) { return reportMatcher ( Any . ANY ) . returnMap ( ) ; } public static < K , V > Map < K , V > anyMapOf ( Class < K > keyClazz , Class < V > valueClazz ) { return reportMatcher ( Any . ANY ) . returnMap ( ) ; } public static Collection anyCollection ( ) { return reportMatcher ( Any . ANY ) . returnList ( ) ; } public static < T > Collection < T > anyCollectionOf ( Class < T > clazz ) { return ( Collection ) reportMatcher ( Any . ANY ) . returnList ( ) ; }", "fixed_code": "* @ return < code > false < / code > . public static boolean anyBoolean ( ) { return reportMatcher ( new InstanceOf ( Boolean . class ) ) . returnFalse ( ) ; } public static byte anyByte ( ) { return reportMatcher ( new InstanceOf ( Byte . class ) ) . returnZero ( ) ; } public static char anyChar ( ) { return reportMatcher ( new InstanceOf ( Character . class ) ) . returnChar ( ) ; } public static int anyInt ( ) { return reportMatcher ( new InstanceOf ( Integer . class ) ) . returnZero ( ) ; } public static long anyLong ( ) { return reportMatcher ( new InstanceOf ( Long . class ) ) . returnZero ( ) ; } public static float anyFloat ( ) { return reportMatcher ( new InstanceOf ( Float . class ) ) . returnZero ( ) ; } public static double anyDouble ( ) { return reportMatcher ( new InstanceOf ( Double . class ) ) . returnZero ( ) ; } public static short anyShort ( ) { return reportMatcher ( new InstanceOf ( Short . class ) ) . returnZero ( ) ; } public static < T > T anyObject ( ) { return ( T ) reportMatcher ( new InstanceOf ( Object . class ) ) . returnNull ( ) ; } public static < T > T any ( Class < T > clazz ) { return ( T ) reportMatcher ( new InstanceOf ( clazz ) ) . returnFor ( clazz ) ; } public static < T > T any ( ) { return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; } public static String anyString ( ) { return reportMatcher ( new InstanceOf ( String . class ) ) . returnString ( ) ; } public static List anyList ( ) { return reportMatcher ( new InstanceOf ( List . class ) ) . returnList ( ) ; } public static < T > List < T > anyListOf ( Class < T > clazz ) { return anyList ( ) ; } public static Set anySet ( ) { return reportMatcher ( new InstanceOf ( Set . class ) ) . returnSet ( ) ; } public static < T > Set < T > anySetOf ( Class < T > clazz ) { return anySet ( ) ; } public static Map anyMap ( ) { return reportMatcher ( new InstanceOf ( Map . class ) ) . returnMap ( ) ; } public static < K , V > Map < K , V > anyMapOf ( Class < K > keyClazz , Class < V > valueClazz ) { return anyMap ( ) ; } public static Collection anyCollection ( ) { return reportMatcher ( new InstanceOf ( Collection . class ) ) . returnList ( ) ; } public static < T > Collection < T > anyCollectionOf ( Class < T > clazz ) { return anyCollection ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_6"}
{"buggy_code": "for ( Type type : typeVariable . getBounds ( ) ) { registerTypeVariablesOn ( type ) ; } registerTypeVariablesOn ( getActualTypeArgumentFor ( typeVariable ) ) ; }", "fixed_code": "for ( Type type : typeVariable . getBounds ( ) ) { registerTypeVariablesOn ( type ) ; } registerTypeParametersOn ( new TypeVariable [ ] { typeVariable } ) ; registerTypeVariablesOn ( getActualTypeArgumentFor ( typeVariable ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_7"}
{"buggy_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ;", "fixed_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else if ( typeParameter ! = actualTypeArgument ) { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_8"}
{"buggy_code": "package org . mockito . internal . stubbing . answers ; import java . io . Serializable ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; private static final long serialVersionUID = 9057165148930624087L ; public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . callRealMethod ( ) ; } } \\ No newline at end of file", "fixed_code": "package org . mockito . internal . stubbing . answers ; import java . io . Serializable ; import java . lang . reflect . Modifier ; import org . mockito . internal . stubbing . defaultanswers . GloballyConfiguredAnswer ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; private static final long serialVersionUID = 9057165148930624087L ; public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( Modifier . isAbstract ( invocation . getMethod ( ) . getModifiers ( ) ) ) { return new GloballyConfiguredAnswer ( ) . answer ( invocation ) ; } return invocation . callRealMethod ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Mockito_9"}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_1"}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_1"}
{"buggy_code": "private static final long serialVersionUID = 9386874258972L ; private static final long START_1972 = 2L * 365L * 86400L * 1000L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; return values [ 0 ] ; }", "fixed_code": "private static final long serialVersionUID = 9386874258972L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; return values [ 0 ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_10"}
{"buggy_code": "private static final long serialVersionUID = 9386874258972L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; return values [ 0 ] ; }", "fixed_code": "private static final long serialVersionUID = 9386874258972L ; private static final long START_1972 = 2L * 365L * 86400L * 1000L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; return values [ 0 ] ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_10"}
{"buggy_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) { protected Boolean initialValue ( ) { return Boolean . FALSE ; } } ;", "fixed_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) ; static { cVerbose . set ( Boolean . FALSE ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) ; static { cVerbose . set ( Boolean . FALSE ) ; }", "fixed_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) { protected Boolean initialValue ( ) { return Boolean . FALSE ; } } ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_11"}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , ' - ' ) ; } buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "fixed_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = Math . max ( sum , 4 ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_13"}
{"buggy_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = Math . max ( sum , 4 ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "fixed_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , ' - ' ) ; } buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_13"}
{"buggy_code": "if ( valueToAdd = = 0 ) { return values ; } if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { / / month is largest field and being added to , such as month - day int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "fixed_code": "if ( valueToAdd = = 0 ) { return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "fixed_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_16"}
{"buggy_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "fixed_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_16"}
{"buggy_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "fixed_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "fixed_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_17"}
{"buggy_code": "/ / Assume date is Gregorian . long instant ; try { instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } catch ( IllegalFieldValueException ex ) { if ( monthOfYear ! = 2 | | dayOfMonth ! = 29 ) { throw ex ; } instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , 28 , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw ex ; } } if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "fixed_code": "/ / Assume date is Gregorian . long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_19"}
{"buggy_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "fixed_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_2"}
{"buggy_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "fixed_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_2"}
{"buggy_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; String best = null ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { if ( best = = null | | id . length ( ) > best . length ( ) ) { best = id ; } } } if ( best ! = null ) { bucket . setZone ( DateTimeZone . forID ( best ) ) ; return position + best . length ( ) ; } return ~ position ; } }", "fixed_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; } } return ~ position ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_20"}
{"buggy_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; } } return ~ position ; } }", "fixed_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; String best = null ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { if ( best = = null | | id . length ( ) > best . length ( ) ) { best = id ; } } } if ( best ! = null ) { bucket . setZone ( DateTimeZone . forID ( best ) ) ; return position + best . length ( ) ; } return ~ position ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_20"}
{"buggy_code": "if ( byNameKeyCache = = null ) { byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; String [ ] [ ] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings ( ) ; String [ ] setEn = null ; for ( String [ ] strings : zoneStringsEn ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setEn = strings ; break ; } } String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; String [ ] setLoc = null ; for ( String [ ] strings : zoneStringsLoc ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break ; } } if ( setEn ! = null & & setLoc ! = null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; / / need to handle case where summer and winter have the same / / abbreviation , such as EST in Australia [ 1716305 ] / / we handle this by appending \" - Summer \" , cf ZoneInfoCompiler if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + \" - Summer \" , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else { byNameKeyCache . put ( setEn [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } }", "fixed_code": "if ( byNameKeyCache = = null ) { byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; String [ ] setLoc = null ; for ( String [ ] strings : zoneStringsLoc ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setLoc = strings ; byNameKeyCache . put ( setLoc [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; / / need to handle case where summer and winter have the same / / abbreviation , such as EST in Australia [ 1716305 ] / / we handle this by appending \" - Summer \" , cf ZoneInfoCompiler if ( setLoc [ 2 ] . equals ( setLoc [ 4 ] ) ) { byNameKeyCache . put ( setLoc [ 4 ] + \" - Summer \" , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else { byNameKeyCache . put ( setLoc [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } break ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_21"}
{"buggy_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; }", "fixed_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_22"}
{"buggy_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] }", "fixed_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_22"}
{"buggy_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" WET \" , \" WET \" ) ; map . put ( \" CET \" , \" CET \" ) ; map . put ( \" MET \" , \" CET \" ) ; map . put ( \" ECT \" , \" CET \" ) ; map . put ( \" EET \" , \" EET \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indiana / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Argentina / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Kolkata \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Ho_Chi_Minh \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "fixed_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" WET \" , \" Europe / London \" ) ; map . put ( \" ECT \" , \" Europe / Paris \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EET \" , \" Europe / Bucharest \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" MET \" , \" Asia / Tehran \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Calcutta \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Saigon \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_23"}
{"buggy_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" WET \" , \" Europe / London \" ) ; map . put ( \" ECT \" , \" Europe / Paris \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EET \" , \" Europe / Bucharest \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" MET \" , \" Asia / Tehran \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Calcutta \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Saigon \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "fixed_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" WET \" , \" WET \" ) ; map . put ( \" CET \" , \" CET \" ) ; map . put ( \" MET \" , \" CET \" ) ; map . put ( \" ECT \" , \" CET \" ) ; map . put ( \" EET \" , \" EET \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indiana / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Argentina / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Kolkata \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Ho_Chi_Minh \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_23"}
{"buggy_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } if ( resetFields ) { for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , i = = ( count - 1 ) ) ; } } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "fixed_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_24"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev < = diff ) { return offsetPrev ; } } } return offsetAdjusted ; }", "fixed_code": "return offsetLocal ; } } } return offsetAdjusted ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_25"}
{"buggy_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } }", "fixed_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_26"}
{"buggy_code": "* @ throws IllegalArgumentException if the zone has no equivalent local time * @ since 2 . 0", "fixed_code": "* @ throws IllegalArgumentException if the zone has no equivalent local time * @ since 2 . 0 public long convertLocalToUTC ( long instantLocal , boolean strict , long originalInstantUTC ) { int offsetOriginal = getOffset ( originalInstantUTC ) ; long instantUTC = instantLocal - offsetOriginal ; int offsetLocalFromOriginal = getOffset ( instantUTC ) ; if ( offsetLocalFromOriginal = = offsetOriginal ) { return instantUTC ; } return convertLocalToUTC ( instantLocal , strict ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_26"}
{"buggy_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; if ( sep . iAfterParser = = null & & sep . iAfterPrinter = = null ) { PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "fixed_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_27"}
{"buggy_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } if ( amount ! = 0 ) { setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { if ( years ! = 0 ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { if ( weekyears ! = 0 ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { if ( months ! = 0 ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { if ( weeks ! = 0 ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { if ( days ! = 0 ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { if ( hours ! = 0 ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { if ( minutes ! = 0 ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { if ( seconds ! = 0 ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { if ( millis ! = 0 ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_3"}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_4"}
{"buggy_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { long totalMonths = years * 12L + months ; if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; result = result . withYears ( normalizedYears ) ; totalMonths = totalMonths - ( normalizedYears * 12 ) ; } if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; result = result . withMonths ( normalizedMonths ) ; totalMonths = totalMonths - normalizedMonths ; } if ( totalMonths ! = 0 ) { throw new UnsupportedOperationException ( \" Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : \" + toString ( ) ) ; } } return result ;", "fixed_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { years = FieldUtils . safeAdd ( years , months / 12 ) ; months = months % 12 ; if ( years ! = 0 ) { result = result . withYears ( years ) ; } if ( months ! = 0 ) { result = result . withMonths ( months ) ; } } return result ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_5"}
{"buggy_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { years = FieldUtils . safeAdd ( years , months / 12 ) ; months = months % 12 ; if ( years ! = 0 ) { result = result . withYears ( years ) ; } if ( months ! = 0 ) { result = result . withMonths ( months ) ; } } return result ;", "fixed_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { long totalMonths = years * 12L + months ; if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; result = result . withYears ( normalizedYears ) ; totalMonths = totalMonths - ( normalizedYears * 12 ) ; } if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; result = result . withMonths ( normalizedMonths ) ; totalMonths = totalMonths - normalizedMonths ; } if ( totalMonths ! = 0 ) { throw new UnsupportedOperationException ( \" Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : \" + toString ( ) ) ; } } return result ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_5"}
{"buggy_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis ( ) , GregorianChronology . getInstance ( zone ) ) ; if ( cutoverDate . getYear ( ) < = 0 ) { throw new IllegalArgumentException ( \" Cutover too early . Must be on or after 0001 - 01 - 01 . \" ) ; } } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } }", "fixed_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_6"}
{"buggy_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < - 59 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } if ( hoursOffset > 0 & & minutesOffset < 0 ) { throw new IllegalArgumentException ( \" Positive hours must not have negative minutes : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "fixed_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_8"}
{"buggy_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "fixed_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < - 59 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } if ( hoursOffset > 0 & & minutesOffset < 0 ) { throw new IllegalArgumentException ( \" Positive hours must not have negative minutes : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_8"}
{"buggy_code": "if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { throw new IllegalArgumentException ( \" Millis out of range : \" + millisOffset ) ; } String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; if ( hoursInMinutes < 0 ) { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; } else { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch1", "project_name": "Time_9"}
{"buggy_code": "public static final DateTimeZone UTC = new FixedDateTimeZone ( \" UTC \" , \" UTC \" , 0 , 0 ) ; private static Provider cProvider ; if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; if ( hoursInMinutes < 0 ) { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; } else { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "public static final DateTimeZone UTC = new FixedDateTimeZone ( \" UTC \" , \" UTC \" , 0 , 0 ) ; private static final int MAX_MILLIS = ( 86400 * 1000 ) - 1 ; private static Provider cProvider ; if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { throw new IllegalArgumentException ( \" Millis out of range : \" + millisOffset ) ; } String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_9"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText }", "fixed_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) \" \\ \" alt = \\ \" \\ \" \" ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_10"}
{"buggy_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText }", "fixed_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) \" \\ \" alt = \\ \" \\ \" \" ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_10"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_11"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "fixed_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "fixed_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "fixed_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "fixed_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_15"}
{"buggy_code": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "fixed_code": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_16"}
{"buggy_code": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "fixed_code": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_16"}
{"buggy_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; }", "fixed_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; }", "fixed_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_17"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_18"}
{"buggy_code": "* @ see # removeRow ( Comparable ) public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "* @ see # removeRow ( Comparable ) public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Chart_18"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_19"}
{"buggy_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "fixed_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_2"}
{"buggy_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "fixed_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_2"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_20"}
{"buggy_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }", "fixed_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }", "fixed_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_21"}
{"buggy_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } / / 2 . check whether the column is now empty . } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } / / 2 . check whether the column is now empty . } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_22"}
{"buggy_code": "* * @ since 1 . 0 . 7", "fixed_code": "* * @ since 1 . 0 . 7 public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof MinMaxCategoryRenderer ) ) { return false ; } MinMaxCategoryRenderer that = ( MinMaxCategoryRenderer ) obj ; if ( this . plotLines ! = that . plotLines ) { return false ; } if ( ! PaintUtilities . equal ( this . groupPaint , that . groupPaint ) ) { return false ; } if ( ! this . groupStroke . equals ( that . groupStroke ) ) { return false ; } return super . equals ( obj ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_23"}
{"buggy_code": "* * @ since 1 . 0 . 7", "fixed_code": "* * @ since 1 . 0 . 7 public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof MinMaxCategoryRenderer ) ) { return false ; } MinMaxCategoryRenderer that = ( MinMaxCategoryRenderer ) obj ; if ( this . plotLines ! = that . plotLines ) { return false ; } if ( ! PaintUtilities . equal ( this . groupPaint , that . groupPaint ) ) { return false ; } if ( ! this . groupStroke . equals ( that . groupStroke ) ) { return false ; } return super . equals ( obj ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_23"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "fixed_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "fixed_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_3"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_4"}
{"buggy_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "fixed_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "fixed_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; }", "fixed_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; }", "fixed_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_6"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_8"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "package org . apache . commons . cli ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; private Map options = new HashMap ( ) ; private Map names = new HashMap ( ) ; / / private Set allOptions = new HashSet ( ) ; private Map hashcodeMap = new HashMap ( ) ; public boolean hasOption ( String opt ) { return options . containsKey ( opt ) ; } public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  String key = opt ; if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; } * @ param opt short or long name of the option * @ return Canonicalized option void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; if ( key = = null ) { key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; } public Iterator iterator ( ) { return hashcodeMap . values ( ) . iterator ( ) ; } public Option [ ] getOptions ( ) { Collection processed = options . values ( ) ; / / reinitialise array Option [ ] optionsArray = new Option [ processed . size ( ) ] ; / / return the array return ( Option [ ] ) processed . toArray ( optionsArray ) ; } } \\ No newline at end of file", "fixed_code": "package org . apache . commons . cli ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . HashSet ; private Set options = new HashSet ( ) ; / / private Set allOptions = new HashSet ( ) ; public boolean hasOption ( String opt ) { return options . contains ( resolveOption ( opt ) ) ; } public String [ ] getOptionValues ( String opt ) { Option key = resolveOption ( opt ) ; if ( options . contains ( key ) ) { return key . getValues ( ) ; } return null ; } * @ param opt short or long name of the option * @ return Canonicalized option private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ; ) { Option option = ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; } void addOption ( Option opt ) { options . add ( opt ) ; } public Iterator iterator ( ) { return options . iterator ( ) ; } public Option [ ] getOptions ( ) { Collection processed = options ; / / reinitialise array Option [ ] optionsArray = new Option [ processed . size ( ) ] ; / / return the array return ( Option [ ] ) processed . toArray ( optionsArray ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_1"}
{"buggy_code": "package org . apache . commons . cli ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . Iterator ; protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = options . getRequiredOptions ( ) ; } protected Options getOptions ( ) {", "fixed_code": "package org . apache . commons . cli ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . Iterator ; protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions ( ) ) ; } protected Options getOptions ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_10"}
{"buggy_code": "} / / if the Option has a value if ( option . hasArg ( ) & & ( option . getArgName ( ) ! = null ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "fixed_code": "} / / if the Option has a value if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_11"}
{"buggy_code": "} else { if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { / / the format is - - foo = value or - foo = value / / the format is a special properties option ( - Dproperty = value ) tokens . add ( arg . substring ( 0 , 2 ) ) ; / / - D tokens . add ( arg . substring ( 2 ) ) ; / / property = value", "fixed_code": "} else { if ( opt . indexOf ( ' = ' ) ! = - 1 & & options . hasOption ( opt . substring ( 0 , opt . indexOf ( ' = ' ) ) ) ) { / / the format is - - foo = value or - foo = value tokens . add ( arg . substring ( 0 , arg . indexOf ( ' = ' ) ) ) ; / / - - foo tokens . add ( arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ) ; / / value } else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { / / the format is a special properties option ( - Dproperty = value ) tokens . add ( arg . substring ( 0 , 2 ) ) ; / / - D tokens . add ( arg . substring ( 2 ) ) ; / / property = value", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_12"}
{"buggy_code": "* @ param option the Option associated with the values * @ return a list of values or an empty List if none are found", "fixed_code": "* @ param option the Option associated with the values * @ return a list of values or an empty List if none are found List getUndefaultedValues ( final Option option ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_13"}
{"buggy_code": "return valueList ; } / / First grab the command line values / / Finally use an empty list public Boolean getSwitch ( final Option option , final Boolean defaultValue ) {", "fixed_code": "return valueList ; } public List getUndefaultedValues ( Option option ) { / / First grab the command line values List valueList = ( List ) values . get ( option ) ; / / Finally use an empty list if ( valueList = = null ) { valueList = Collections . EMPTY_LIST ; }  return valueList ; } public Boolean getSwitch ( final Option option , final Boolean defaultValue ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_13"}
{"buggy_code": "final Option option ) throws OptionException { / / count of arguments processed for this option . int argumentCount = 0 ; while ( arguments . hasNext ( ) & & ( argumentCount < maximum ) ) { final String allValuesQuoted = ( String ) arguments . next ( ) ;", "fixed_code": "final Option option ) throws OptionException { / / count of arguments processed for this option . int argumentCount = commandLine . getUndefaultedValues ( option ) . size ( ) ; while ( arguments . hasNext ( ) & & ( argumentCount < maximum ) ) { final String allValuesQuoted = ( String ) arguments . next ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Cli_13"}
{"buggy_code": "/ / needs validation ? boolean validate = option . isRequired ( ) | | option instanceof Group ; if ( validate ) { option . validate ( commandLine ) ; } / / if the child option is present then validate it if ( commandLine . hasOption ( option ) ) { break ; } option . validate ( commandLine ) ; } }", "fixed_code": "/ / needs validation ? boolean validate = option . isRequired ( ) | | option instanceof Group ; / / if the child option is present then validate it if ( commandLine . hasOption ( option ) ) { break ; } validate = true ; } if ( validate ) { option . validate ( commandLine ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_14"}
{"buggy_code": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } / / augment the list with the default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = ( List ) this . defaultValues . get ( option ) ; } / / if there are more default values as specified , add them to / / the list . / / copy the list first return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "fixed_code": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( defaultValues = = null | | defaultValues . isEmpty ( ) ) { defaultValues = ( List ) this . defaultValues . get ( option ) ; } / / augment the list with the default values if ( defaultValues ! = null & & ! defaultValues . isEmpty ( ) ) { if ( valueList = = null | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } else { / / if there are more default values as specified , add them to / / the list . if ( defaultValues . size ( ) > valueList . size ( ) ) { / / copy the list first valueList = new ArrayList ( valueList ) ; for ( int i = valueList . size ( ) ; i < defaultValues . size ( ) ; i + + ) { valueList . add ( defaultValues . get ( i ) ) ; } } } } return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_15"}
{"buggy_code": "} / / ensure that all parent options are also added } public void addValue ( final Option option ,", "fixed_code": "} / / ensure that all parent options are also added Option parent = option . getParent ( ) ; while ( parent ! = null & & ! options . contains ( parent ) ) { options . add ( parent ) ; parent = parent . getParent ( ) ; } } public void addValue ( final Option option ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_16"}
{"buggy_code": "public abstract class OptionImpl implements Option { private final int id ; private final boolean required ;", "fixed_code": "public abstract class OptionImpl implements Option { private final int id ; private final boolean required ; private Option parent ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_16"}
{"buggy_code": "/ / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; if ( option instanceof Argument ) { i . remove ( ) ;", "fixed_code": "/ / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; option . setParent ( this ) ; if ( option instanceof Argument ) { i . remove ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Cli_16"}
{"buggy_code": "* * @ return the parent of this option }", "fixed_code": "* * @ return the parent of this option Option getParent ( ) ; void setParent ( Option parent ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Cli_16"}
{"buggy_code": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else {", "fixed_code": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; break ; } else {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_17"}
{"buggy_code": "/ / single hyphen else if ( \" - \" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( \" - \" ) ) { tokens . add ( value ) ; } } private void processSingleHyphen ( String hyphen ) { tokens . add ( hyphen ) ; }", "fixed_code": "/ / single hyphen else if ( \" - \" . equals ( token ) ) { tokens . add ( token ) ; } else if ( token . startsWith ( \" - \" ) ) { tokens . add ( value ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_18"}
{"buggy_code": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( token ) ; } }", "fixed_code": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; }  tokens . add ( token ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_19"}
{"buggy_code": "} else { tokens . add ( \" - \" + ch ) ; } } } } \\ No newline at end of file", "fixed_code": "} else { tokens . add ( token ) ; break ; } } } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_2"}
{"buggy_code": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { if ( token . indexOf ( ' = ' ) ! = - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }", "fixed_code": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { int pos = token . indexOf ( ' = ' ) ; String opt = pos = = - 1 ? token : token . substring ( 0 , pos ) ; / / - - foo  if ( ! options . hasOption ( opt ) & & stopAtNonOption ) { process ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_20"}
{"buggy_code": "* * @ return the current option }", "fixed_code": "* * @ return the current option Option getCurrentOption ( ) ; void setCurrentOption ( Option currentOption ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_21"}
{"buggy_code": "private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { return commandLine . looksLikeOption ( trigger ) ; } }", "fixed_code": "private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { Option oldOption = commandLine . getCurrentOption ( ) ; try { commandLine . setCurrentOption ( this ) ; return commandLine . looksLikeOption ( trigger ) ; } finally { commandLine . setCurrentOption ( oldOption ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_21"}
{"buggy_code": "private final Map defaultSwitches = new HashMap ( ) ; private final List normalised ; private final Set prefixes ; public boolean looksLikeOption ( final String trigger ) { / / this is a reentrant call for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { return true ; } } return false ; } public String toString ( ) {", "fixed_code": "private final Map defaultSwitches = new HashMap ( ) ; private final List normalised ; private final Set prefixes ; private Option currentOption ; private String checkForOption ; public boolean looksLikeOption ( final String trigger ) { if ( checkForOption ! = null ) { / / this is a reentrant call return ! checkForOption . equals ( trigger ) ; } checkForOption = trigger ; try { for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { if ( getCurrentOption ( ) . canProcess ( this , trigger ) | | getCurrentOption ( ) . findOption ( trigger ) ! = null ) { return true ; } } }  return false ; } finally { checkForOption = null ; } } public String toString ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Cli_21"}
{"buggy_code": "private boolean eatTheRest ; private Options options ; if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else if ( stopAtNonOption ) { processNonOptionToken ( token ) ; } else { tokens . add ( token ) ; } gobble ( iter ) ; * * @ param value The current token private void processNonOptionToken ( String value ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; tokens . add ( value ) ; } eatTheRest = true ; } tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { Option currentOption ; for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) ) ; break ; } else", "fixed_code": "private boolean eatTheRest ; private Option currentOption ; private Options options ; if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token , stopAtNonOption ) ; } else { currentOption = options . getOption ( opt ) ; tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; * * @ param value The current token private void processNonOptionToken ( String value , boolean stopAtNonOption ) { if ( stopAtNonOption & & ( currentOption = = null | | ! currentOption . hasArg ( ) ) ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; } tokens . add ( value ) ; } eatTheRest = true ; } if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break ; } else", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_22"}
{"buggy_code": "while ( true ) { int lastPos = pos ; text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; sb . append ( text ) ; return sb ; } else if ( pos = = lastPos ) { throw new RuntimeException ( \" Text too long for line - throwing exception to avoid infinite loop [ CLI - 162 ] : \" + text ) ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;", "fixed_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; sb . append ( text ) ; return sb ; }  if ( ( text . length ( ) > width ) & & ( pos = = nextLineTabStop - 1 ) ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_23"}
{"buggy_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening throw new IllegalStateException ( \" Total width is less than the width of the argument and indent \" + \" - no room for the description \" ) ; } / / all following lines must be padded with nextLineTabStop space", "fixed_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = width - 1 ; } / / all following lines must be padded with nextLineTabStop space", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_24"}
{"buggy_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = width - 1 ; } / / all following lines must be padded with nextLineTabStop space", "fixed_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = 1 ; } / / all following lines must be padded with nextLineTabStop space", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_25"}
{"buggy_code": "public static Option create ( String opt ) throws IllegalArgumentException { / / create the option Option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; / / return the Option instance return option ;", "fixed_code": "public static Option create ( String opt ) throws IllegalArgumentException { Option option = null ; try { / / create the option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } finally { / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; } / / return the Option instance return option ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_26"}
{"buggy_code": "/ / if no option has already been selected or the / / same option is being reselected then set the / / selected member variable if ( selected = = null | | selected . equals ( option . getOpt ( ) ) ) { selected = option . getOpt ( ) ; } else {", "fixed_code": "/ / if no option has already been selected or the / / same option is being reselected then set the / / selected member variable if ( selected = = null | | selected . equals ( option . getKey ( ) ) ) { selected = option . getKey ( ) ; } else {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_27"}
{"buggy_code": "{ / / if the value is not yes , true or 1 then don ' t add the / / option to the CommandLine break ; } cmd . addOption ( opt ) ;", "fixed_code": "{ / / if the value is not yes , true or 1 then don ' t add the / / option to the CommandLine continue ; } cmd . addOption ( opt ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_28"}
{"buggy_code": "static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( \" \\ \" \" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } int length = str . length ( ) ; if ( str . endsWith ( \" \\ \" \" ) ) { str = str . substring ( 0 , length - 1 ) ; } return str ;", "fixed_code": "static String stripLeadingAndTrailingQuotes ( String str ) { int length = str . length ( ) ; if ( length > 1 & & str . startsWith ( \" \\ \" \" ) & & str . endsWith ( \" \\ \" \" ) & & str . substring ( 1 , length - 1 ) . indexOf ( ' \" ' ) = = - 1 ) { str = str . substring ( 1 , length - 1 ) ; } return str ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_29"}
{"buggy_code": "import java . util . Date ; import org . apache . commons . lang . math . NumberUtils ;", "fixed_code": "import java . util . Date ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_3"}
{"buggy_code": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "fixed_code": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_30"}
{"buggy_code": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties String value = properties . getProperty ( option ) ;", "fixed_code": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties String value = properties . getProperty ( option ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_30"}
{"buggy_code": "private String longOpt ; private String argName = \" arg \" ; private String description ;", "fixed_code": "private String longOpt ; private String argName ; private String description ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_31"}
{"buggy_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option", "fixed_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & ( option . getArgName ( ) = = null | | option . getArgName ( ) . length ( ) ! = 0 ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ! = null ? option . getArgName ( ) : getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_31"}
{"buggy_code": "private static void reset ( ) { description = null ; argName = \" arg \" ; longopt = null ; type = null ; required = false ;", "fixed_code": "private static void reset ( ) { description = null ; argName = null ; longopt = null ; type = null ; required = false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Cli_31"}
{"buggy_code": "/ / if we didn ' t find one , simply chop at startPos + width pos = startPos + width ; while ( ( pos < = text . length ( ) ) & & ( ( c = text . charAt ( pos ) ) ! = ' ' ) & & ( c ! = ' \\ n ' ) & & ( c ! = ' \\ r ' ) ) { + + pos ; } return pos = = text . length ( ) ? - 1 : pos ; }", "fixed_code": "/ / if we didn ' t find one , simply chop at startPos + width pos = startPos + width ;  return pos = = text . length ( ) ? - 1 : pos ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_32"}
{"buggy_code": "{ StringBuffer sb = new StringBuffer ( text . length ( ) ) ; renderWrappedText ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; } * @ param nextLineTabStop The position on the next line for the first tab . * @ param text The text to be rendered . / / cannot happen", "fixed_code": "{ StringBuffer sb = new StringBuffer ( text . length ( ) ) ; renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; } * @ param nextLineTabStop The position on the next line for the first tab . * @ param text The text to be rendered . private StringBuffer renderWrappedTextBlock ( StringBuffer sb , int width , int nextLineTabStop , String text ) { try { BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; while ( ( line = in . readLine ( ) ) ! = null ) { if ( ! firstLine ) { sb . append ( getNewLine ( ) ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } } catch ( IOException e ) { / / cannot happen } return sb ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_33"}
{"buggy_code": "private int numberOfArgs = UNINITIALIZED ; private Class type ; private List values = new ArrayList ( ) ;", "fixed_code": "private int numberOfArgs = UNINITIALIZED ; private Class type = String . class ; private List values = new ArrayList ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_34"}
{"buggy_code": "description = null ; argName = null ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ;", "fixed_code": "description = null ; argName = null ; longopt = null ; type = String . class ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_34"}
{"buggy_code": "List < String > matchingOpts = new ArrayList < String > ( ) ; / / for a perfect match return the single option only for ( String longOpt : longOpts . keySet ( ) ) {", "fixed_code": "List < String > matchingOpts = new ArrayList < String > ( ) ; / / for a perfect match return the single option only if ( longOpts . keySet ( ) . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( String longOpt : longOpts . keySet ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_35"}
{"buggy_code": "import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; private final List < Object > requiredOpts = new ArrayList < Object > ( ) ; private final Map < String , OptionGroup > optionGroups = new HashMap < String , OptionGroup > ( ) ;", "fixed_code": "import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; private final List < Object > requiredOpts = new ArrayList < Object > ( ) ; private final Map < String , OptionGroup > optionGroups = new LinkedHashMap < String , OptionGroup > ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_36"}
{"buggy_code": "import java . io . Serializable ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; private final Map < String , Option > optionMap = new HashMap < String , Option > ( ) ; private String selected ;", "fixed_code": "import java . io . Serializable ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; private final Map < String , Option > optionMap = new LinkedHashMap < String , Option > ( ) ; private String selected ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Cli_36"}
{"buggy_code": "private boolean isShortOption ( String token ) { / / short options ( - S , - SV , - S = V , - SV1 = V2 , - S1S2 ) return token . startsWith ( \" - \" ) & & token . length ( ) > = 2 & & options . hasShortOption ( token . substring ( 1 , 2 ) ) ; / / remove leading \" - \" and \" = value \" }", "fixed_code": "private boolean isShortOption ( String token ) { / / short options ( - S , - SV , - S = V , - SV1 = V2 , - S1S2 ) if ( ! token . startsWith ( \" - \" ) | | token . length ( ) = = 1 ) { return false ; } / / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_37"}
{"buggy_code": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; / / check for several concatenated short options }", "fixed_code": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { return true ; } / / check for several concatenated short options return optName . length ( ) > 0 & & options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_38"}
{"buggy_code": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { * @ return The file input stream represented by < code > str < / code > . * @ throws ParseException if the file is not exist or not readable", "fixed_code": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { * @ return The file input stream represented by < code > str < / code > . * @ throws ParseException if the file is not exist or not readable public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( \" Unable to find file : \" + str ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_39"}
{"buggy_code": "if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; / / loop through the required options", "fixed_code": "if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( \" Missing required option \" ) ; buff . append ( requiredOptions . size ( ) = = 1 ? \" \" : \" s \" ) ; buff . append ( \" : \" ) ; / / loop through the required options", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_4"}
{"buggy_code": "} else { return null ; } }", "fixed_code": "} else { throw new ParseException ( \" Unable to handle the class : \" + clazz ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_40"}
{"buggy_code": "static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( \" - - \" ) ) { return str . substring ( 2 , str . length ( ) ) ;", "fixed_code": "static String stripLeadingHyphens ( String str ) { if ( str = = null ) { return null ; } if ( str . startsWith ( \" - - \" ) ) { return str . substring ( 2 , str . length ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_5"}
{"buggy_code": "package org . apache . commons . cli2 . builder ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import org . apache . commons . cli2 . Argument ; this . abuilder = abuilder ; } private final Set options = new HashSet ( ) ;", "fixed_code": "package org . apache . commons . cli2 . builder ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . Set ; import org . apache . commons . cli2 . Argument ; this . abuilder = abuilder ; } private final Set options = new LinkedHashSet ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_7"}
{"buggy_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos = = - 1 ) {", "fixed_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; if ( pos = = - 1 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_8"}
{"buggy_code": "while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }", "fixed_code": "while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; buff . append ( \" , \" ) ; } throw new MissingOptionException ( buff . substring ( 0 , buff . length ( ) - 2 ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Cli_9"}
{"buggy_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 Node function = fnScope . getRootNode ( ) ;", "fixed_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 if ( ! removeGlobals ) { return ; } Node function = fnScope . getRootNode ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 Node function = fnScope . getRootNode ( ) ;", "fixed_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 if ( ! removeGlobals ) { return ; } Node function = fnScope . getRootNode ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_1"}
{"buggy_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_10"}
{"buggy_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return false ; }", "fixed_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; int pType = parent . getType ( ) ; if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return parent ! = null & & NodeUtil . isGet ( parent ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_100"}
{"buggy_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return false ; }", "fixed_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; int pType = parent . getType ( ) ; if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return parent ! = null & & NodeUtil . isGet ( parent ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_100"}
{"buggy_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } if ( flags . process_closure_primitives ) { options . closurePass = true ; } initOptionsFromFlags ( options ) ; return options ; }", "fixed_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } if ( flags . process_closure_primitives ) { options . closurePass = true ; } initOptionsFromFlags ( options ) ; return options ; }", "fixed_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_101"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "fixed_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; removeDuplicateDeclarations ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_102"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "fixed_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; removeDuplicateDeclarations ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_102"}
{"buggy_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . return foundType ; }", "fixed_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : case Token . INSTANCEOF : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . if ( foundType = = null ) { ObjectType maybeType = ObjectType . cast ( registry . getGreatestSubtypeWithProperty ( type , field ) ) ; / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { foundType = maybeType ; } } return foundType ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_103"}
{"buggy_code": "} / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . return foundType ; }", "fixed_code": "} / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . if ( foundType = = null ) { ObjectType maybeType = ObjectType . cast ( registry . getGreatestSubtypeWithProperty ( type , field ) ) ; / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { foundType = maybeType ; } } return foundType ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_103"}
{"buggy_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : return true ; case Token . FUNCTION : return false ;", "fixed_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : case Token . INSTANCEOF : return true ; case Token . FUNCTION : return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_103"}
{"buggy_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result ! = null ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "fixed_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( ! result . isNoType ( ) ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_104"}
{"buggy_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result ! = null ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "fixed_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( ! result . isNoType ( ) ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_104"}
{"buggy_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = new StringBuilder ( ) ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb . length ( ) > 0 ) { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "fixed_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = null ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } else { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = null ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_105"}
{"buggy_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = new StringBuilder ( ) ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb . length ( ) > 0 ) { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "fixed_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = null ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } else { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = null ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_105"}
{"buggy_code": "* @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; } / / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ;", "fixed_code": "* @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; } / / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ;", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_106"}
{"buggy_code": "* @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; }", "fixed_code": "* @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_106"}
{"buggy_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; } return options ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; } return options ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_107"}
{"buggy_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "fixed_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . private final Set < Node > injectedDecls = Sets . newHashSet ( ) ; / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; injectedDecls . clear ( ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } injectedDecls . add ( newDecl . getFirstChild ( ) ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & ! injectedDecls . contains ( n ) ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "fixed_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . private final Set < Node > injectedDecls = Sets . newHashSet ( ) ; / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; injectedDecls . clear ( ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } injectedDecls . add ( newDecl . getFirstChild ( ) ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & ! injectedDecls . contains ( n ) ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_108"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_109"}
{"buggy_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "fixed_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_11"}
{"buggy_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "fixed_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_11"}
{"buggy_code": "return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ; Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \"", "fixed_code": "return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ; Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \"", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_110"}
{"buggy_code": "return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "fixed_code": "return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_110"}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \"", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \"", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_110"}
{"buggy_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType ; } @ Override", "fixed_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType . isAllType ( ) ? getNativeType ( ARRAY_TYPE ) : topType ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_111"}
{"buggy_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType ; } @ Override", "fixed_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType . isAllType ( ) ? getNativeType ( ARRAY_TYPE ) : topType ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_111"}
{"buggy_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = inferTemplateTypesFromParameters ( fnType , n ) ;  / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "fixed_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = Maps . filterKeys ( inferTemplateTypesFromParameters ( fnType , n ) , new Predicate < TemplateType > ( ) {  @ Override public boolean apply ( TemplateType key ) { return keys . contains ( key ) ; } } ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = inferTemplateTypesFromParameters ( fnType , n ) ;  / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "fixed_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = Maps . filterKeys ( inferTemplateTypesFromParameters ( fnType , n ) , new Predicate < TemplateType > ( ) {  @ Override public boolean apply ( TemplateType key ) { return keys . contains ( key ) ; } } ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_112"}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null | | requiresLevel . isOn ( ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_113"}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null | | requiresLevel . isOn ( ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_113"}
{"buggy_code": "} else { recordDepScope ( nameNode , ns ) ; } } else { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "fixed_code": "} else { recordDepScope ( nameNode , ns ) ; } } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "} else { recordDepScope ( nameNode , ns ) ; } } else { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "fixed_code": "} else { recordDepScope ( nameNode , ns ) ; } } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_114"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; / / empty function case if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; / / empty function case if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_116"}
{"buggy_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { / / The best type name is the actual type name . / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "fixed_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } / / The best type name is the actual type name . if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { / / The best type name is the actual type name . / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "fixed_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } / / The best type name is the actual type name . if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_117"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ; if ( errors . size ( ) > MAX_INVALDIATION_WARNINGS_PER_PROPERTY ) { return ; }  log . err ( \" at \" + error . sourceName + \" : \" + error . lineNumber ) / / errors . add ( / / t . toString ( ) + \" at \" + error . sourceName + \" : \" + error . lineNumber ) ; }", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ; if ( errors . size ( ) > MAX_INVALDIATION_WARNINGS_PER_PROPERTY ) { return ; } log . err ( \" at \" + error . sourceName + \" : \" + error . lineNumber ) / / errors . add ( / / t . toString ( ) + \" at \" + error . sourceName + \" : \" + error . lineNumber ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_118"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_118"}
{"buggy_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . INC : case Token . DEC : isSet = true ;", "fixed_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . CATCH : case Token . INC : case Token . DEC : isSet = true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . INC : case Token . DEC : isSet = true ;", "fixed_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . CATCH : case Token . INC : case Token . DEC : isSet = true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_119"}
{"buggy_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { return false ; }", "fixed_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( cfgNode ) ; for ( DiGraphEdge < Node , Branch > edge : branchEdges ) { if ( edge . getValue ( ) = = Branch . ON_EX ) { return true ; } } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { return false ; }", "fixed_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( cfgNode ) ; for ( DiGraphEdge < Node , Branch > edge : branchEdges ) { if ( edge . getValue ( ) = = Branch . ON_EX ) { return true ; } } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_12"}
{"buggy_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ;", "fixed_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { if ( ref . getSymbol ( ) . getScope ( ) ! = ref . scope ) { return false ; } break ; } else if ( block . isLoop ) { return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ;", "fixed_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { if ( ref . getSymbol ( ) . getScope ( ) ! = ref . scope ) { return false ; } break ; } else if ( block . isLoop ) { return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_120"}
{"buggy_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "fixed_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) & & / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . ( isInlineableDeclaredConstant ( v , referenceInfo ) | | referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "fixed_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) & & / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . ( isInlineableDeclaredConstant ( v , referenceInfo ) | | referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_121"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_122"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_123"}
{"buggy_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "fixed_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; while ( node . isGetProp ( ) ) { node = node . getFirstChild ( ) ; } if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "fixed_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; while ( node . isGetProp ( ) ) { node = node . getFirstChild ( ) ; } if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_124"}
{"buggy_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "fixed_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "fixed_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_125"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } } } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough & & ! inFinally ( n . getParent ( ) , n ) ) { removeNode ( n ) ; } } } } private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } } } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough & & ! inFinally ( n . getParent ( ) , n ) ) { removeNode ( n ) ; } } } } private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_127"}
{"buggy_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; if ( len = = 0 ) { return false ; } for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_128"}
{"buggy_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; if ( len = = 0 ) { return false ; } for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_128"}
{"buggy_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "fixed_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . while ( first . isCast ( ) ) { first = first . getFirstChild ( ) ; } if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "fixed_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . while ( first . isCast ( ) ) { first = first . getFirstChild ( ) ; } if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_129"}
{"buggy_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; }", "fixed_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { Node next = c . getNext ( ) ; traverse ( c ) ; c = next ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_13"}
{"buggy_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; }", "fixed_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { Node next = c . getNext ( ) ; traverse ( c ) ; c = next ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_13"}
{"buggy_code": "continue ; } if ( name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "fixed_code": "continue ; } if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "continue ; } if ( name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "fixed_code": "continue ; } if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_130"}
{"buggy_code": "int length = s . length ( ) ; if ( length = = 0 | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "fixed_code": "int length = s . length ( ) ; if ( length = = 0 | | Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_131"}
{"buggy_code": "int length = s . length ( ) ; if ( length = = 0 | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "fixed_code": "int length = s . length ( ) ; if ( length = = 0 | | Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_131"}
{"buggy_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "fixed_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_132"}
{"buggy_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "fixed_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_132"}
{"buggy_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; return result ; }", "fixed_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; unreadToken = NO_UNREAD_TOKEN ; return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; return result ; }", "fixed_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; unreadToken = NO_UNREAD_TOKEN ; return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_133"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_14"}
{"buggy_code": "return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "fixed_code": "return true ; } if ( n . isDelProp ( ) ) { return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "fixed_code": "return true ; } if ( n . isDelProp ( ) ) { return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_15"}
{"buggy_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final String aliasName ; AliasedTypeNode ( Node typeReference , String aliasName ) { this . typeReference = typeReference ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { typeReference . setString ( aliasName ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; } }", "fixed_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final Node aliasDefinition ; private final String aliasName ; AliasedTypeNode ( Node typeReference , Node aliasDefinition , String aliasName ) { this . typeReference = typeReference ; this . aliasDefinition = aliasDefinition ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { String typeName = typeReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_16"}
{"buggy_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final String aliasName ; AliasedTypeNode ( Node typeReference , String aliasName ) { this . typeReference = typeReference ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { typeReference . setString ( aliasName ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; } }", "fixed_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final Node aliasDefinition ; private final String aliasName ; AliasedTypeNode ( Node typeReference , Node aliasDefinition , String aliasName ) { this . typeReference = typeReference ; this . aliasDefinition = aliasDefinition ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { String typeName = typeReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_16"}
{"buggy_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "fixed_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_17"}
{"buggy_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "fixed_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_17"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_18"}
{"buggy_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; / / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "fixed_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; case Token . THIS : / / \" this \" references aren ' t currently modeled in the CFG . break ; default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; / / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "fixed_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; case Token . THIS : / / \" this \" references aren ' t currently modeled in the CFG . break ; default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_19"}
{"buggy_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "fixed_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; if ( implicitProto = = null ) { / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = ImmutableSet . of ( ) ; } else { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; } for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "fixed_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; if ( implicitProto = = null ) { / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = ImmutableSet . of ( ) ; } else { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; } for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_2"}
{"buggy_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "fixed_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null & & value . getNext ( ) = = null & & NodeUtil . isImmutableValue ( value ) ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_20"}
{"buggy_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "fixed_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null & & value . getNext ( ) = = null & & NodeUtil . isImmutableValue ( value ) ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_20"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( parent . getType ( ) = = Token . COMMA ) { if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } } if ( ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( parent . getType ( ) = = Token . COMMA ) { if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } } if ( ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else { return ; } } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } else if ( n . isExprResult ( ) ) { return ; } String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else { return ; } } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } else if ( n . isExprResult ( ) ) { return ; } String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_22"}
{"buggy_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "fixed_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_23"}
{"buggy_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "fixed_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_23"}
{"buggy_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) ) { if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } }", "fixed_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) & & n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_24"}
{"buggy_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) ) { if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } }", "fixed_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) & & n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_24"}
{"buggy_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; } } } n . setJSType ( type ) ; for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { scope = traverse ( arg , scope ) ; } return scope ; }", "fixed_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { scope = traverseChildren ( n , scope ) ; Node constructor = n . getFirstChild ( ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; backwardsInferenceFromCallSite ( n , ct ) ; } } } n . setJSType ( type ) ; return scope ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_25"}
{"buggy_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; } } } n . setJSType ( type ) ; for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { scope = traverse ( arg , scope ) ; } return scope ; }", "fixed_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { scope = traverseChildren ( n , scope ) ; Node constructor = n . getFirstChild ( ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; backwardsInferenceFromCallSite ( n , ct ) ; } } } n . setJSType ( type ) ; return scope ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_25"}
{"buggy_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; }", "fixed_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; private Set < String > modulesWithExports = Sets . newHashSet ( ) ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { if ( ! modulesWithExports . contains ( moduleName ) ) { return ; } Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; modulesWithExports . add ( moduleName ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; }", "fixed_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; private Set < String > modulesWithExports = Sets . newHashSet ( ) ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { if ( ! modulesWithExports . contains ( moduleName ) ) { return ; } Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; modulesWithExports . add ( moduleName ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_26"}
{"buggy_code": "return block ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isLabelName ( ) ) ; Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "fixed_code": "return block ; } private static Node blockUnchecked ( Node stmt ) { return new Node ( Token . BLOCK , stmt ) ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( finallyBody . isBlock ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_27"}
{"buggy_code": "return block ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isLabelName ( ) ) ; Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "fixed_code": "return block ; } private static Node blockUnchecked ( Node stmt ) { return new Node ( Token . BLOCK , stmt ) ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( finallyBody . isBlock ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_27"}
{"buggy_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . } }", "fixed_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . @ Override void addConstant ( String newcode ) { add ( \" 0 \" ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_28"}
{"buggy_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . } }", "fixed_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . @ Override void addConstant ( String newcode ) { add ( \" 0 \" ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_28"}
{"buggy_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . continue ; } return false ; } Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "fixed_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; Set < String > validProperties = Sets . newHashSet ( ) ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . String propName = parent . getLastChild ( ) . getString ( ) ; if ( ! validProperties . contains ( propName ) ) { if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , gramps ) ) { validProperties . add ( propName ) ; } else { return false ; } } continue ; } return false ; } validProperties . add ( child . getString ( ) ) ; Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_29"}
{"buggy_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . continue ; } return false ; } Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "fixed_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; Set < String > validProperties = Sets . newHashSet ( ) ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . String propName = parent . getLastChild ( ) . getString ( ) ; if ( ! validProperties . contains ( propName ) ) { if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , gramps ) ) { validProperties . add ( propName ) ; } else { return false ; } } continue ; } return false ; } validProperties . add ( child . getString ( ) ) ; Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_29"}
{"buggy_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; }", "fixed_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; }", "fixed_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_3"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "fixed_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; private boolean unknownDependencies = false ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_30"}
{"buggy_code": "private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "fixed_code": "private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; private boolean unknownDependencies = false ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_30"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } @ Override", "fixed_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_30"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_31"}
{"buggy_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; / / All tokens must be separated by a space . if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } if ( builder . length ( ) > 0 ) { builder . append ( ' ' ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "fixed_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . int lineStartChar = - 1 ; do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . lineStartChar = stream . getCharno ( ) + 1 ; } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; lineStartChar = 0 ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; boolean isEOC = token = = JsDocToken . EOC ; if ( ! isEOC ) { if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { int numSpaces = stream . getCharno ( ) - lineStartChar ; for ( int i = 0 ; i < numSpaces ; i + + ) { builder . append ( ' ' ) ; } lineStartChar = - 1 ; } else if ( builder . length ( ) > 0 ) { / / All tokens must be separated by a space . builder . append ( ' ' ) ; } } if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_32"}
{"buggy_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; / / All tokens must be separated by a space . if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } if ( builder . length ( ) > 0 ) { builder . append ( ' ' ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "fixed_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . int lineStartChar = - 1 ; do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . lineStartChar = stream . getCharno ( ) + 1 ; } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; lineStartChar = 0 ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; boolean isEOC = token = = JsDocToken . EOC ; if ( ! isEOC ) { if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { int numSpaces = stream . getCharno ( ) - lineStartChar ; for ( int i = 0 ; i < numSpaces ; i + + ) { builder . append ( ' ' ) ; } lineStartChar = - 1 ; } else if ( builder . length ( ) > 0 ) { / / All tokens must be separated by a space . builder . append ( ' ' ) ; } } if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_32"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( hasReferenceName ( ) ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( hasReferenceName ( ) ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_33"}
{"buggy_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_34"}
{"buggy_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; }", "fixed_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_34"}
{"buggy_code": "@ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "@ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_34"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! objType . isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! objType . hasProperty ( prop ) ) { typeToInfer = getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; } objType . defineInferredProperty ( prop , typeToInfer , null ) ; } } } } }", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null ) { type . matchConstraint ( constraintObj ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! objType . isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! objType . hasProperty ( prop ) ) { typeToInfer = getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; } objType . defineInferredProperty ( prop , typeToInfer , null ) ; } } } } }", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null ) { type . matchConstraint ( constraintObj ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_35"}
{"buggy_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . } }", "fixed_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . if ( convention . getSingletonGetterClassName ( callNode ) ! = null ) { return false ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_36"}
{"buggy_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . } }", "fixed_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . if ( convention . getSingletonGetterClassName ( callNode ) ! = null ) { return false ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_36"}
{"buggy_code": "node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ; / / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "fixed_code": "node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ; / / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_37"}
{"buggy_code": "node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_37"}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_37"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_38"}
{"buggy_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return \" { . . . } \" ; } }", "fixed_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; + i ; if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return forAnnotations ? \" ? \" : \" { . . . } \" ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_39"}
{"buggy_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return \" { . . . } \" ; } }", "fixed_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; + i ; if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return forAnnotations ? \" ? \" : \" { . . . } \" ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_39"}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_4"}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_4"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } } }", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } } }", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_40"}
{"buggy_code": "} / / Clone any remaining params that aren ' t in the function literal . parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "fixed_code": "} / / Clone any remaining params that aren ' t in the function literal . while ( oldParams . hasNext ( ) ) { paramBuilder . newParameterFromNode ( oldParams . next ( ) ) ; } parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( ! isVarArgs ) { while ( oldParameterType ! = null & & ! isVarArgs ) { builder . newParameterFromNode ( oldParameterType ) ; oldParameterType = oldParameterType . getNext ( ) ; } } if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_41"}
{"buggy_code": "} / / Clone any remaining params that aren ' t in the function literal . parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "fixed_code": "} / / Clone any remaining params that aren ' t in the function literal . while ( oldParams . hasNext ( ) ) { paramBuilder . newParameterFromNode ( oldParams . next ( ) ) ; } parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( ! isVarArgs ) { while ( oldParameterType ! = null & & ! isVarArgs ) { builder . newParameterFromNode ( oldParameterType ) ; oldParameterType = oldParameterType . getNext ( ) ; } } if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_41"}
{"buggy_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "fixed_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { if ( loopNode . isForEach ( ) ) { errorReporter . error ( \" unsupported language extension : for each \" , sourceName , loopNode . getLineno ( ) , \" \" , 0 ) ; / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . EXPR_RESULT , Node . newNumber ( 0 ) ) ; } return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_42"}
{"buggy_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "fixed_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { if ( loopNode . isForEach ( ) ) { errorReporter . error ( \" unsupported language extension : for each \" , sourceName , loopNode . getLineno ( ) , \" \" , 0 ) ; / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . EXPR_RESULT , Node . newNumber ( 0 ) ) ; } return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_42"}
{"buggy_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314", "fixed_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314 private List < Node > lentObjectLiterals = null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_43"}
{"buggy_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314", "fixed_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314 private List < Node > lentObjectLiterals = null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_43"}
{"buggy_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / } append ( newcode ) ;", "fixed_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; } else if ( c = = ' / ' & & getLastChar ( ) = = ' / ' ) { / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / append ( \" \" ) ; } append ( newcode ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_44"}
{"buggy_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / } append ( newcode ) ;", "fixed_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; } else if ( c = = ' / ' & & getLastChar ( ) = = ' / ' ) { / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / append ( \" \" ) ; } append ( newcode ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_44"}
{"buggy_code": "assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "fixed_code": "assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "fixed_code": "assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_45"}
{"buggy_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_46"}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_47"}
{"buggy_code": "/ / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "fixed_code": "/ / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_47"}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; }", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_47"}
{"buggy_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred ) { / / Determining declaration for # 2 inferred = ! ( rhsValue ! = null & & rhsValue . isFunction ( ) & & ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; } if ( ! inferred ) {", "fixed_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { / / Determining declaration for # 2 if ( info ! = null ) { inferred = false ; } else if ( ! scope . isDeclared ( qName , false ) & & n . isUnscopedQualifiedName ( ) ) { inferred = false ; } } if ( ! inferred ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred ) { / / Determining declaration for # 2 inferred = ! ( rhsValue ! = null & & rhsValue . isFunction ( ) & & ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; } if ( ! inferred ) {", "fixed_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { / / Determining declaration for # 2 if ( info ! = null ) { inferred = false ; } else if ( ! scope . isDeclared ( qName , false ) & & n . isUnscopedQualifiedName ( ) ) { inferred = false ; } } if ( ! inferred ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_48"}
{"buggy_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) = = Token . FUNCTION ) { for ( Node c = declarationRoot . getFirstChild ( ) . getNext ( ) . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } Node functionBody = declarationRoot . getLastChild ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; } else if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } / / Add the function parameters / / Add the function body declarations nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . case Token . CATCH : / / Remove catch except name from the stack of names .", "fixed_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } nameStack . push ( renamer ) ; } break ; case Token . LP : { Renamer renamer = nameStack . peek ( ) . forChildScope ( ) ; / / Add the function parameters for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } / / Add the function body declarations Node functionBody = n . getNext ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope nameStack . pop ( ) ; / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; case Token . LP : / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . break ; case Token . CATCH : / / Remove catch except name from the stack of names .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_49"}
{"buggy_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) = = Token . FUNCTION ) { for ( Node c = declarationRoot . getFirstChild ( ) . getNext ( ) . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } Node functionBody = declarationRoot . getLastChild ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; } else if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } / / Add the function parameters / / Add the function body declarations nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . case Token . CATCH : / / Remove catch except name from the stack of names .", "fixed_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } nameStack . push ( renamer ) ; } break ; case Token . LP : { Renamer renamer = nameStack . peek ( ) . forChildScope ( ) ; / / Add the function parameters for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } / / Add the function body declarations Node functionBody = n . getNext ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope nameStack . pop ( ) ; / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; case Token . LP : / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . break ; case Token . CATCH : / / Remove catch except name from the stack of names .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_49"}
{"buggy_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "fixed_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . if ( gramps . isDelProp ( ) ) { return false ; } / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_5"}
{"buggy_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "fixed_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . if ( gramps . isDelProp ( ) ) { return false ; } / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_5"}
{"buggy_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "fixed_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_50"}
{"buggy_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "fixed_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_50"}
{"buggy_code": "add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ;", "fixed_code": "add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_51"}
{"buggy_code": "add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; } } static boolean isWordChar ( char ch ) {", "fixed_code": "add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; } } static boolean isNegativeZero ( double x ) { return x = = 0 . 0 & & Math . copySign ( 1 , x ) = = - 1 . 0 ; } static boolean isWordChar ( char ch ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_51"}
{"buggy_code": "return false ; } } return len > 0 ; } static double getSimpleNumber ( String s ) {", "fixed_code": "return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_52"}
{"buggy_code": "return false ; } } return len > 0 ; } static double getSimpleNumber ( String s ) {", "fixed_code": "return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_52"}
{"buggy_code": "} Node replacement ; / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "fixed_code": "} Node replacement ; if ( nodes . isEmpty ( ) ) { replacement = new Node ( Token . TRUE ) ; } else { / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; } Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_53"}
{"buggy_code": "} Node replacement ; / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "fixed_code": "} Node replacement ; if ( nodes . isEmpty ( ) ) { replacement = new Node ( Token . TRUE ) ; } else { / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; } Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_53"}
{"buggy_code": "/ / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | baseType . isUnknownType ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } boolean replacedPrototype = prototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ; / / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression ,", "fixed_code": "/ / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } PrototypeObjectType oldPrototype = this . prototype ; boolean replacedPrototype = oldPrototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; if ( oldPrototype ! = null ) { / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . oldPrototype . setOwnerFunction ( null ) ; } if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ; / / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; if ( qVarType ! = null & & rhsValue ! = null & & rhsValue . getType ( ) = = Token . OBJECTLIT ) { typeRegistry . resetImplicitPrototype ( rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; } else if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_54"}
{"buggy_code": "/ / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | baseType . isUnknownType ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } boolean replacedPrototype = prototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "fixed_code": "/ / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } PrototypeObjectType oldPrototype = this . prototype ; boolean replacedPrototype = oldPrototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; if ( oldPrototype ! = null ) { / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . oldPrototype . setOwnerFunction ( null ) ; } if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_54"}
{"buggy_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression ,", "fixed_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; if ( qVarType ! = null & & rhsValue ! = null & & rhsValue . getType ( ) = = Token . OBJECTLIT ) { typeRegistry . resetImplicitPrototype ( rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; } else if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression ,", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_54"}
{"buggy_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "fixed_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "fixed_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_55"}
{"buggy_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "fixed_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_56"}
{"buggy_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "fixed_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_56"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_57"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_57"}
{"buggy_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "fixed_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } if ( NodeUtil . isName ( lhs ) ) { addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; } else { computeGenKill ( lhs , gen , kill , conditional ) ; } computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_58"}
{"buggy_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "fixed_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } if ( NodeUtil . isName ( lhs ) ) { addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; } else { computeGenKill ( lhs , gen , kill , conditional ) ; } computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_58"}
{"buggy_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "fixed_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) & & ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "fixed_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) & & ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_59"}
{"buggy_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; } return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "fixed_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { mismatch ( t , n , msg , rightType , leftType ) ; return false ; } return true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; } return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "fixed_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { mismatch ( t , n , msg , rightType , leftType ) ; return false ; } return true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_6"}
{"buggy_code": "/ / ignoring side - effects return TernaryValue . TRUE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : return TernaryValue . FALSE ; case Token . NAME : String name = n . getString ( ) ;", "fixed_code": "/ / ignoring side - effects return TernaryValue . TRUE ; case Token . VOID : return TernaryValue . FALSE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { return TernaryValue . FALSE ; } break ; case Token . NAME : String name = n . getString ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_60"}
{"buggy_code": "/ / ignoring side - effects return TernaryValue . TRUE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : return TernaryValue . FALSE ; case Token . NAME : String name = n . getString ( ) ;", "fixed_code": "/ / ignoring side - effects return TernaryValue . TRUE ; case Token . VOID : return TernaryValue . FALSE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { return TernaryValue . FALSE ; } break ; case Token . NAME : String name = n . getString ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_60"}
{"buggy_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "fixed_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; if ( namespaceName . equals ( \" Math \" ) ) { return false ; } } if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "fixed_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; if ( namespaceName . equals ( \" Math \" ) ) { return false ; } } if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_61"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null ) ; } private String toSource ( Node n , SourceMap sourceMap ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "fixed_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null , true ) ; } private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( firstOutput & & options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null ) ; } private String toSource ( Node n , SourceMap sourceMap ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "fixed_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null , true ) ; } private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( firstOutput & & options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_64"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 000 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_65"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 000 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_65"}
{"buggy_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; / / Object literal keys are not typeable } break ;", "fixed_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; } else { / / Object literal keys are not typeable typeable = false ; } break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; / / Object literal keys are not typeable } break ;", "fixed_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; } else { / / Object literal keys are not typeable typeable = false ; } break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_66"}
{"buggy_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "fixed_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "fixed_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_67"}
{"buggy_code": "} break ; } token = eatTokensUntilEOL ( ) ; } continue retry ; } } } } return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "fixed_code": "} break ; } } token = eatTokensUntilEOL ( ) ; continue retry ; } } } } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "} break ; } token = eatTokensUntilEOL ( ) ; } continue retry ; } } } } return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "fixed_code": "} break ; } } token = eatTokensUntilEOL ( ) ; continue retry ; } } } } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_68"}
{"buggy_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "fixed_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . if ( functionType . isOrdinaryFunction ( ) & & ! functionType . getTypeOfThis ( ) . isUnknownType ( ) & & ! functionType . getTypeOfThis ( ) . isNativeObjectType ( ) & & ! ( child . getType ( ) = = Token . GETELEM | | child . getType ( ) = = Token . GETPROP ) ) { report ( t , n , EXPECTED_THIS_TYPE , functionType . toString ( ) ) ; } visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_69"}
{"buggy_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "fixed_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . if ( functionType . isOrdinaryFunction ( ) & & ! functionType . getTypeOfThis ( ) . isUnknownType ( ) & & ! functionType . getTypeOfThis ( ) . isNativeObjectType ( ) & & ! ( child . getType ( ) = = Token . GETELEM | | child . getType ( ) = = Token . GETPROP ) ) { report ( t , n , EXPECTED_THIS_TYPE , functionType . toString ( ) ) ; } visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_69"}
{"buggy_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; / / Objects are restricted to \" Function \" , subtypes are left / / Only filter out subtypes of \" function \" } return matchesExpectation ( \" object \" ) ? type : null ; }", "fixed_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; if ( resultEqualsValue ) { / / Objects are restricted to \" Function \" , subtypes are left return ctorType . getGreatestSubtype ( type ) ; } else { / / Only filter out subtypes of \" function \" return type . isSubtype ( ctorType ) ? null : type ; } } return matchesExpectation ( \" object \" ) ? type : null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; / / Objects are restricted to \" Function \" , subtypes are left / / Only filter out subtypes of \" function \" } return matchesExpectation ( \" object \" ) ? type : null ; }", "fixed_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; if ( resultEqualsValue ) { / / Objects are restricted to \" Function \" , subtypes are left return ctorType . getGreatestSubtype ( type ) ; } else { / / Only filter out subtypes of \" function \" return type . isSubtype ( ctorType ) ? null : type ; } } return matchesExpectation ( \" object \" ) ? type : null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_7"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_70"}
{"buggy_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = t . inGlobalScope ( ) & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "fixed_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = parent . getJSDocInfo ( ) ! = null & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_71"}
{"buggy_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = t . inGlobalScope ( ) & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "fixed_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = parent . getJSDocInfo ( ) ! = null & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_71"}
{"buggy_code": "String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name . \" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } static class LabelNameSupplier implements Supplier < String > {", "fixed_code": "String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name . \" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } static class LabelNameSupplier implements Supplier < String > {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_72"}
{"buggy_code": "String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_72"}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } static class LabelNameSupplier implements Supplier < String > {", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } static class LabelNameSupplier implements Supplier < String > {", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_72"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_73"}
{"buggy_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = left . getType ( ) ; int rhType = right . getType ( ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "fixed_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = getNormalizedNodeType ( left ) ; int rhType = getNormalizedNodeType ( right ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) { private int getNormalizedNodeType ( Node n ) { int type = n . getType ( ) ; if ( type = = Token . NOT ) { TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; switch ( value ) { case TRUE : return Token . TRUE ; case FALSE : return Token . FALSE ; } } return type ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_74"}
{"buggy_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = left . getType ( ) ; int rhType = right . getType ( ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "fixed_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = getNormalizedNodeType ( left ) ; int rhType = getNormalizedNodeType ( right ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) { private int getNormalizedNodeType ( Node n ) { int type = n . getType ( ) ; if ( type = = Token . NOT ) { TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; switch ( value ) { case TRUE : return Token . TRUE ; case FALSE : return Token . FALSE ; } } return type ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_74"}
{"buggy_code": "} static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "} static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "} static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "} static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_75"}
{"buggy_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( sibling ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } } } } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : / / With a AND / OR the first branch always runs , but the second is / / may not . case Token . HOOK : return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( child ) ) { / / Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } } return VariableLiveness . MAYBE_LIVE ;", "fixed_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . if ( n . getNext ( ) ! = null ) { state = isVariableReadBeforeKill ( n . getNext ( ) , variable ) ; if ( state = = VariableLiveness . KILL ) { state = VariableLiveness . MAYBE_LIVE ; } } break ; case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . if ( n . getNext ( ) ! = null & & n . getNext ( ) . getNext ( ) ! = null ) { state = checkHookBranchReadBeforeKill ( n . getNext ( ) , n . getNext ( ) . getNext ( ) , variable ) ; } break ; default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { break ; } } } / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) { / / Not a FUNCTION return VariableLiveness . MAYBE_LIVE ; } if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : VariableLiveness v1 = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; VariableLiveness v2 = isVariableReadBeforeKill ( n . getLastChild ( ) , variable ) ; / / With a AND / OR the first branch always runs , but the second is / / may not . if ( v1 ! = VariableLiveness . MAYBE_LIVE ) { return v1 ; } else if ( v2 = = VariableLiveness . READ ) { return VariableLiveness . READ ; } else { return VariableLiveness . MAYBE_LIVE ; } case Token . HOOK : VariableLiveness first = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; if ( first ! = VariableLiveness . MAYBE_LIVE ) { return first ; } return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } return VariableLiveness . MAYBE_LIVE ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( sibling ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } } } } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : / / With a AND / OR the first branch always runs , but the second is / / may not . case Token . HOOK : return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( child ) ) { / / Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } } return VariableLiveness . MAYBE_LIVE ;", "fixed_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . if ( n . getNext ( ) ! = null ) { state = isVariableReadBeforeKill ( n . getNext ( ) , variable ) ; if ( state = = VariableLiveness . KILL ) { state = VariableLiveness . MAYBE_LIVE ; } } break ; case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . if ( n . getNext ( ) ! = null & & n . getNext ( ) . getNext ( ) ! = null ) { state = checkHookBranchReadBeforeKill ( n . getNext ( ) , n . getNext ( ) . getNext ( ) , variable ) ; } break ; default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { break ; } } } / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) { / / Not a FUNCTION return VariableLiveness . MAYBE_LIVE ; } if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : VariableLiveness v1 = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; VariableLiveness v2 = isVariableReadBeforeKill ( n . getLastChild ( ) , variable ) ; / / With a AND / OR the first branch always runs , but the second is / / may not . if ( v1 ! = VariableLiveness . MAYBE_LIVE ) { return v1 ; } else if ( v2 = = VariableLiveness . READ ) { return VariableLiveness . READ ; } else { return VariableLiveness . MAYBE_LIVE ; } case Token . HOOK : VariableLiveness first = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; if ( first ! = VariableLiveness . MAYBE_LIVE ) { return first ; } return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } return VariableLiveness . MAYBE_LIVE ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_76"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_77"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_77"}
{"buggy_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "fixed_code": "break ; case Token . MOD : if ( rval = = 0 ) { return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { return null ; } result = lval / rval ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "fixed_code": "break ; case Token . MOD : if ( rval = = 0 ) { return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { return null ; } result = lval / rval ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_78"}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; }", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_79"}
{"buggy_code": "getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; }", "fixed_code": "getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_79"}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ;", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_79"}
{"buggy_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! blacklistedVars . contains ( var ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "fixed_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! isNamedParameter ( var ) & & ! blacklistedVars . contains ( var ) ; } } private boolean isNamedParameter ( Var v ) { return v . getParentNode ( ) . isParamList ( ) ; } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! blacklistedVars . contains ( var ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "fixed_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! isNamedParameter ( var ) & & ! blacklistedVars . contains ( var ) ; } } private boolean isNamedParameter ( Var v ) { return v . getParentNode ( ) . isParamList ( ) ; } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_8"}
{"buggy_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "fixed_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . case Token . DELPROP : return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . DELPROP : case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_80"}
{"buggy_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "fixed_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . case Token . DELPROP : return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . DELPROP : case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_80"}
{"buggy_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "fixed_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { int functionType = functionNode . getFunctionType ( ) ; if ( functionType ! = FunctionNode . FUNCTION_EXPRESSION ) { errorReporter . error ( \" unnamed function statement \" , sourceName , functionNode . getLineno ( ) , \" \" , 0 ) ; } name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_81"}
{"buggy_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "fixed_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { int functionType = functionNode . getFunctionType ( ) ; if ( functionType ! = FunctionNode . FUNCTION_EXPRESSION ) { errorReporter . error ( \" unnamed function statement \" , sourceName , functionNode . getLineno ( ) , \" \" , 0 ) ; } name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_81"}
{"buggy_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; } public boolean isNumberObjectType ( ) {", "fixed_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | ( registry . getNativeFunctionType ( JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; } public boolean isNumberObjectType ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_82"}
{"buggy_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; } public boolean isNumberObjectType ( ) {", "fixed_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | ( registry . getNativeFunctionType ( JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; } public boolean isNumberObjectType ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_82"}
{"buggy_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "fixed_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_83"}
{"buggy_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "fixed_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_83"}
{"buggy_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "fixed_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; Node target = assign . getFirstChild ( ) ; if ( ! validAssignmentTarget ( target ) ) { errorReporter . error ( \" invalid assignment target \" , sourceName , target . getLineno ( ) , \" \" , 0 ) ; } return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { if ( type = = Token . INC | | type = = Token . DEC ) { if ( ! validAssignmentTarget ( operand ) ) { String msg = ( type = = Token . INC ) ? \" invalid increment target \" : \" invalid decrement target \" ; errorReporter . error ( msg , sourceName , operand . getLineno ( ) , \" \" , 0 ) ; } } Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } private boolean validAssignmentTarget ( Node target ) { switch ( target . getType ( ) ) { case Token . NAME : case Token . GETPROP : case Token . GETELEM : return true ; } return false ; } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_84"}
{"buggy_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "fixed_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; Node target = assign . getFirstChild ( ) ; if ( ! validAssignmentTarget ( target ) ) { errorReporter . error ( \" invalid assignment target \" , sourceName , target . getLineno ( ) , \" \" , 0 ) ; } return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { if ( type = = Token . INC | | type = = Token . DEC ) { if ( ! validAssignmentTarget ( operand ) ) { String msg = ( type = = Token . INC ) ? \" invalid increment target \" : \" invalid decrement target \" ; errorReporter . error ( msg , sourceName , operand . getLineno ( ) , \" \" , 0 ) ; } } Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } private boolean validAssignmentTarget ( Node target ) { switch ( target . getType ( ) ) { case Token . NAME : case Token . GETPROP : case Token . GETELEM : return true ; } return false ; } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_84"}
{"buggy_code": "return n ; } if ( n . getParent ( ) = = null ) { List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; if ( outEdges . size ( ) = = 1 ) { return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; } } switch ( n . getType ( ) ) { case Token . BLOCK : if ( n . hasChildren ( ) ) { Node first = n . getFirstChild ( ) ; return tryRemoveUnconditionalBranching ( first ) ; } else { return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; } case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; return next ; }", "fixed_code": "return n ; } switch ( n . getType ( ) ) { case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { if ( next . hasChildren ( ) ) { next = next . getFirstChild ( ) ; } else { next = computeFollowing ( next ) ; } } return next ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_85"}
{"buggy_code": "return n ; } if ( n . getParent ( ) = = null ) { List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; if ( outEdges . size ( ) = = 1 ) { return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; } } switch ( n . getType ( ) ) { case Token . BLOCK : if ( n . hasChildren ( ) ) { Node first = n . getFirstChild ( ) ; return tryRemoveUnconditionalBranching ( first ) ; } else { return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; } case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; return next ; }", "fixed_code": "return n ; } switch ( n . getType ( ) ) { case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { if ( next . hasChildren ( ) ) { next = next . getFirstChild ( ) ; } else { next = computeFollowing ( next ) ; } } return next ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_85"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_86"}
{"buggy_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . return NodeUtil . isExpressionNode ( maybeExpr ) ; } }", "fixed_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . if ( calledFn . getType ( ) = = Token . GETELEM ) { return false ; } else if ( calledFn . getType ( ) = = Token . GETPROP & & calledFn . getLastChild ( ) . getString ( ) . startsWith ( \" on \" ) ) { return false ; } } return true ; } return false ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_87"}
{"buggy_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . return NodeUtil . isExpressionNode ( maybeExpr ) ; } }", "fixed_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . if ( calledFn . getType ( ) = = Token . GETELEM ) { return false ; } else if ( calledFn . getType ( ) = = Token . GETPROP & & calledFn . getLastChild ( ) . getString ( ) . startsWith ( \" on \" ) ) { return false ; } } return true ; } return false ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_87"}
{"buggy_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "fixed_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { Preconditions . checkState ( n . getParent ( ) . getType ( ) = = Token . ASSIGN ) ; / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . Node rhs = n . getNext ( ) ; VariableLiveness state = isVariableReadBeforeKill ( rhs , variable ) ; if ( state = = VariableLiveness . READ ) { return state ; } return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_88"}
{"buggy_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "fixed_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { Preconditions . checkState ( n . getParent ( ) . getType ( ) = = Token . ASSIGN ) ; / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . Node rhs = n . getNext ( ) ; VariableLiveness state = isVariableReadBeforeKill ( rhs , variable ) ; if ( state = = VariableLiveness . READ ) { return state ; } return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_88"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_89"}
{"buggy_code": "} / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "} / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_89"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName (", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName (", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_89"}
{"buggy_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "fixed_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . filename = filename . replace ( \" \\ \\ \" , \" / \" ) ; if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_9"}
{"buggy_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "fixed_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . filename = filename . replace ( \" \\ \\ \" , \" / \" ) ; if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_9"}
{"buggy_code": "/ / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; } / / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ;", "fixed_code": "/ / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; } / / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_90"}
{"buggy_code": "/ / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_90"}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ;", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Closure_90"}
{"buggy_code": "} / / Don ' t traverse functions that are getting lent to a prototype . } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "fixed_code": "} / / Don ' t traverse functions that are getting lent to a prototype . Node gramps = parent . getParent ( ) ; if ( NodeUtil . isObjectLitKey ( parent , gramps ) ) { JSDocInfo maybeLends = gramps . getJSDocInfo ( ) ; if ( maybeLends ! = null & & maybeLends . getLendsName ( ) ! = null & & maybeLends . getLendsName ( ) . endsWith ( \" . prototype \" ) ) { return false ; } } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_91"}
{"buggy_code": "} / / Don ' t traverse functions that are getting lent to a prototype . } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "fixed_code": "} / / Don ' t traverse functions that are getting lent to a prototype . Node gramps = parent . getParent ( ) ; if ( NodeUtil . isObjectLitKey ( parent , gramps ) ) { JSDocInfo maybeLends = gramps . getJSDocInfo ( ) ; if ( maybeLends ! = null & & maybeLends . getLendsName ( ) ! = null & & maybeLends . getLendsName ( ) . endsWith ( \" . prototype \" ) ) { return false ; } } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_91"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_92"}
{"buggy_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "fixed_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . ADD : case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : case Token . DIV : case Token . EQ : case Token . GE : case Token . GT : case Token . LE : case Token . LSH : case Token . LT : case Token . MOD : case Token . MUL : case Token . NE : case Token . RSH : case Token . SHEQ : case Token . SHNE : case Token . SUB : case Token . URSH : return isValidDefineValue ( val . getFirstChild ( ) , defines ) & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : case Token . POS : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_94"}
{"buggy_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "fixed_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . ADD : case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : case Token . DIV : case Token . EQ : case Token . GE : case Token . GT : case Token . LE : case Token . LSH : case Token . LT : case Token . MOD : case Token . MUL : case Token . NE : case Token . RSH : case Token . SHEQ : case Token . SHNE : case Token . SUB : case Token . URSH : return isValidDefineValue ( val . getFirstChild ( ) , defines ) & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : case Token . POS : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_94"}
{"buggy_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "fixed_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & isQnameRootedInGlobalScope ( n ) ) { Scope globalScope = scope . getGlobalScope ( ) ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . if ( ! globalScope . isDeclared ( variableName , false ) ) { scopeToDeclareIn = scope . getGlobalScope ( ) ; } } / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_95"}
{"buggy_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "fixed_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & isQnameRootedInGlobalScope ( n ) ) { Scope globalScope = scope . getGlobalScope ( ) ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . if ( ! globalScope . isDeclared ( variableName , false ) ) { scopeToDeclareIn = scope . getGlobalScope ( ) ; } } / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_95"}
{"buggy_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "fixed_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_96"}
{"buggy_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "fixed_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_96"}
{"buggy_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "fixed_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_97"}
{"buggy_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "fixed_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_97"}
{"buggy_code": "} / / Make sure this assignment is not in a loop . return true ; }", "fixed_code": "} / / Make sure this assignment is not in a loop . for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ; } } return true ; } private final boolean isFunction ; private final boolean isLoop ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_98"}
{"buggy_code": "} / / Make sure this assignment is not in a loop . return true ; }", "fixed_code": "} / / Make sure this assignment is not in a loop . for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ; } } return true ; } private final boolean isFunction ; private final boolean isLoop ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_98"}
{"buggy_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "fixed_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Closure_99"}
{"buggy_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "fixed_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_99"}
{"buggy_code": "} / / single character is itself if ( txt . length ( ) = = 1 ) { return txt . toUpperCase ( ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ;", "fixed_code": "} / / single character is itself if ( txt . length ( ) = = 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_1"}
{"buggy_code": "} / / 1 . Convert to lowercase txt = txt . toLowerCase ( ) ; / / 2 . Remove anything not A - Z txt = txt . replaceAll ( \" [ ^ a - z ] \" , \" \" ) ;", "fixed_code": "} / / 1 . Convert to lowercase txt = txt . toLowerCase ( java . util . Locale . ENGLISH ) ; / / 2 . Remove anything not A - Z txt = txt . replaceAll ( \" [ ^ a - z ] \" , \" \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Codec_1"}
{"buggy_code": "} } if ( count = = len ) { return str . toUpperCase ( ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "fixed_code": "} } if ( count = = len ) { return str . toUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Codec_1"}
{"buggy_code": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" ^ mb \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "fixed_code": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" mb $ \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_10"}
{"buggy_code": "private static final byte SPACE = 32 ; / / Static initializer for printable chars collection static { * the buffer to write to * @ return The number of bytes written to the < code > buffer < / code > private static final void encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; }", "fixed_code": "private static final byte SPACE = 32 ; private static final byte CR = 13 ; private static final byte LF = 10 ; private static final int SAFE_LENGTH = 73 ; / / Static initializer for printable chars collection static { * the buffer to write to * @ return The number of bytes written to the < code > buffer < / code > private static final int encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } private static int getUnsignedOctet ( final int index , final byte [ ] bytes ) { int b = bytes [ index ] ; if ( b < 0 ) { b = 256 + b ; } return b ; } private static int encodeByte ( final int b , final boolean encode , final ByteArrayOutputStream buffer ) { if ( encode ) { return encodeQuotedPrintable ( b , buffer ) ; } else { buffer . write ( b ) ; return 1 ; } } private static boolean isWhitespace ( final int b ) { return b = = SPACE | | b = = TAB ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_11"}
{"buggy_code": "* * @ throws IllegalArgumentException if the provided skip length is negative / / skip in chunks of 512 bytes / / Note : the logic is similar to the InflaterInputStream : / / as long as we have not reached EOF , indicate that there is more / / data available . As we do not know for sure how much data is left , / / just return 1 as a safe guess . / / use the EOF flag of the underlying codec instance }", "fixed_code": "* * @ throws IllegalArgumentException if the provided skip length is negative @ Override public long skip ( long n ) throws IOException { if ( n < 0 ) { throw new IllegalArgumentException ( \" Negative skip length \" ) ; } / / skip in chunks of 512 bytes final byte [ ] b = new byte [ 512 ] ; final int max = ( int ) Math . min ( n , Integer . MAX_VALUE ) ; int total = 0 ;  while ( total < max ) { int len = max - total ; if ( len > b . length ) { len = b . length ; } len = read ( b , 0 , len ) ; if ( len = = EOF ) { break ; } total + = len ; } return total ; } public int available ( ) throws IOException { / / Note : the logic is similar to the InflaterInputStream : / / as long as we have not reached EOF , indicate that there is more / / data available . As we do not know for sure how much data is left , / / just return 1 as a safe guess . / / use the EOF flag of the underlying codec instance if ( baseNCodec . eof ) { return 0 ; } else { return 1 ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_12"}
{"buggy_code": "* @ return { @ code true } if the CharSequences are equal ( case - sensitive ) , or both { @ code null } * @ since 1 . 10", "fixed_code": "* @ return { @ code true } if the CharSequences are equal ( case - sensitive ) , or both { @ code null } * @ since 1 . 10 public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 = = cs2 ) { return true ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_13"}
{"buggy_code": "import org . apache . commons . codec . EncoderException ; import org . apache . commons . codec . StringEncoder ; public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; }", "fixed_code": "import org . apache . commons . codec . EncoderException ; import org . apache . commons . codec . StringEncoder ; import org . apache . commons . codec . binary . StringUtils ; public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) { return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Codec_13"}
{"buggy_code": "", "fixed_code": "  zh polish + russian + german + english true eau french true [ aoeiu\u00e4\u00f6\u00fc ] h german true ^ vogel german , true vogel $ german true witz german true tz $ german + russian + english true ^ tz russian + english true g\u00fce spanish true g\u00fci spanish true ghe romanian true ghi romanian true vici $ romanian true schi $ romanian true chsch german true tsch german true ssch german true sch $ german + russian true ^ sch german + russian true ^ rz polish true rz $ polish + german true [ ^ aoeiu\u00e4\u00f6\u00fc ] rz polish true rz [ ^ aoeiu\u00e4\u00f6\u00fc ] polish true cki $ polish true ska $ polish true cka $ polish true ue german + russian true ae german + russian + english true oe german + french + russian + english true th $ german true ^ th german true th [ ^ aoeiu ] german true mann german true cz polish true cy polish true niew polish true stein german true heim $ german true heimer $ german true ii $ russian true iy $ russian true yy $ russian true yi $ russian true yj $ russian true ij $ russian true gaus $ russian true gauz $ russian true gauz $ russian true goltz $ russian true gol ' tz $ russian true golts $ russian true gol ' ts $ russian true ^ goltz russian true ^ gol ' tz russian true ^ golts russian true ^ gol ' ts russian true gendler $ russian true gejmer $ russian true gejm $ russian true geimer $ russian true geim $ russian true geymer russian true geym $ russian true gof $ russian true thal german true zweig german true ck $ german + english true c $ polish + romanian + hungarian true sz polish + hungarian true gue spanish + french true gui spanish + french true guy french true cs $ hungarian true ^ cs hungarian true dzs hungarian true zs $ hungarian true ^ zs hungarian true ^ wl polish true ^ wr polish + english + german true  gy $ hungarian true gy [ aeou ] hungarian true gy hungarian + russian true ly hungarian + russian + polish true ny hungarian + russian + polish true ty hungarian + russian + polish true  \u00e2 romanian + french true \u0103 romanian true \u00e0 french true \u00e4 german true \u00e1 hungarian + spanish true \u0105 polish true \u0107 polish true \u00e7 french true \u0119 polish true \u00e9 french + hungarian + spanish true \u00e8 french true \u00ea french true \u00ed hungarian + spanish true \u00ee romanian + french true \u0142 polish true \u0144 polish true \u00f1 spanish true \u00f3 polish + hungarian + spanish true \u00f6 german + hungarian true \u00f5 hungarian true \u015f romanian true \u015b polish true \u0163 romanian true \u00fc german + hungarian true \u00f9 french true \u0171 hungarian true \u00fa hungarian + spanish true \u017a polish true \u017c polish true  \u00df german true  \u0430 cyrillic true \u0451 cyrillic true \u043e cyrillic true \u0435 cyrillic true \u0438 cyrillic true \u0443 cyrillic true \u044b cyrillic true \u044d cyrillic true \u044e cyrillic true \u044f cyrillic true  \u05d0 hebrew true \u05d1 hebrew true \u05d2 ebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   a cyrillic + hebrew false o cyrillic + hebrew false e cyrillic + hebrew false i cyrillic + hebrew false y cyrillic + hebrew + romanian false u cyrillic + hebrew false  v [ ^ aoeiu\u00e4\u00fc\u00f6 ] german false / / in german \" v \" can be found before a vowel only y [ ^ aoeiu ] german false / / in german \" y \" usually appears only in the last position ; sometimes before a vowel c [ ^ aohk ] german false dzi german + english + french false ou german false aj german + english + french false ej german + english + french false oj german + english + french false uj german + english + french false k romanian false v polish false ky polish false eu russian + polish false w french + romanian + spanish + hungarian + russian false kie french + spanish false gie french + romanian + spanish false q hungarian + polish + russian + romanian false sch hungarian + polish + french + spanish false ^ h russian false", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_14"}
{"buggy_code": "import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import org . apache . commons . codec . language . bm . Languages . LanguageSet ; import org . apache . commons . codec . language . bm . Rule . Phoneme ; return phonemeBuilder ; } final Set < Rule . Phoneme > phonemes = new TreeSet < Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost phonemes . addAll ( subBuilder . getPhonemes ( ) ) ; } return new PhonemeBuilder ( phonemes ) ; }", "fixed_code": "import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import org . apache . commons . codec . language . bm . Languages . LanguageSet ; import org . apache . commons . codec . language . bm . Rule . Phoneme ; return phonemeBuilder ; } final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap < Rule . Phoneme , Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes ( ) ) { if ( phonemes . containsKey ( newPhoneme ) ) { final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages ( ) ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; } } } return new PhonemeBuilder ( phonemes . keySet ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Codec_14"}
{"buggy_code": "", "fixed_code": "  eau french true ou french true gni italian + french true tx spanish true tj spanish true gy french true guy french true  sh spanish + portuguese true / / English , but no sign for / sh / in these languages  lh portuguese true nh portuguese true ny spanish true  gue spanish + french true gui spanish + french true gia italian true gie italian true gio italian true giu italian true  \u00f1 spanish true \u00e2 portuguese + french true \u00e1 portuguese + spanish true \u00e0 portuguese true \u00e3 portuguese true \u00ea french + portuguese true \u00ed portuguese + spanish true \u00ee french true \u00f4 french + portuguese true \u00f5 portuguese true \u00f2 italian + spanish true \u00fa portuguese + spanish true \u00f9 french true \u00fc portuguese + spanish true  \u05d0 hebrew true \u05d1 hebrew true \u05d2 hebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   a hebrew false o hebrew false e hebrew false i hebrew false y hebrew false u hebrew false  kh spanish false gua italian false guo italian false \u00e7 italian false cha italian false cho italian false chu italian false j italian false dj spanish false sce french false sci french false \u00f3 french false \u00e8 portuguese false", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Codec_14"}
{"buggy_code": "private static final Map < NameType , Lang > Langs = new EnumMap < NameType , Lang > ( NameType . class ) ; private static final String LANGUAGE_RULES_RN = \" org / apache / commons / codec / language / bm / lang . txt \" ; static { for ( final NameType s : NameType . values ( ) ) { Langs . put ( s , loadFromResource ( LANGUAGE_RULES_RN , Languages . getInstance ( s ) ) ) ; } }", "fixed_code": "private static final Map < NameType , Lang > Langs = new EnumMap < NameType , Lang > ( NameType . class ) ; private static final String LANGUAGE_RULES_RN = \" org / apache / commons / codec / language / bm / % s_lang . txt \" ; static { for ( final NameType s : NameType . values ( ) ) { Langs . put ( s , loadFromResource ( String . format ( LANGUAGE_RULES_RN , s . getName ( ) ) , Languages . getInstance ( s ) ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Codec_14"}
{"buggy_code": "* @ param lang the language set to merge * @ return a new Phoneme @ Override public String toString ( ) {", "fixed_code": "* @ param lang the language set to merge * @ return a new Phoneme public Phoneme mergeWithLanguage ( final LanguageSet lang ) { return new Phoneme ( this . phonemeText . toString ( ) , this . languages . merge ( lang ) ) ; } @ Override public String toString ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "Codec_14"}
{"buggy_code": "", "fixed_code": "  ^ o \u2019 english true ^ o ' english true ^ mc english true ^ fitz english true ceau french + romanian true eau romanian true eau $ french true / / mp : I ' ve added this eaux $ french true / / mp : I ' ve added this ault $ french true oult $ french true eux $ french true eix $ french true glou $ greeklatin true uu dutch true tx spanish true witz german true tz $ german + russian + english true ^ tz russian + english true poulos $ greeklatin true pulos $ greeklatin true iou greeklatin true sj $ dutch true ^ sj dutch true g\u00fce spanish true g\u00fci spanish true ghe romanian + greeklatin true ghi romanian + greeklatin true escu $ romanian true esco $ romanian true vici $ romanian true schi $ romanian true ii $ russian true iy $ russian true yy $ russian true yi $ russian true ^ rz polish true rz $ polish + german true [ bcdfgklmnpstwz ] rz polish true rz [ bcdfghklmnpstw ] polish true cki $ polish true ska $ polish true cka $ polish true ae german + russian + english true oe german + french + russian + english + dutch true th $ german + english true ^ th german + english + greeklatin true mann german true cz polish true cy polish + greeklatin true niew polish true etti $ italian true eti $ italian true ati $ italian true ato $ italian true [ aoei ] no $ italian true [ aoei ] ni $ italian true esi $ italian true oli $ italian true field $ english true stein german true heim $ german true heimer $ german true thal german true zweig german true [ aeou ] h german true \u00e4h german true \u00f6h german true \u00fch german true [ ln ] h [ ao ] $ portuguese true [ ln ] h [ aou ] portuguese + french + german + dutch + czech + spanish + turkish true chsch german true tsch german true sch $ german + russian true ^ sch german + russian true ck $ german + english true c $ polish + romanian + hungarian + czech + turkish true sz polish + hungarian true cs $ hungarian true ^ cs hungarian true dzs hungarian true zs $ hungarian true ^ zs hungarian true ^ wl polish true ^ wr polish + english + german + dutch true  gy $ hungarian true gy [ aeou ] hungarian true gy hungarian + russian + french + greeklatin true guy french true gu [ ei ] spanish + french + portuguese true gu [ ao ] spanish + portuguese true gi [ aou ] italian + greeklatin true  ly hungarian + russian + polish + greeklatin true ny hungarian + russian + polish + spanish + greeklatin true ty hungarian + russian + polish + greeklatin true  \u0107 polish true \u00e7 french + spanish + portuguese + turkish true \u010d czech true \u010f czech true \u011f turkish true \u0142 polish true \u0144 polish true \u00f1 spanish true \u0148 czech true \u0159 czech true \u015b polish true \u015f romanian + turkish true \u0161 czech true \u0163 romanian true \u0165 czech true \u017a polish true \u017c polish true  \u00df german true  \u00e4 german true \u00e1 hungarian + spanish + portuguese + czech + greeklatin true \u00e2 romanian + french + portuguese true \u0103 romanian true \u0105 polish true \u00e0 portuguese true \u00e3 portuguese true \u0119 polish true \u00e9 french + hungarian + czech + greeklatin true \u00e8 french + spanish + italian true \u00ea french true \u011b czech true \u00ea french + portuguese true \u00ed hungarian + spanish + portuguese + czech + greeklatin true \u00ee romanian + french true \u0131 turkish true \u00f3 polish + hungarian + spanish + italian + portuguese + czech + greeklatin true \u00f6 german + hungarian + turkish true \u00f4 french + portuguese true \u00f5 portuguese + hungarian true \u00f2 italian + spanish true \u0171 hungarian true \u00fa hungarian + spanish + portuguese + czech + greeklatin true \u00fc german + hungarian + spanish + portuguese + turkish true \u00f9 french true \u016f czech true \u00fd czech + greeklatin true  \u0430 cyrillic true \u0451 cyrillic true \u043e cyrillic true \u0435 cyrillic true \u0438 cyrillic true \u0443 cyrillic true \u044b cyrillic true \u044d cyrillic true \u044e cyrillic true \u044f cyrillic true  \u03b1 greek true \u03b5 greek true \u03b7 greek true \u03b9 greek true \u03bf greek true \u03c5 greek true \u03c9 greek true  \u0627 arabic true / / alif ( isol + init ) \u0628 arabic true / / ba ' \u062a arabic true / / ta ' \u062b arabic true / / tha ' \u062c arabic true / / jim \u062d arabic true / / h . a ' \u062e ' arabic true / / kha ' \u062f arabic true / / dal ( isol + init ) \u0630 arabic true / / dhal ( isol + init ) \u0631 arabic true / / ra ' ( isol + init ) \u0632 arabic true / / za ' ( isol + init ) \u0633 arabic true / / sin \u0634 arabic true / / shin \u0635 arabic true / / s . ad \u0636 arabic true / / d . ad \u0637 arabic true / / t . a ' \u0638 arabic true / / z . a ' \u0639 arabic true / / ' ayn \u063a arabic true / / ghayn \u0641 arabic true / / fa ' \u0642 arabic true / / qaf \u0643 arabic true / / kaf \u0644 arabic true / / lam \u0645 arabic true / / mim \u0646 arabic true / / nun \u0647 arabic true / / ha ' \u0648 arabic true / / waw ( isol + init ) \u064a arabic true / / ya '  \u0622 arabic true / / alif madda \u0625 arabic true / / alif + diacritic \u0623 arabic true / / alif + hamza \u0624 arabic true / / waw + hamza \u0626 arabic true / / ya ' + hamza \u0644\u0627 arabic true / / ligature l + a  \u05d0 hebrew true \u05d1 hebrew true \u05d2 hebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   a cyrillic + hebrew + greek + arabic false o cyrillic + hebrew + greek + arabic false e cyrillic + hebrew + greek + arabic false i cyrillic + hebrew + greek + arabic false y cyrillic + hebrew + greek + arabic + romanian + dutch false u cyrillic + hebrew + greek + arabic false  j italian false j [ ^ aoeiuy ] french + spanish + portuguese + greeklatin false g czech false k romanian + spanish + portuguese + french + italian false q hungarian + polish + russian + romanian + czech + dutch + turkish + greeklatin false v polish false w french + romanian + spanish + hungarian + russian + czech + turkish + greeklatin false x czech + hungarian + dutch + turkish false / / polish excluded from the list  dj spanish + turkish false v [ ^ aoeiu ] german false / / in german , \" v \" can be found before a vowel only y [ ^ aoeiu ] german false / / in german , \" y \" usually appears only in the last position ; sometimes before a vowel c [ ^ aohk ] german false dzi german + english + french + turkish false ou german false a [ eiou ] turkish false / / no diphthongs in Turkish \u00f6 [ eaiou ] turkish false \u00fc [ eaiou ] turkish false e [ aiou ] turkish false i [ aeou ] turkish false o [ aieu ] turkish false u [ aieo ] turkish false aj german + english + french + dutch false ej german + english + french + dutch false oj german + english + french + dutch false uj german + english + french + dutch false eu russian + polish false ky polish false kie french + spanish + greeklatin false gie portuguese + romanian + spanish + greeklatin false ch [ aou ] italian false ch turkish false son $ german false sc [ ei ] french false sch hungarian + polish + french + spanish false ^ h russian false", "label": 1, "tool_name": "Developer", "patch_name": "patch6", "project_name": "Codec_14"}
{"buggy_code": "final char mappedChar = this . map ( str . charAt ( index ) ) ; / / HW rule check if ( index > 1 & & mappedChar ! = ' 0 ' ) { final char hwChar = str . charAt ( index - 1 ) ; if ( ' H ' = = hwChar | | ' W ' = = hwChar ) { final char preHWChar = str . charAt ( index - 2 ) ; final char firstCode = this . map ( preHWChar ) ; if ( firstCode = = mappedChar | | ' H ' = = preHWChar | | ' W ' = = preHWChar ) { return 0 ; } } } return mappedChar ;", "fixed_code": "final char mappedChar = this . map ( str . charAt ( index ) ) ; / / HW rule check if ( index > 1 & & mappedChar ! = ' 0 ' ) { for ( int i = index - 1 ; i > = 0 ; i - - ) { final char prevChar = str . charAt ( i ) ; if ( this . map ( prevChar ) = = mappedChar ) { return 0 ; } if ( ' H ' ! = prevChar & & ' W ' ! = prevChar ) { break ; } } } return mappedChar ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_15"}
{"buggy_code": "1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , / / 20 - 2f 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , / / 30 - 3f 2 - 7 1 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , / / 40 - 4f A - O 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , } ;", "fixed_code": "0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , / / 30 - 3f 2 - 7 25 , 26 , 27 , 28 , 29 , 30 , 31 , / / 50 - 57 P - V } ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_16"}
{"buggy_code": "* @ since As of 1 . 7 , throws { @ link NullPointerException } instead of UnsupportedEncodingException public static String newStringIso8859_1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; }", "fixed_code": "* @ since As of 1 . 7 , throws { @ link NullPointerException } instead of UnsupportedEncodingException public static String newStringIso8859_1 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . ISO_8859_1 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_17"}
{"buggy_code": "if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "fixed_code": "if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return cs1 . length ( ) = = cs2 . length ( ) & & CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_18"}
{"buggy_code": "} break ; } if ( lineLength > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "fixed_code": "} break ; } if ( lineLength > 0 & & pos > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_2"}
{"buggy_code": "if ( ( contains ( value , 0 , 4 , \" VAN \" , \" VON \" ) | | contains ( value , 0 , 3 , \" SCH \" ) ) | | contains ( value , index + 1 , 2 , \" ET \" ) ) { / / - - obvious germanic - - / / result . append ( ' K ' ) ; } else if ( contains ( value , index + 1 , 4 , \" IER \" ) ) { result . append ( ' J ' ) ; } else { result . append ( ' J ' , ' K ' ) ;", "fixed_code": "if ( ( contains ( value , 0 , 4 , \" VAN \" , \" VON \" ) | | contains ( value , 0 , 3 , \" SCH \" ) ) | | contains ( value , index + 1 , 2 , \" ET \" ) ) { / / - - obvious germanic - - / / result . append ( ' K ' ) ; } else if ( contains ( value , index + 1 , 3 , \" IER \" ) ) { result . append ( ' J ' ) ; } else { result . append ( ' J ' , ' K ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_3"}
{"buggy_code": "* < / p > public Base64 ( ) { this ( false ) ; }", "fixed_code": "* < / p > public Base64 ( ) { this ( 0 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_4"}
{"buggy_code": "/ / EOF ( - 1 ) and first time ' = ' character is encountered in stream . / / This approach makes the ' = ' padding characters completely optional . if ( eof & & modulus ! = 0 ) { x = x < < 6 ; switch ( modulus ) {", "fixed_code": "/ / EOF ( - 1 ) and first time ' = ' character is encountered in stream . / / This approach makes the ' = ' padding characters completely optional . if ( eof & & modulus ! = 0 ) { if ( buffer = = null | | buffer . length - pos < decodeSize ) { resizeBuffer ( ) ; } x = x < < 6 ; switch ( modulus ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_5"}
{"buggy_code": "} else if ( len = = 0 ) { return 0 ; } else { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } return base64 . readResults ( b , offset , len ) ; } }", "fixed_code": "} else if ( len = = 0 ) { return 0 ; } else { int readLen = 0 ; while ( readLen = = 0 ) { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } readLen = base64 . readResults ( b , offset , len ) ; } return readLen ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_6"}
{"buggy_code": "* @ since 1 . 4 public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; }", "fixed_code": "* @ since 1 . 4 public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_7"}
{"buggy_code": "if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; if ( c > 0 & & b . length = = len ) { base64 . setInitialBuffer ( b , offset , len ) ; } if ( doEncode ) { base64 . encode ( buf , 0 , c ) ; } else {", "fixed_code": "if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; if ( doEncode ) { base64 . encode ( buf , 0 , c ) ; } else {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_8"}
{"buggy_code": "return eof ? - 1 : 0 ; } void setInitialBuffer ( byte [ ] out , int outPos , int outAvail ) { if ( out ! = null & & out . length = = outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } }", "fixed_code": "return eof ? - 1 : 0 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Codec_8"}
{"buggy_code": "return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "fixed_code": "return binaryData ; } long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Codec_9"}
{"buggy_code": "public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > iterator1 , final Iterator < ? extends E > iterator2 ) { return new CollatingIterator < E > ( comparator , iterator1 , iterator2 ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > . . . iterators ) { return new CollatingIterator < E > ( comparator , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Collection < Iterator < ? extends E > > iterators ) { return new CollatingIterator < E > ( comparator , iterators ) ; } / / Object Graph", "fixed_code": "public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > iterator1 , final Iterator < ? extends E > iterator2 ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterator1 , iterator2 ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > . . . iterators ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Collection < Iterator < ? extends E > > iterators ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterators ) ; } / / Object Graph", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Collections_25"}
{"buggy_code": "* only stable for the same process ) . * @ return the instance with recalculated hash code private Object readResolve ( ) { calculateHashCode ( keys ) ; return this ; }", "fixed_code": "* only stable for the same process ) . * @ return the instance with recalculated hash code protected Object readResolve ( ) { calculateHashCode ( keys ) ; return this ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Collections_26"}
{"buggy_code": "} } } }", "fixed_code": "} } private void readObject ( ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject ( ) ; if ( clazz ! = null & & ! Collection . class . isAssignableFrom ( clazz ) ) { throw new UnsupportedOperationException ( ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Collections_27"}
{"buggy_code": "return new RangeEntryMap ( fromKey , fromInclusive , toKey , toInclusive ) ; } }", "fixed_code": "return new RangeEntryMap ( fromKey , fromInclusive , toKey , toInclusive ) ; } @ Override public void clear ( ) { Iterator < Map . Entry < K , V > > it = AbstractPatriciaTrie . this . entrySet ( ) . iterator ( ) ; Set < K > currentKeys = keySet ( ) ; while ( it . hasNext ( ) ) { if ( currentKeys . contains ( it . next ( ) . getKey ( ) ) ) { it . remove ( ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Collections_28"}
{"buggy_code": "public void close ( ) throws IOException { if ( ! this . closed ) { super . close ( ) ; this . closed = true ; }", "fixed_code": "public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; super . close ( ) ; this . closed = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_1"}
{"buggy_code": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order for ( ZipArchiveEntry ze : entries . keySet ( ) ) { OffsetEntry offsetEntry = entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } } }", "fixed_code": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order Map < ZipArchiveEntry , OffsetEntry > origMap = new LinkedHashMap < ZipArchiveEntry , OffsetEntry > ( entries ) ; entries . clear ( ) ; for ( ZipArchiveEntry ze : origMap . keySet ( ) ) { OffsetEntry offsetEntry = origMap . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } entries . put ( ze , offsetEntry ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_10"}
{"buggy_code": "return new TarArchiveInputStream ( in ) ; } / / COMPRESS - 117 - improve auto - recognition try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; tais . getNextEntry ( ) ; / / autodetection , simply not a TAR / / ignored } } catch ( IOException e ) { throw new ArchiveException ( \" Could not use reset and mark operations . \" , e ) ; }", "fixed_code": "return new TarArchiveInputStream ( in ) ; } / / COMPRESS - 117 - improve auto - recognition if ( signatureLength > = 512 ) { try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; tais . getNextEntry ( ) ; / / autodetection , simply not a TAR / / ignored } } } catch ( IOException e ) { throw new ArchiveException ( \" Could not use reset and mark operations . \" , e ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_11"}
{"buggy_code": "return null ; } currEntry = new TarArchiveEntry ( headerBuf ) ; entryOffset = 0 ; entrySize = currEntry . getSize ( ) ;", "fixed_code": "return null ; } try { currEntry = new TarArchiveEntry ( headerBuf ) ; } catch ( IllegalArgumentException e ) { IOException ioe = new IOException ( \" Error detected parsing the header \" ) ; ioe . initCause ( e ) ; throw ioe ; } entryOffset = 0 ; entrySize = currEntry . getSize ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_12"}
{"buggy_code": "* @ param name the name to use protected void setName ( String name ) { this . name = name ; }", "fixed_code": "* @ param name the name to use protected void setName ( String name ) { if ( name ! = null & & getPlatform ( ) = = PLATFORM_FAT & & name . indexOf ( \" / \" ) = = - 1 ) { name = name . replace ( ' \\ \\ ' , ' / ' ) ; } this . name = name ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_13"}
{"buggy_code": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; }", "fixed_code": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } if ( buffer [ start ] = = 0 ) { return 0L ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_14"}
{"buggy_code": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { if ( otherComment ! = null ) { return false ; } } else if ( ! myComment . equals ( otherComment ) ) { return false ; } return getTime ( ) = = other . getTime ( ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "fixed_code": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { myComment = \" \" ; } if ( otherComment = = null ) { otherComment = \" \" ; } return getTime ( ) = = other . getTime ( ) & & myComment . equals ( otherComment ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_15"}
{"buggy_code": "try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; / / COMPRESS - 191 - verify the header checksum tais . getNextEntry ( ) ; return new TarArchiveInputStream ( in ) ; } catch ( Exception e ) { / / NOPMD / / can generate IllegalArgumentException as well / / as IOException", "fixed_code": "try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; / / COMPRESS - 191 - verify the header checksum if ( tais . getNextTarEntry ( ) . isCheckSumOK ( ) ) { return new TarArchiveInputStream ( in ) ; } } catch ( Exception e ) { / / NOPMD / / can generate IllegalArgumentException as well / / as IOException", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_16"}
{"buggy_code": "} / / May have additional NULs or spaces trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } for ( ; start < end ; start + + ) {", "fixed_code": "} / / May have additional NULs or spaces trailer = buffer [ end - 1 ] ; while ( start < end - 1 & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_17"}
{"buggy_code": "void writePaxHeaders ( String entryName , Map < String , String > headers ) throws IOException { String name = \" . / PaxHeaders . X / \" + stripTo7Bits ( entryName ) ; / / TarEntry ' s constructor would think this is a directory / / and not allow any data to be written if ( name . length ( ) > = TarConstants . NAMELEN ) { name = name . substring ( 0 , TarConstants . NAMELEN - 1 ) ; }", "fixed_code": "void writePaxHeaders ( String entryName , Map < String , String > headers ) throws IOException { String name = \" . / PaxHeaders . X / \" + stripTo7Bits ( entryName ) ; while ( name . endsWith ( \" / \" ) ) { / / TarEntry ' s constructor would think this is a directory / / and not allow any data to be written name = name . substring ( 0 , name . length ( ) - 1 ) ; } if ( name . length ( ) > = TarConstants . NAMELEN ) { name = name . substring ( 0 , TarConstants . NAMELEN - 1 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_18"}
{"buggy_code": "if ( rawCentralDirectoryData . length ! = expectedLength ) { throw new ZipException ( \" central directory zip64 extended \"", "fixed_code": "( hasCompressedSize ? DWORD : 0 ) ( hasRelativeHeaderOffset ? DWORD : 0 ) ( hasDiskStart ? WORD : 0 ) ; if ( rawCentralDirectoryData . length < expectedLength ) { throw new ZipException ( \" central directory zip64 extended \" \" information extra field ' s length \" \" doesn ' t match central directory \"", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_19"}
{"buggy_code": "* If getNextEnxtry has been called , the entry metadata is stored in * currentEntry . public ArArchiveInputStream ( final InputStream pInput ) { input = pInput ; * if the entry could not be read public ArArchiveEntry getNextArEntry ( ) throws IOException { / / hit EOF before previous entry was complete / / TODO : throw an exception instead ? if ( offset = = 0 ) { final byte [ ] expected = ArArchiveEntry . HEADER . getBytes ( ) ; } } / / hit eof if ( input . available ( ) = = 0 ) { return null ; } if ( offset % 2 ! = 0 ) { read ( ) ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; } } return new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; } closed = true ; input . close ( ) ; } } public int read ( ) throws IOException { final int ret = input . read ( ) ; offset + = ( ret > 0 ? 1 : 0 ) ; return ret ; } public int read ( byte [ ] b ) throws IOException { public int read ( byte [ ] b , final int off , final int len ) throws IOException { int toRead = len ; final int ret = this . input . read ( b , off , toRead ) ; offset + = ( ret > 0 ? ret : 0 ) ; return ret ;", "fixed_code": "* If getNextEnxtry has been called , the entry metadata is stored in * currentEntry . private ArArchiveEntry currentEntry = null ; private long entryOffset = - 1 ; public ArArchiveInputStream ( final InputStream pInput ) { input = pInput ; * if the entry could not be read public ArArchiveEntry getNextArEntry ( ) throws IOException { if ( currentEntry ! = null ) { final long entryEnd = entryOffset + currentEntry . getLength ( ) ; while ( offset < entryEnd ) { int x = read ( ) ; if ( x = = - 1 ) { / / hit EOF before previous entry was complete / / TODO : throw an exception instead ? return null ; } } currentEntry = null ; } if ( offset = = 0 ) { final byte [ ] expected = ArArchiveEntry . HEADER . getBytes ( ) ; } } if ( offset % 2 ! = 0 ) { if ( read ( ) < 0 ) { / / hit eof return null ; } } if ( input . available ( ) = = 0 ) { return null ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; } } entryOffset = offset ; currentEntry = new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; return currentEntry ; } closed = true ; input . close ( ) ; } currentEntry = null ; } public int read ( ) throws IOException { byte [ ] single = new byte [ 1 ] ; int num = read ( single , 0 , 1 ) ; return num = = - 1 ? - 1 : single [ 0 ] & 0xff ; } public int read ( byte [ ] b ) throws IOException { public int read ( byte [ ] b , final int off , final int len ) throws IOException { int toRead = len ; if ( currentEntry ! = null ) { final long entryEnd = entryOffset + currentEntry . getLength ( ) ; if ( len > 0 & & entryEnd > offset ) { toRead = ( int ) Math . min ( len , entryEnd - offset ) ; } else { return - 1 ; } } final int ret = this . input . read ( b , off , toRead ) ; offset + = ( ret > 0 ? ret : 0 ) ; return ret ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_2"}
{"buggy_code": "ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "fixed_code": "ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { / / mode is initialised to 0 ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_20"}
{"buggy_code": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; - - shift ; if ( shift = = 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( length > 0 & & shift > 0 ) { header . write ( cache ) ; } }", "fixed_code": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; if ( - - shift < 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( shift ! = 7 ) { header . write ( cache ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_21"}
{"buggy_code": "private InputStream in ; private final boolean decompressConcatenated ; private int currentChar = - 1 ; private static final int EOF = 0 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; init ( true ) ; initBlock ( ) ; setupBlock ( ) ; } @ Override } private int read0 ( ) throws IOException { final int retChar = this . currentChar ; switch ( currentState ) { case EOF : return - 1 ; case START_BLOCK_STATE : throw new IllegalStateException ( ) ; case RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : throw new IllegalStateException ( ) ; } return retChar ; } private boolean init ( boolean isFirstStream ) throws IOException { } this . su_ch2 = su_ch2Shadow ^ = ( this . su_rNToGo = = 1 ) ? 1 : 0 ; this . su_i2 + + ; this . currentChar = su_ch2Shadow ; this . currentState = RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; this . su_ch2 = su_ch2Shadow ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_i2 + + ; this . currentChar = su_ch2Shadow ; this . currentState = NO_RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; private int setupRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { this . currentChar = this . su_ch2 ; this . crc . updateCRC ( this . su_ch2 ) ; this . su_j2 + + ; return this . su_ch2 ; private int setupNoRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { int su_ch2Shadow = this . su_ch2 ; this . currentChar = su_ch2Shadow ; this . crc . updateCRC ( su_ch2Shadow ) ; this . su_j2 + + ; this . currentState = NO_RAND_PART_C_STATE ;", "fixed_code": "private InputStream in ; private final boolean decompressConcatenated ; private static final int EOF = 0 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; init ( true ) ; initBlock ( ) ; } @ Override } private int read0 ( ) throws IOException { switch ( currentState ) { case EOF : return - 1 ; case START_BLOCK_STATE : return setupBlock ( ) ; case RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case RAND_PART_B_STATE : return setupRandPartB ( ) ; case RAND_PART_C_STATE : return setupRandPartC ( ) ; case NO_RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case NO_RAND_PART_B_STATE : return setupNoRandPartB ( ) ; case NO_RAND_PART_C_STATE : return setupNoRandPartC ( ) ; default : throw new IllegalStateException ( ) ; } } private boolean init ( boolean isFirstStream ) throws IOException { } this . su_ch2 = su_ch2Shadow ^ = ( this . su_rNToGo = = 1 ) ? 1 : 0 ; this . su_i2 + + ; this . currentState = RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; this . su_ch2 = su_ch2Shadow ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_i2 + + ; this . currentState = NO_RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; return su_ch2Shadow ; private int setupRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { this . crc . updateCRC ( this . su_ch2 ) ; this . su_j2 + + ; return this . su_ch2 ; private int setupNoRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { int su_ch2Shadow = this . su_ch2 ; this . crc . updateCRC ( su_ch2Shadow ) ; this . su_j2 + + ; this . currentState = NO_RAND_PART_C_STATE ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_22"}
{"buggy_code": "byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i + + ) { dictSize | = ( coder . properties [ i + 1 ] < < ( 8 * i ) ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( \" Dictionary larger than 4GiB maximum size \" ) ;", "fixed_code": "byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i + + ) { dictSize | = ( coder . properties [ i + 1 ] & 0xffl ) < < ( 8 * i ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( \" Dictionary larger than 4GiB maximum size \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_23"}
{"buggy_code": "/ / space but some implementations use the extra digit for big / / sizes / uids / gids . . . byte trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } else { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , end - 1 , trailer ) ) ; } trailer = buffer [ end - 1 ] ; while ( start < end - 1 & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "fixed_code": "/ / space but some implementations use the extra digit for big / / sizes / uids / gids . . . byte trailer = buffer [ end - 1 ] ; while ( start < end & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_24"}
{"buggy_code": "this . allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor ; / / haven ' t read anything so far } public ZipArchiveEntry getNextZipEntry ( ) throws IOException {", "fixed_code": "this . allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor ; / / haven ' t read anything so far buf . limit ( 0 ) ; } public ZipArchiveEntry getNextZipEntry ( ) throws IOException {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_25"}
{"buggy_code": "numToSkip - = skipped ; } return available - numToSkip ; }", "fixed_code": "numToSkip - = skipped ; } if ( numToSkip > 0 ) { byte [ ] skipBuf = new byte [ SKIP_BUF_SIZE ] ; while ( numToSkip > 0 ) { int read = readFully ( input , skipBuf , 0 , ( int ) Math . min ( numToSkip , SKIP_BUF_SIZE ) ) ; if ( read < 1 ) { break ; } numToSkip - = read ; } } return available - numToSkip ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_26"}
{"buggy_code": "end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "fixed_code": "end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_27"}
{"buggy_code": "numToRead = Math . min ( numToRead , available ( ) ) ; totalRead = is . read ( buf , offset , numToRead ) ; count ( totalRead ) ; if ( totalRead = = - 1 ) { hasHitEOF = true ; } else { entryOffset + = totalRead ; }", "fixed_code": "numToRead = Math . min ( numToRead , available ( ) ) ; totalRead = is . read ( buf , offset , numToRead ) ; if ( totalRead = = - 1 ) { if ( numToRead > 0 ) { throw new IOException ( \" Truncated TAR archive \" ) ; } hasHitEOF = true ; } else { count ( totalRead ) ; entryOffset + = totalRead ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_28"}
{"buggy_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests )", "fixed_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_29"}
{"buggy_code": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { return new JarArchiveOutputStream ( out ) ; } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { return new ArjArchiveInputStream ( in ) ; } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; }", "fixed_code": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new JarArchiveOutputStream ( out , entryEncoding ) ; } else { return new JarArchiveOutputStream ( out ) ; } } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { if ( entryEncoding ! = null ) { return new ArjArchiveInputStream ( in , entryEncoding ) ; } else { return new ArjArchiveInputStream ( in ) ; } } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Compress_29"}
{"buggy_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests )", "fixed_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Compress_29"}
{"buggy_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests )", "fixed_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ;", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Compress_29"}
{"buggy_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) private final boolean useUnicodeExtraFields ; String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "fixed_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ; private final boolean useUnicodeExtraFields ; String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { this . encoding = encoding ; zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "Compress_29"}
{"buggy_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests )", "fixed_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ;", "label": 1, "tool_name": "Developer", "patch_name": "patch6", "project_name": "Compress_29"}
{"buggy_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) private boolean addPaxHeadersForNonAsciiNames = false ; private static final ZipEncoding ASCII = public TarArchiveOutputStream ( OutputStream os , int blockSize , int recordSize , String encoding ) { out = new CountingOutputStream ( os ) ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . assemLen = 0 ;", "fixed_code": "private final ZipEncoding zipEncoding ; / / the provided encoding ( for unit tests ) final String encoding ; private boolean addPaxHeadersForNonAsciiNames = false ; private static final ZipEncoding ASCII = public TarArchiveOutputStream ( OutputStream os , int blockSize , int recordSize , String encoding ) { out = new CountingOutputStream ( os ) ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . assemLen = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch7", "project_name": "Compress_29"}
{"buggy_code": "private boolean closed = false ; private final OutputStream out ; * @ throws IOException on error public void finish ( ) throws IOException { writeEOFRecord ( ) ; writeEOFRecord ( ) ; } currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; }", "fixed_code": "private boolean closed = false ; private boolean haveUnclosedEntry = false ; private final OutputStream out ; * @ throws IOException on error public void finish ( ) throws IOException { if ( haveUnclosedEntry ) { throw new IOException ( \" This archives contains unclosed entries . \" ) ; } writeEOFRecord ( ) ; writeEOFRecord ( ) ; } currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; haveUnclosedEntry = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_3"}
{"buggy_code": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } final int hi = offs + len ; int destOffs = offs ;", "fixed_code": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } if ( len = = 0 ) { return 0 ; } final int hi = offs + len ; int destOffs = offs ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_30"}
{"buggy_code": "for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; if ( currentByte = = 0 ) { break ; } / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "fixed_code": "for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_31"}
{"buggy_code": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Integer . parseInt ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Integer . parseInt ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "fixed_code": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Long . parseLong ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Long . parseLong ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_32"}
{"buggy_code": "* @ since 1 . 9 public class DeflateCompressorInputStream extends CompressorInputStream { private final InputStream in ; * * @ since 1 . 9 }", "fixed_code": "* @ since 1 . 9 public class DeflateCompressorInputStream extends CompressorInputStream { private static final int MAGIC_1 = 0x78 ; private static final int MAGIC_2a = 0x01 ; private static final int MAGIC_2b = 0x5e ; private static final int MAGIC_2c = 0x9c ; private static final int MAGIC_2d = 0xda ; private final InputStream in ; * * @ since 1 . 9 public static boolean matches ( byte [ ] signature , int length ) { return length > 3 & & signature [ 0 ] = = MAGIC_1 & & ( signature [ 1 ] = = ( byte ) MAGIC_2a | | signature [ 1 ] = = ( byte ) MAGIC_2b | | signature [ 1 ] = = ( byte ) MAGIC_2c | | signature [ 1 ] = = ( byte ) MAGIC_2d ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_33"}
{"buggy_code": "return new ZCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) {", "fixed_code": "return new ZCompressorInputStream ( in ) ; } if ( DeflateCompressorInputStream . matches ( signature , signatureLength ) ) { return new DeflateCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Compress_33"}
{"buggy_code": "public class X7875_NewUnix implements ZipExtraField , Cloneable , Serializable { private static final ZipShort HEADER_ID = new ZipShort ( 0x7875 ) ; private static final BigInteger ONE_THOUSAND = BigInteger . valueOf ( 1000 ) ; private static final long serialVersionUID = 1L ; * @ return a < code > ZipShort < / code > for the length of the data of this extra field public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; }", "fixed_code": "public class X7875_NewUnix implements ZipExtraField , Cloneable , Serializable { private static final ZipShort HEADER_ID = new ZipShort ( 0x7875 ) ; private static final ZipShort ZERO = new ZipShort ( 0 ) ; private static final BigInteger ONE_THOUSAND = BigInteger . valueOf ( 1000 ) ; private static final long serialVersionUID = 1L ; * @ return a < code > ZipShort < / code > for the length of the data of this extra field public ZipShort getCentralDirectoryLength ( ) { return ZERO ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_34"}
{"buggy_code": "* @ since 1 . 5 public static boolean verifyCheckSum ( byte [ ] header ) { long storedSum = 0 ; long unsignedSum = 0 ; long signedSum = 0 ; for ( int i = 0 ; i < header . length ; i + + ) { byte b = header [ i ] ; if ( CHKSUM_OFFSET < = i & & i < CHKSUM_OFFSET + CHKSUMLEN ) { if ( ' 0 ' < = b & & b < = ' 7 ' & & digits + + < 6 ) { storedSum = storedSum * 8 + b - ' 0 ' ; } else if ( digits > 0 ) { digits = 6 ; } b = ' ' ; } unsignedSum + = 0xff & b ;", "fixed_code": "* @ since 1 . 5 public static boolean verifyCheckSum ( byte [ ] header ) { long storedSum = parseOctal ( header , CHKSUM_OFFSET , CHKSUMLEN ) ; long unsignedSum = 0 ; long signedSum = 0 ; for ( int i = 0 ; i < header . length ; i + + ) { byte b = header [ i ] ; if ( CHKSUM_OFFSET < = i & & i < CHKSUM_OFFSET + CHKSUMLEN ) { b = ' ' ; } unsignedSum + = 0xff & b ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_35"}
{"buggy_code": "} private InputStream getCurrentStream ( ) throws IOException { if ( deferredBlockStreams . isEmpty ( ) ) { throw new IllegalStateException ( \" No current 7z entry ( call getNextEntry ( ) first ) . \" ) ; }", "fixed_code": "} private InputStream getCurrentStream ( ) throws IOException { if ( archive . files [ currentEntryIndex ] . getSize ( ) = = 0 ) { return new ByteArrayInputStream ( new byte [ 0 ] ) ; } if ( deferredBlockStreams . isEmpty ( ) ) { throw new IllegalStateException ( \" No current 7z entry ( call getNextEntry ( ) first ) . \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_36"}
{"buggy_code": "int read = 0 ; while ( ( ch = i . read ( ) ) ! = - 1 ) { read + + ; if ( ch = = ' ' ) { / / Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) ! = - 1 ) {", "fixed_code": "int read = 0 ; while ( ( ch = i . read ( ) ) ! = - 1 ) { read + + ; if ( ch = = ' \\ n ' ) { / / blank line in header break ; } else if ( ch = = ' ' ) { / / End of length string / / Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) ! = - 1 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_37"}
{"buggy_code": "return true ; } if ( getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "fixed_code": "return true ; } if ( ! isPaxHeader ( ) & & ! isGlobalPaxHeader ( ) & & getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_38"}
{"buggy_code": "public class ArchiveUtils { private ArchiveUtils ( ) { * @ since Compress 1 . 12 public static String sanitize ( String s ) { final char [ ] chars = s . toCharArray ( ) ; final int len = chars . length ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "public class ArchiveUtils { private static final int MAX_SANITIZED_NAME_LENGTH = 255 ; private ArchiveUtils ( ) { * @ since Compress 1 . 12 public static String sanitize ( String s ) { final char [ ] cs = s . toCharArray ( ) ; final char [ ] chars = cs . length < = MAX_SANITIZED_NAME_LENGTH ? cs : Arrays . copyOf ( cs , MAX_SANITIZED_NAME_LENGTH ) ; if ( cs . length > MAX_SANITIZED_NAME_LENGTH ) { for ( int i = MAX_SANITIZED_NAME_LENGTH - 3 ; i < MAX_SANITIZED_NAME_LENGTH ; i + + ) { chars [ i ] = ' . ' ; } } final int len = chars . length ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_39"}
{"buggy_code": "results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } return results ; }", "fixed_code": "results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } out . finish ( ) ; return results ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_4"}
{"buggy_code": "* @ exception IOException if an I / O error occurs . public void close ( ) throws IOException { finish ( ) ; if ( raf ! = null ) { raf . close ( ) ; }", "fixed_code": "* @ exception IOException if an I / O error occurs . public void close ( ) throws IOException { if ( raf ! = null ) { raf . close ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Compress_4"}
{"buggy_code": "public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; out . close ( ) ; this . closed = true ; }", "fixed_code": "public void close ( ) throws IOException { if ( ! this . closed ) { out . close ( ) ; this . closed = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Compress_4"}
{"buggy_code": "public void close ( ) throws IOException { if ( ! closed ) { finish ( ) ; buffer . close ( ) ; out . close ( ) ; closed = true ;", "fixed_code": "public void close ( ) throws IOException { if ( ! closed ) { buffer . close ( ) ; out . close ( ) ; closed = true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Compress_4"}
{"buggy_code": "if ( count < 0 | | count > MAXIMUM_CACHE_SIZE ) { throw new IllegalArgumentException ( \" count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE ) ; } while ( bitsCachedSize < count ) { final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } bitsCachedSize + = 8 ; } / / bitsCachedSize > = 57 and left - shifting it 8 bits would cause an overflow final long bitsOut ; if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { bitsOut = ( bitsCached & MASKS [ count ] ) ; bitsCached > > > = count ; bitsOut = ( bitsCached > > ( bitsCachedSize - count ) ) & MASKS [ count ] ; } bitsCachedSize - = count ; return bitsOut ; } }", "fixed_code": "if ( count < 0 | | count > MAXIMUM_CACHE_SIZE ) { throw new IllegalArgumentException ( \" count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE ) ; } while ( bitsCachedSize < count & & bitsCachedSize < 57 ) { final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } bitsCachedSize + = 8 ; } int overflowBits = 0 ; long overflow = 0l ; if ( bitsCachedSize < count ) { / / bitsCachedSize > = 57 and left - shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize ; overflowBits = 8 - bitsToAddCount ; final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { long bitsToAdd = nextByte & MASKS [ bitsToAddCount ] ; bitsCached | = ( bitsToAdd < < bitsCachedSize ) ; overflow = ( nextByte > > > bitsToAddCount ) & MASKS [ overflowBits ] ; } else { bitsCached < < = bitsToAddCount ; long bitsToAdd = ( nextByte > > > ( overflowBits ) ) & MASKS [ bitsToAddCount ] ; bitsCached | = bitsToAdd ; overflow = nextByte & MASKS [ overflowBits ] ; } bitsCachedSize = count ; } final long bitsOut ; if ( overflowBits = = 0 ) { if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { bitsOut = ( bitsCached & MASKS [ count ] ) ; bitsCached > > > = count ; bitsOut = ( bitsCached > > ( bitsCachedSize - count ) ) & MASKS [ count ] ; } bitsCachedSize - = count ; } else { bitsOut = bitsCached & MASKS [ count ] ; bitsCached = overflow ; bitsCachedSize = overflowBits ; } return bitsOut ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_40"}
{"buggy_code": "if ( sig . equals ( ZipLong . CFH_SIG ) | | sig . equals ( ZipLong . AED_SIG ) ) { hitCentralDirectory = true ; skipRemainderOfArchive ( ) ; } if ( ! sig . equals ( ZipLong . LFH_SIG ) ) { return null ; } int off = WORD ;", "fixed_code": "if ( sig . equals ( ZipLong . CFH_SIG ) | | sig . equals ( ZipLong . AED_SIG ) ) { hitCentralDirectory = true ; skipRemainderOfArchive ( ) ; return null ; } if ( ! sig . equals ( ZipLong . LFH_SIG ) ) { throw new ZipException ( String . format ( \" Unexpected record signature : 0X % X \" , sig . getValue ( ) ) ) ; } int off = WORD ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_41"}
{"buggy_code": "* @ return true if the entry represents a unix symlink , false otherwise . public boolean isUnixSymlink ( ) { return ( getUnixMode ( ) & UnixStat . LINK_FLAG ) = = UnixStat . LINK_FLAG ; }", "fixed_code": "* @ return true if the entry represents a unix symlink , false otherwise . public boolean isUnixSymlink ( ) { return ( getUnixMode ( ) & UnixStat . FILE_TYPE_FLAG ) = = UnixStat . LINK_FLAG ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_42"}
{"buggy_code": "* Bits used to indicate the filesystem object type . * @ since 1 . 14", "fixed_code": "* Bits used to indicate the filesystem object type . * @ since 1 . 14 int FILE_TYPE_FLAG = 0170000 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Compress_42"}
{"buggy_code": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; * @ throws IOException on error protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ze . getMethod ( ) ! = DEFLATED | | channel ! = null ) { return ; } writeCounted ( DD_SIG ) ; return versionNeededToExtractMethod ( zipMethod ) ; } private boolean usesDataDescriptor ( final int zipMethod ) { return zipMethod = = DEFLATED & & channel = = null ; } private int versionNeededToExtractMethod ( int zipMethod ) {", "fixed_code": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) , phased ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod , phased ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; * @ throws IOException on error protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ! usesDataDescriptor ( ze . getMethod ( ) , false ) ) { return ; } writeCounted ( DD_SIG ) ; return versionNeededToExtractMethod ( zipMethod ) ; } private boolean usesDataDescriptor ( final int zipMethod , boolean phased ) { return ! phased & & zipMethod = = DEFLATED & & channel = = null ; } private int versionNeededToExtractMethod ( int zipMethod ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_43"}
{"buggy_code": "public ChecksumCalculatingInputStream ( final Checksum checksum , final InputStream in ) { this . checksum = checksum ; this . in = in ;", "fixed_code": "public ChecksumCalculatingInputStream ( final Checksum checksum , final InputStream in ) { if ( checksum = = null ) { throw new NullPointerException ( \" Parameter checksum must not be null \" ) ; } if ( in = = null ) { throw new NullPointerException ( \" Parameter in must not be null \" ) ; } this . checksum = checksum ; this . in = in ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_44"}
{"buggy_code": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } formatBigIntegerBinary ( value , buf , offset , length , negative ) ; buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "fixed_code": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } else { formatBigIntegerBinary ( value , buf , offset , length , negative ) ; } buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_45"}
{"buggy_code": "} private static ZipLong unixTimeToZipLong ( long l ) { final long TWO_TO_32 = 0x100000000L ; if ( l > = TWO_TO_32 ) { throw new IllegalArgumentException ( \" X5455 timestamps must fit in a signed 32 bit integer : \" + l ) ; } return new ZipLong ( l ) ;", "fixed_code": "} private static ZipLong unixTimeToZipLong ( long l ) { if ( l < Integer . MIN_VALUE | | l > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( \" X5455 timestamps must fit in a signed 32 bit integer : \" + l ) ; } return new ZipLong ( l ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_46"}
{"buggy_code": "if ( ae instanceof ZipArchiveEntry ) { final ZipArchiveEntry ze = ( ZipArchiveEntry ) ae ; return ZipUtil . canHandleEntryData ( ze ) & & supportsDataDescriptorFor ( ze ) ; } return false ; } throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . DATA_DESCRIPTOR , current . entry ) ; } int read ; if ( current . entry . getMethod ( ) = = ZipArchiveOutputStream . STORED ) { * Whether the compressed size for the entry is either known or * not required by the compression method being used .", "fixed_code": "if ( ae instanceof ZipArchiveEntry ) { final ZipArchiveEntry ze = ( ZipArchiveEntry ) ae ; return ZipUtil . canHandleEntryData ( ze ) & & supportsDataDescriptorFor ( ze ) & & supportsCompressedSizeFor ( ze ) ; } return false ; } throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . DATA_DESCRIPTOR , current . entry ) ; } if ( ! supportsCompressedSizeFor ( current . entry ) ) { throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . UNKNOWN_COMPRESSED_SIZE , current . entry ) ; } int read ; if ( current . entry . getMethod ( ) = = ZipArchiveOutputStream . STORED ) { * Whether the compressed size for the entry is either known or * not required by the compression method being used . private boolean supportsCompressedSizeFor ( final ZipArchiveEntry entry ) { return entry . getCompressedSize ( ) ! = ArchiveEntry . SIZE_UNKNOWN | | entry . getMethod ( ) = = ZipEntry . DEFLATED | | entry . getMethod ( ) = = ZipMethod . ENHANCED_DEFLATED . getCode ( ) | | ( entry . getGeneralPurposeBit ( ) . usesDataDescriptor ( ) & & allowStoredEntriesWithDataDescriptor & & entry . getMethod ( ) = = ZipEntry . STORED ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_47"}
{"buggy_code": "} catch ( DataFormatException e ) { throw new ZipException ( e . getMessage ( ) ) ; } if ( read = = 0 & & inf . finished ( ) ) { return - 1 ; } crc . update ( buffer , start , read ) ; return read ;", "fixed_code": "} catch ( DataFormatException e ) { throw new ZipException ( e . getMessage ( ) ) ; } if ( read = = 0 ) { if ( inf . finished ( ) ) { return - 1 ; } else if ( lengthOfLastRead = = - 1 ) { throw new IOException ( \" Truncated ZIP file \" ) ; } } crc . update ( buffer , start , read ) ; return read ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_5"}
{"buggy_code": "public ZipArchiveEntry ( String name ) { super ( name ) ; }", "fixed_code": "public ZipArchiveEntry ( String name ) { super ( name ) ; setName ( name ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_6"}
{"buggy_code": "int end = offset + length ; for ( int i = offset ; i < end ; + + i ) { if ( buffer [ i ] = = 0 ) { break ; } result . append ( ( char ) buffer [ i ] ) ; } return result . toString ( ) ;", "fixed_code": "int end = offset + length ; for ( int i = offset ; i < end ; + + i ) { byte b = buffer [ i ] ; if ( b = = 0 ) { / / Trailing null break ; } result . append ( ( char ) ( b & 0xFF ) ) ; / / Allow for sign - extension } return result . toString ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_7"}
{"buggy_code": "public static long parseOctal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; int start = offset ; for ( int i = start ; i < end ; i + + ) { final byte currentByte = buffer [ i ] ; if ( currentByte = = 0 ) { break ; } / / Skip leading spaces if ( currentByte = = ( byte ) ' ' | | currentByte = = ' 0 ' ) { if ( stillPadding ) { continue ; } if ( currentByte = = ( byte ) ' ' ) { break ; } } / / Must have trailing NUL or space / / May have additional NUL or space stillPadding = false ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "fixed_code": "public static long parseOctal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; int end = offset + length ; int start = offset ; if ( length < 2 ) { throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; }  boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; } / / Skip leading spaces while ( start < end ) { if ( buffer [ start ] = = ' ' ) { start + + ; } else { break ; } } / / Must have trailing NUL or space byte trailer ; trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } else { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , end - 1 , trailer ) ) ; } / / May have additional NUL or space trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_8"}
{"buggy_code": "}", "fixed_code": "} @ Deprecated @ Override public int getCount ( ) { return ( int ) getBytesWritten ( ) ; } @ Override public long getBytesWritten ( ) { return ( ( CountingOutputStream ) out ) . getBytesWritten ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Compress_9"}
{"buggy_code": "@ Override public int read ( ) throws IOException { int current = super . read ( ) ; if ( current = = ' \\ n ' ) { lineCounter + + ; } lastChar = current ;", "fixed_code": "@ Override public int read ( ) throws IOException { int current = super . read ( ) ; if ( current = = ' \\ r ' | | ( current = = ' \\ n ' & & lastChar ! = ' \\ r ' ) ) { lineCounter + + ; } lastChar = current ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_1"}
{"buggy_code": "this . format . validate ( ) ; / / TODO : Is it a good idea to do this here instead of on the first call to a print method ? / / It seems a pain to have to track whether the header has already been printed or not . } / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =", "fixed_code": "this . format . validate ( ) ; / / TODO : Is it a good idea to do this here instead of on the first call to a print method ? / / It seems a pain to have to track whether the header has already been printed or not . if ( format . getHeader ( ) ! = null ) { this . printRecord ( ( Object [ ] ) format . getHeader ( ) ) ; } } / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_10"}
{"buggy_code": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "fixed_code": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header = = null | | header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_11"}
{"buggy_code": "* Note : this is currently like { @ link # RFC4180 } plus { @ link # withAllowMissingColumnNames ( boolean ) withAllowMissingColumnNames ( true ) } . * < / p > public static final CSVFormat EXCEL = DEFAULT . withIgnoreEmptyLines ( false ) ;", "fixed_code": "* Note : this is currently like { @ link # RFC4180 } plus { @ link # withAllowMissingColumnNames ( boolean ) withAllowMissingColumnNames ( true ) } . * < / p > public static final CSVFormat EXCEL = DEFAULT . withIgnoreEmptyLines ( false ) . withAllowMissingColumnNames ( true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_12"}
{"buggy_code": "* http : / / dev . mysql . com / doc / refman / 5 . 1 / en / load - data . html < / a > public static final CSVFormat MYSQL = DEFAULT . withDelimiter ( TAB ) . withEscape ( BACKSLASH ) . withIgnoreEmptyLines ( false ) . withQuote ( null ) . withRecordSeparator ( LF ) ;", "fixed_code": "* http : / / dev . mysql . com / doc / refman / 5 . 1 / en / load - data . html < / a > public static final CSVFormat MYSQL = DEFAULT . withDelimiter ( TAB ) . withEscape ( BACKSLASH ) . withIgnoreEmptyLines ( false ) . withQuote ( null ) . withRecordSeparator ( LF ) . withNullString ( \" \\ \\ N \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_13"}
{"buggy_code": "if ( ! newRecord ) { out . append ( format . getDelimiter ( ) ) ; } if ( format . isQuoteCharacterSet ( ) ) { / / the original object is needed so can check for Number printAndQuote ( object , value , offset , len ) ; } else if ( format . isEscapeCharacterSet ( ) ) {", "fixed_code": "if ( ! newRecord ) { out . append ( format . getDelimiter ( ) ) ; } if ( object = = null ) { out . append ( value ) ; } else if ( format . isQuoteCharacterSet ( ) ) { / / the original object is needed so can check for Number printAndQuote ( object , value , offset , len ) ; } else if ( format . isEscapeCharacterSet ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Csv_13"}
{"buggy_code": "char c = value . charAt ( pos ) ; / / RFC4180 ( https : / / tools . ietf . org / html / rfc4180 ) TEXTDATA = % x20 - 21 / % x23 - 2B / % x2D - 7E if ( newRecord & & ( c < ' 0 ' | | c > ' 9 ' & & c < ' A ' | | c > ' Z ' & & c < ' a ' | | c > ' z ' ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now", "fixed_code": "char c = value . charAt ( pos ) ; / / RFC4180 ( https : / / tools . ietf . org / html / rfc4180 ) TEXTDATA = % x20 - 21 / % x23 - 2B / % x2D - 7E if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_14"}
{"buggy_code": "} else { char c = value . charAt ( pos ) ; if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "fixed_code": "} else { char c = value . charAt ( pos ) ; if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_15"}
{"buggy_code": "private final Lexer lexer ; private final List < String > recordList = new ArrayList < > ( ) ; this . format = format ; this . lexer = new Lexer ( format , new ExtendedBufferedReader ( reader ) ) ; this . headerMap = this . initializeHeader ( ) ; this . characterOffset = characterOffset ; this . recordNumber = recordNumber - 1 ; @ Override public Iterator < CSVRecord > iterator ( ) { return new Iterator < CSVRecord > ( ) { private CSVRecord current ; private CSVRecord getNextRecord ( ) { throw new UnsupportedOperationException ( ) ; } } ; }", "fixed_code": "private final Lexer lexer ; private final CSVRecordIterator csvRecordIterator ; private final List < String > recordList = new ArrayList < > ( ) ; this . format = format ; this . lexer = new Lexer ( format , new ExtendedBufferedReader ( reader ) ) ; this . csvRecordIterator = new CSVRecordIterator ( ) ; this . headerMap = this . initializeHeader ( ) ; this . characterOffset = characterOffset ; this . recordNumber = recordNumber - 1 ; @ Override public Iterator < CSVRecord > iterator ( ) { return csvRecordIterator ; }  class CSVRecordIterator implements Iterator < CSVRecord > { private CSVRecord current ; private CSVRecord getNextRecord ( ) { throw new UnsupportedOperationException ( ) ; } } ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_16"}
{"buggy_code": "\" No header mapping was specified , the record values can ' t be accessed by name \" ) ; } final Integer index = mapping . get ( name ) ; return index ! = null ? values [ index . intValue ( ) ] : null ; }", "fixed_code": "\" No header mapping was specified , the record values can ' t be accessed by name \" ) ; } final Integer index = mapping . get ( name ) ; try { return index ! = null ? values [ index . intValue ( ) ] : null ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( String . format ( \" Index for header ' % s ' is % d but CSVRecord only has % d values ! \" , name , index . intValue ( ) , values . length ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_2"}
{"buggy_code": "throw new IOException ( \" EOF whilst processing escape sequence \" ) ; default : / / Now check for meta - characters return c ; / / indicate unexpected char - available from in . getLastChar ( ) } }", "fixed_code": "throw new IOException ( \" EOF whilst processing escape sequence \" ) ; default : / / Now check for meta - characters if ( isDelimiter ( c ) | | isEscape ( c ) | | isQuoteChar ( c ) | | isCommentStart ( c ) ) { return c ; } / / indicate unexpected char - available from in . getLastChar ( ) return END_OF_STREAM ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_3"}
{"buggy_code": "* @ return a copy of the header map that iterates in column order . public Map < String , Integer > getHeaderMap ( ) { return new LinkedHashMap < String , Integer > ( this . headerMap ) ; }", "fixed_code": "* @ return a copy of the header map that iterates in column order . public Map < String , Integer > getHeaderMap ( ) { return this . headerMap = = null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_4"}
{"buggy_code": "public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; out . append ( recordSeparator ) ; newRecord = true ; }", "fixed_code": "public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; if ( recordSeparator ! = null ) { out . append ( recordSeparator ) ; } newRecord = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_5"}
{"buggy_code": "< M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; map . put ( entry . getKey ( ) , values [ col ] ) ; } return map ; }", "fixed_code": "< M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) { map . put ( entry . getKey ( ) , values [ col ] ) ; } } return map ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_6"}
{"buggy_code": "import java . net . URL ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; / / build the name to index mappings if ( header ! = null ) { for ( int i = 0 ; i < header . length ; i + + ) { hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } }", "fixed_code": "import java . net . URL ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; / / build the name to index mappings if ( header ! = null ) { for ( int i = 0 ; i < header . length ; i + + ) { if ( hdrMap . containsKey ( header [ i ] ) ) { throw new IllegalStateException ( \" The header contains duplicate names : \" + Arrays . toString ( header ) ) ; } hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_7"}
{"buggy_code": "if ( header = = null ) { this . header = null ; } else { this . header = header . clone ( ) ; } this . skipHeaderRecord = skipHeaderRecord ; throw new IllegalStateException ( \" No quotes mode set but no escape character is set \" ) ; } if ( header ! = null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size ( ) ! = header . length ) { throw new IllegalStateException ( \" The header contains duplicate names : \" + Arrays . toString ( header ) ) ; } } }", "fixed_code": "if ( header = = null ) { this . header = null ; } else { Set < String > dupCheck = new HashSet < String > ( ) ; for ( String hdr : header ) { if ( ! dupCheck . add ( hdr ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate entry : ' \" + hdr + \" ' in \" + Arrays . toString ( header ) ) ; } } this . header = header . clone ( ) ; } this . skipHeaderRecord = skipHeaderRecord ; throw new IllegalStateException ( \" No quotes mode set but no escape character is set \" ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_8"}
{"buggy_code": "* @ return the given map . < M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) {", "fixed_code": "* @ return the given map . < M extends Map < String , String > > M putIn ( final M map ) { if ( mapping = = null ) { return map ; } for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Csv_9"}
{"buggy_code": "int indexOfActualTypeArgument = getIndex ( classTypeVariables , fieldTypeVariable ) ; Type [ ] actualTypeArguments = objParameterizedType . getActualTypeArguments ( ) ; return actualTypeArguments [ indexOfActualTypeArgument ] ; } throw new UnsupportedOperationException ( \" Expecting parameterized type , got \" + parentType } } / / Evaluate type on this type private static Type [ ] extractRealTypes ( Type [ ] actualTypeArguments , Type parentType , Class < ? > rawParentClass ) {", "fixed_code": "int indexOfActualTypeArgument = getIndex ( classTypeVariables , fieldTypeVariable ) ; Type [ ] actualTypeArguments = objParameterizedType . getActualTypeArguments ( ) ; return actualTypeArguments [ indexOfActualTypeArgument ] ; } else if ( typeToEvaluate instanceof TypeVariable < ? > ) { Type theSearchedType = null ; do { theSearchedType = extractTypeForHierarchy ( parentType , ( TypeVariable < ? > ) typeToEvaluate ) ; } while ( ( theSearchedType ! = null ) & & ( theSearchedType instanceof TypeVariable < ? > ) ) ; if ( theSearchedType ! = null ) { return theSearchedType ; } } throw new UnsupportedOperationException ( \" Expecting parameterized type , got \" + parentType } } private static Type extractTypeForHierarchy ( Type parentType , TypeVariable < ? > typeToEvaluate ) { Class < ? > rawParentType = null ; if ( parentType instanceof Class < ? > ) { rawParentType = ( Class < ? > ) parentType ; } else if ( parentType instanceof ParameterizedType ) { ParameterizedType parentTypeAsPT = ( ParameterizedType ) parentType ; rawParentType = ( Class < ? > ) parentTypeAsPT . getRawType ( ) ; } else { return null ; } Type superClass = rawParentType . getGenericSuperclass ( ) ; if ( superClass instanceof ParameterizedType & & ( ( ParameterizedType ) superClass ) . getRawType ( ) = = typeToEvaluate . getGenericDeclaration ( ) ) { / / Evaluate type on this type TypeVariable < ? > [ ] classTypeVariables = ( ( Class < ? > ) ( ( ParameterizedType ) superClass ) . getRawType ( ) ) . getTypeParameters ( ) ; int indexOfActualTypeArgument = getIndex ( classTypeVariables , typeToEvaluate ) ;  Type [ ] actualTypeArguments = null ; if ( parentType instanceof Class < ? > ) { actualTypeArguments = ( ( ParameterizedType ) superClass ) . getActualTypeArguments ( ) ; } else if ( parentType instanceof ParameterizedType ) { actualTypeArguments = ( ( ParameterizedType ) parentType ) . getActualTypeArguments ( ) ; } else { return null ; } return actualTypeArguments [ indexOfActualTypeArgument ] ; } Type searchedType = null ; if ( superClass ! = null ) { searchedType = extractTypeForHierarchy ( superClass , typeToEvaluate ) ; } return searchedType ; } private static Type [ ] extractRealTypes ( Type [ ] actualTypeArguments , Type parentType , Class < ? > rawParentClass ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_1"}
{"buggy_code": "@ Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field . get ( value ) ; TypeAdapter t = new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType . getType ( ) ) ; t . write ( writer , fieldValue ) ; } @ Override void read ( JsonReader reader , Object value )", "fixed_code": "@ Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field . get ( value ) ; TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType . getType ( ) ) ; t . write ( writer , fieldValue ) ; } @ Override void read ( JsonReader reader , Object value )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_10"}
{"buggy_code": "in . nextNull ( ) ; return null ; case NUMBER : return new LazilyParsedNumber ( in . nextString ( ) ) ; default : throw new JsonSyntaxException ( \" Expecting number , got : \" + jsonToken ) ;", "fixed_code": "in . nextNull ( ) ; return null ; case NUMBER : case STRING : return new LazilyParsedNumber ( in . nextString ( ) ) ; default : throw new JsonSyntaxException ( \" Expecting number , got : \" + jsonToken ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_11"}
{"buggy_code": "pathNames [ stackSize - 2 ] = \" null \" ; } else { popStack ( ) ; pathNames [ stackSize - 1 ] = \" null \" ; } pathIndices [ stackSize - 1 ] + + ; } @ Override public String toString ( ) {", "fixed_code": "pathNames [ stackSize - 2 ] = \" null \" ; } else { popStack ( ) ; if ( stackSize > 0 ) { pathNames [ stackSize - 1 ] = \" null \" ; } } if ( stackSize > 0 ) { pathIndices [ stackSize - 1 ] + + ; } } @ Override public String toString ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_12"}
{"buggy_code": "} / / We ' ve read a complete number . Decide if it ' s a PEEKED_LONG or a PEEKED_NUMBER . if ( last = = NUMBER_CHAR_DIGIT & & fitsInLong & & ( value ! = Long . MIN_VALUE | | negative ) ) { peekedLong = negative ? value : - value ; pos + = i ; return peeked = PEEKED_LONG ;", "fixed_code": "} / / We ' ve read a complete number . Decide if it ' s a PEEKED_LONG or a PEEKED_NUMBER . if ( last = = NUMBER_CHAR_DIGIT & & fitsInLong & & ( value ! = Long . MIN_VALUE | | negative ) & & ( value ! = 0 | | false = = negative ) ) { peekedLong = negative ? value : - value ; pos + = i ; return peeked = PEEKED_LONG ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_13"}
{"buggy_code": "public static WildcardType subtypeOf ( Type bound ) { Type [ ] upperBounds ; upperBounds = new Type [ ] { bound } ; return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } public static WildcardType supertypeOf ( Type bound ) { Type [ ] lowerBounds ; lowerBounds = new Type [ ] { bound } ; return new WildcardTypeImpl ( new Type [ ] { Object . class } , lowerBounds ) ; }", "fixed_code": "public static WildcardType subtypeOf ( Type bound ) { Type [ ] upperBounds ; if ( bound instanceof WildcardType ) { upperBounds = ( ( WildcardType ) bound ) . getUpperBounds ( ) ; } else { upperBounds = new Type [ ] { bound } ; } return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } public static WildcardType supertypeOf ( Type bound ) { Type [ ] lowerBounds ; if ( bound instanceof WildcardType ) { lowerBounds = ( ( WildcardType ) bound ) . getLowerBounds ( ) ; } else { lowerBounds = new Type [ ] { bound } ; } return new WildcardTypeImpl ( new Type [ ] { Object . class } , lowerBounds ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_14"}
{"buggy_code": "public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ;", "fixed_code": "public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( ! lenient & & ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_15"}
{"buggy_code": "while ( true ) { if ( toResolve instanceof TypeVariable ) { TypeVariable < ? > typeVariable = ( TypeVariable < ? > ) toResolve ; / / cannot reduce due to infinite recursion toResolve = resolveTypeVariable ( context , contextRawType , typeVariable ) ; if ( toResolve = = typeVariable ) { return toResolve ;", "fixed_code": "while ( true ) { if ( toResolve instanceof TypeVariable ) { TypeVariable < ? > typeVariable = ( TypeVariable < ? > ) toResolve ; if ( visitedTypeVariables . contains ( typeVariable ) ) { / / cannot reduce due to infinite recursion return toResolve ; } else { visitedTypeVariables . add ( typeVariable ) ; } toResolve = resolveTypeVariable ( context , contextRawType , typeVariable ) ; if ( toResolve = = typeVariable ) { return toResolve ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_16"}
{"buggy_code": "@ Override public Date read ( JsonReader in ) throws IOException { if ( in . peek ( ) ! = JsonToken . STRING ) { throw new JsonParseException ( \" The date should be a string value \" ) ; } Date date = deserializeToDate ( in . nextString ( ) ) ; if ( dateType = = Date . class ) {", "fixed_code": "@ Override public Date read ( JsonReader in ) throws IOException { if ( in . peek ( ) = = JsonToken . NULL ) { in . nextNull ( ) ; return null ; } Date date = deserializeToDate ( in . nextString ( ) ) ; if ( dateType = = Date . class ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_17"}
{"buggy_code": "* @ param supertype a superclass of , or interface implemented by , this . static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { / / wildcards are useless for resolving supertypes . As the upper bound has the same raw type , use it instead checkArgument ( supertype . isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $ Gson $ Types . getGenericSupertype ( context , contextRawType , supertype ) ) ;", "fixed_code": "* @ param supertype a superclass of , or interface implemented by , this . static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { if ( context instanceof WildcardType ) { / / wildcards are useless for resolving supertypes . As the upper bound has the same raw type , use it instead context = ( ( WildcardType ) context ) . getUpperBounds ( ) [ 0 ] ; } checkArgument ( supertype . isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $ Gson $ Types . getGenericSupertype ( context , contextRawType , supertype ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_18"}
{"buggy_code": "if ( ! clazz . isAssignableFrom ( requestedType ) ) { return null ; } return ( TypeAdapter < T2 > ) typeAdapter ; } @ Override public String toString ( ) { return \" Factory [ typeHierarchy = \" + clazz . getName ( ) + \" , adapter = \" + typeAdapter + \" ] \" ;", "fixed_code": "if ( ! clazz . isAssignableFrom ( requestedType ) ) { return null ; } return ( TypeAdapter < T2 > ) new TypeAdapter < T1 > ( ) { @ Override public void write ( JsonWriter out , T1 value ) throws IOException { typeAdapter . write ( out , value ) ; } @ Override public T1 read ( JsonReader in ) throws IOException { T1 result = typeAdapter . read ( in ) ; if ( result ! = null & & ! requestedType . isInstance ( result ) ) { throw new JsonSyntaxException ( \" Expected a \" + requestedType . getName ( ) + \" but was \" + result . getClass ( ) . getName ( ) ) ; } return result ; } } ; } @ Override public String toString ( ) { return \" Factory [ typeHierarchy = \" + clazz . getName ( ) + \" , adapter = \" + typeAdapter + \" ] \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_2"}
{"buggy_code": "import java . util . SortedSet ; import java . util . TreeMap ; import java . util . TreeSet ; import com . google . gson . InstanceCreator ; import com . google . gson . JsonIOException ; } if ( Map . class . isAssignableFrom ( rawType ) ) { if ( SortedMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ;", "fixed_code": "import java . util . SortedSet ; import java . util . TreeMap ; import java . util . TreeSet ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentNavigableMap ; import java . util . concurrent . ConcurrentSkipListMap ; import com . google . gson . InstanceCreator ; import com . google . gson . JsonIOException ; } if ( Map . class . isAssignableFrom ( rawType ) ) { if ( ConcurrentNavigableMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new ConcurrentSkipListMap < Object , Object > ( ) ; } } ; } else if ( ConcurrentMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new ConcurrentHashMap < Object , Object > ( ) ; } } ; } else if ( SortedMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_3"}
{"buggy_code": "* bracket . private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( true ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; string ( value ) ; return this ; } return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; out . append ( value ) ; return this ; } return this ; / / skip the name and the value } } beforeValue ( false ) ; out . write ( \" null \" ) ; return this ; } public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; } throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; out . append ( Double . toString ( value ) ) ; return this ; } public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( Long . toString ( value ) ) ; return this ; } & & ( string . equals ( \" - Infinity \" ) | | string . equals ( \" Infinity \" ) | | string . equals ( \" NaN \" ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( false ) ; out . append ( string ) ; return this ; } * closing bracket or another element . @ SuppressWarnings ( \" fallthrough \" ) private void beforeValue ( boolean root ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT : if ( ! lenient ) { } / / fall - through case EMPTY_DOCUMENT : / / first in document if ( ! lenient & & ! root ) { throw new IllegalStateException ( \" JSON must start with an array or an object . \" ) ; } replaceTop ( NONEMPTY_DOCUMENT ) ; break ;", "fixed_code": "* bracket . private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; string ( value ) ; return this ; } return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . append ( value ) ; return this ; } return this ; / / skip the name and the value } } beforeValue ( ) ; out . write ( \" null \" ) ; return this ; } public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; } throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . append ( Double . toString ( value ) ) ; return this ; } public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out . write ( Long . toString ( value ) ) ; return this ; } & & ( string . equals ( \" - Infinity \" ) | | string . equals ( \" Infinity \" ) | | string . equals ( \" NaN \" ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ; out . append ( string ) ; return this ; } * closing bracket or another element . @ SuppressWarnings ( \" fallthrough \" ) private void beforeValue ( ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT : if ( ! lenient ) { } / / fall - through case EMPTY_DOCUMENT : / / first in document replaceTop ( NONEMPTY_DOCUMENT ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_4"}
{"buggy_code": "checkLenient ( ) ; return peeked = PEEKED_SINGLE_QUOTED ; case ' \" ' : if ( stackSize = = 1 ) { checkLenient ( ) ; } return peeked = PEEKED_DOUBLE_QUOTED ; case ' [ ' : return peeked = PEEKED_BEGIN_ARRAY ; default : pos - - ; / / Don ' t consume the first character in a literal value . } if ( stackSize = = 1 ) { checkLenient ( ) ; } int result = peekKeyword ( ) ; if ( result ! = PEEKED_NONE ) {", "fixed_code": "checkLenient ( ) ; return peeked = PEEKED_SINGLE_QUOTED ; case ' \" ' : return peeked = PEEKED_DOUBLE_QUOTED ; case ' [ ' : return peeked = PEEKED_BEGIN_ARRAY ; default : pos - - ; / / Don ' t consume the first character in a literal value . } int result = peekKeyword ( ) ; if ( result ! = PEEKED_NONE ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Gson_4"}
{"buggy_code": "String timezoneOffset = date . substring ( offset ) ; / / When timezone has no minutes , we should append it , valid timezones are , for example : + 00 : 00 , + 0000 and + 00 offset + = timezoneOffset . length ( ) ; / / 18 - Jun - 2015 , tatu : Minor simplification , skip offset of \" + 0000 \" / \" + 00 : 00 \"", "fixed_code": "String timezoneOffset = date . substring ( offset ) ; / / When timezone has no minutes , we should append it , valid timezones are , for example : + 00 : 00 , + 0000 and + 00 timezoneOffset = timezoneOffset . length ( ) > = 5 ? timezoneOffset : timezoneOffset + \" 00 \" ; offset + = timezoneOffset . length ( ) ; / / 18 - Jun - 2015 , tatu : Minor simplification , skip offset of \" + 0000 \" / \" + 00 : 00 \"", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_5"}
{"buggy_code": "throw new IllegalArgumentException ( \" @ JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference . \" ) ; } typeAdapter = typeAdapter . nullSafe ( ) ; return typeAdapter ; } }", "fixed_code": "throw new IllegalArgumentException ( \" @ JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference . \" ) ; } if ( typeAdapter ! = null ) { typeAdapter = typeAdapter . nullSafe ( ) ; } return typeAdapter ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_6"}
{"buggy_code": "if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED ) { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; try { long result = Long . parseLong ( peekedString ) ; peeked = PEEKED_NONE ; if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED ) { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; try { result = Integer . parseInt ( peekedString ) ; peeked = PEEKED_NONE ;", "fixed_code": "if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED | | p = = PEEKED_UNQUOTED ) { if ( p = = PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; } try { long result = Long . parseLong ( peekedString ) ; peeked = PEEKED_NONE ; if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED | | p = = PEEKED_UNQUOTED ) { if ( p = = PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; } try { result = Integer . parseInt ( peekedString ) ; peeked = PEEKED_NONE ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_7"}
{"buggy_code": "import java . io . ObjectStreamClass ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; }", "fixed_code": "import java . io . ObjectStreamClass ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; private static void assertInstantiable ( Class < ? > c ) { int modifiers = c . getModifiers ( ) ; if ( Modifier . isInterface ( modifiers ) ) { throw new UnsupportedOperationException ( \" Interface can ' t be instantiated ! Interface name : \" + c . getName ( ) ) ; } if ( Modifier . isAbstract ( modifiers ) ) { throw new UnsupportedOperationException ( \" Abstract class can ' t be instantiated ! Class name : \" + c . getName ( ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_8"}
{"buggy_code": "* * @ return this writer .", "fixed_code": "* * @ return this writer . public JsonWriter value ( Boolean value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Gson_9"}
{"buggy_code": "return this ; } @ Override public JsonWriter value ( double value ) throws IOException { if ( ! isLenient ( ) & & ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) ) {", "fixed_code": "return this ; } @ Override public JsonWriter value ( Boolean value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } put ( new JsonPrimitive ( value ) ) ; return this ; } @ Override public JsonWriter value ( double value ) throws IOException { if ( ! isLenient ( ) & & ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Gson_9"}
{"buggy_code": "} @ Override public void write ( JsonWriter out , Boolean value ) throws IOException { if ( value = = null ) { out . nullValue ( ) ; return ; } out . value ( value ) ; } } ;", "fixed_code": "} @ Override public void write ( JsonWriter out , Boolean value ) throws IOException { out . value ( value ) ; } } ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Gson_9"}
{"buggy_code": "public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { return new BigDecimal ( numStr ) ; } public static BigDecimal parseBigDecimal ( char [ ] buffer ) throws NumberFormatException { public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { return new BigDecimal ( buffer , offset , len ) ; } }", "fixed_code": "public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { try { return new BigDecimal ( numStr ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( numStr ) ; } } public static BigDecimal parseBigDecimal ( char [ ] buffer ) throws NumberFormatException { public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { try { return new BigDecimal ( buffer , offset , len ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( new String ( buffer , offset , len ) ) ; } } private static NumberFormatException _badBigDecimal ( String str ) { return new NumberFormatException ( \" Value \\ \" \" + str + \" \\ \" can not be represented as BigDecimal \" ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_1"}
{"buggy_code": "return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( _inputStart > = 0 ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( _segmentSize = = 0 ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "fixed_code": "return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( ( _inputStart > = 0 ) & & ( _inputBuffer ! = null ) ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( ( _segmentSize = = 0 ) & & ( _currentSegment ! = null ) ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_1"}
{"buggy_code": "if ( _spilloverEnd > = hashArea . length ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } * to work it out , but this is the simplest , fast and seems to do ok . hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash > > > 12 ) ; return hash ; }", "fixed_code": "final int end = ( _hashSize < < 3 ) ; if ( _spilloverEnd > = end ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } * to work it out , but this is the simplest , fast and seems to do ok . hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash < < 3 ) ; / / shuffle back a bit hash + = ( hash > > > 12 ) ; / / and bit more return hash ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_10"}
{"buggy_code": "_hashShared = false ; / / 09 - Sep - 2015 , tatu : As per [ jackson - core # 216 ] , also need to ensure / / we rehash as needed , as need - rehash flag is not copied from parent } if ( _needRehash ) { rehash ( ) ;", "fixed_code": "_hashShared = false ; / / 09 - Sep - 2015 , tatu : As per [ jackson - core # 216 ] , also need to ensure / / we rehash as needed , as need - rehash flag is not copied from parent _verifyNeedForRehash ( ) ; } if ( _needRehash ) { rehash ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_11"}
{"buggy_code": "_nameInputTotal , - 1L , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , getTokenCharacterOffset ( ) , - 1L , getTokenLineNr ( ) , getTokenColumnNr ( ) ) ; }", "fixed_code": "_nameInputTotal , - 1L , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , _tokenInputTotal , - 1L , _tokenInputRow , getTokenColumnNr ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_12"}
{"buggy_code": "if ( _parsingContext . expectComma ( ) ) { i = _skipComma ( i ) ; } _updateLocation ( ) ;", "fixed_code": "if ( _parsingContext . expectComma ( ) ) { i = _skipComma ( i ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_12"}
{"buggy_code": "return this ; } @ Override protected void _checkStdFeatureChanges ( int newFeatureFlags , int changedFeatures ) {", "fixed_code": "return this ; } @ Override public JsonGenerator disable ( Feature f ) { super . disable ( f ) ; if ( f = = Feature . QUOTE_FIELD_NAMES ) { _cfgUnqNames = true ; } return this ; } @ Override protected void _checkStdFeatureChanges ( int newFeatureFlags , int changedFeatures ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_13"}
{"buggy_code": "protected final void _verifyRelease ( byte [ ] toRelease , byte [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < = src . length ) ) { throw wrongBuf ( ) ; } } protected final void _verifyRelease ( char [ ] toRelease , char [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < = src . length ) ) { throw wrongBuf ( ) ; } } private IllegalArgumentException wrongBuf ( ) { / / sanity check failed ; trying to return different , smaller buffer . return new IllegalArgumentException ( \" Trying to release buffer not owned by the context \" ) ; } }", "fixed_code": "protected final void _verifyRelease ( byte [ ] toRelease , byte [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < src . length ) ) { throw wrongBuf ( ) ; } } protected final void _verifyRelease ( char [ ] toRelease , char [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < src . length ) ) { throw wrongBuf ( ) ; } } private IllegalArgumentException wrongBuf ( ) { / / sanity check failed ; trying to return different , smaller buffer . return new IllegalArgumentException ( \" Trying to release buffer smaller than original \" ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_14"}
{"buggy_code": "/ / Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken / / check for no buffered context _exposedContext - null / / If all the conditions matches then check for scalar / non - scalar property / / if not scalar and ended successfully , then return null / / else if scalar , and scalar not present in obj / array and ! includePath and INCLUDE_ALL matched once / / then return null / / Anything buffered ? TokenFilterContext ctxt = _exposedContext ;", "fixed_code": "/ / Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken / / check for no buffered context _exposedContext - null / / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & _currToken ! = null & & _exposedContext = = null ) { / / if not scalar and ended successfully , then return null if ( ( _currToken . isStructEnd ( ) & & _headContext . isStartHandled ( ) ) ) { return ( _currToken = null ) ; } / / else if scalar , and scalar not present in obj / array and ! includePath and INCLUDE_ALL matched once / / then return null else if ( _currToken . isScalarValue ( ) & & ! _headContext . isStartHandled ( ) & & ! _includePath & & _itemFilter = = TokenFilter . INCLUDE_ALL ) { return ( _currToken = null ) ; } } / / Anything buffered ? TokenFilterContext ctxt = _exposedContext ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_15"}
{"buggy_code": "* * @ since 2 . 8", "fixed_code": "* * @ since 2 . 8 protected boolean _suppressNextToken ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_16"}
{"buggy_code": "final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . while ( len > 0 ) { int len2 = Math . min ( buf . length , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; writeRaw ( buf , 0 , len2 ) ; / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it offset + = len2 ; len - = len2 ; } * * @ since 2 . 8 . 2", "fixed_code": "final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy if ( len < = buf . length ) { text . getChars ( offset , offset + len , buf , 0 ) ; _writeRawSegment ( buf , 0 , len ) ; return ; } / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . final int maxChunk = ( _outputEnd > > 2 ) + ( _outputEnd > > 4 ) ; / / = = ( 1 / 4 + 1 / 16 ) = = 5 / 16 final int maxBytes = maxChunk * 3 ; while ( len > 0 ) { int len2 = Math . min ( maxChunk , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; if ( ( _outputTail + maxBytes ) > _outputEnd ) { _flushBuffer ( ) ; } / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it if ( len > 0 ) { char ch = buf [ len2 - 1 ] ; if ( ( ch > = SURR1_FIRST ) & & ( ch < = SURR1_LAST ) ) { - - len2 ; } } _writeRawSegment ( buf , 0 , len2 ) ; offset + = len2 ; len - = len2 ; } * * @ since 2 . 8 . 2 private void _writeRawSegment ( char [ ] cbuf , int offset , int end ) throws IOException { main_loop : while ( offset < end ) { inner_loop : while ( true ) { int ch = ( int ) cbuf [ offset ] ; if ( ch > 0x7F ) { break inner_loop ; } _outputBuffer [ _outputTail + + ] = ( byte ) ch ; if ( + + offset > = end ) { break main_loop ; } } char ch = cbuf [ offset + + ] ; if ( ch < 0x800 ) { / / 2 - byte ? _outputBuffer [ _outputTail + + ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; _outputBuffer [ _outputTail + + ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { offset = _outputRawMultiByteChar ( ch , cbuf , offset , end ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_17"}
{"buggy_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "fixed_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_18"}
{"buggy_code": "* * @ since 2 . 7 . 7 protected String _asString ( BigDecimal value ) throws IOException { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector return value . toString ( ) ; }", "fixed_code": "* * @ since 2 . 7 . 7 protected final static int MAX_BIG_DECIMAL_SCALE = 9999 ; protected String _asString ( BigDecimal value ) throws IOException { if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector int scale = value . scale ( ) ; if ( ( scale < - MAX_BIG_DECIMAL_SCALE ) | | ( scale > MAX_BIG_DECIMAL_SCALE ) ) { _reportError ( String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , scale , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ) ; } return value . toPlainString ( ) ; } return value . toString ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_18"}
{"buggy_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "fixed_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonCore_18"}
{"buggy_code": "/ / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "fixed_code": "/ / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_19"}
{"buggy_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction outBuf [ outPtr + + ] = c ; fract_loop :", "fixed_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = c ; fract_loop :", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_19"}
{"buggy_code": "- _inputPtr ; / / to push back trailing char ( comma etc ) _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here / / And there we have it ! return resetInt ( negative , intLen ) ; - _inputPtr ; / / to push back trailing char ( comma etc ) _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here / / And there we have it ! return resetInt ( negative , intPartLength ) ; if ( ! eof ) { - _inputPtr ; / / As per # 105 , need separating space between root values ; check here } _textBuffer . setCurrentLength ( outPtr ) ; * NOTE : caller MUST ensure there is at least one character available ; * and that input pointer is AT given char ( not past ) / / caller had pushed it back , before calling ; reset / / TODO ? Handle UTF - 8 char decoding for error reporting", "fixed_code": "_textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } / / And there we have it ! return resetInt ( negative , intLen ) ; _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( _inputBuffer [ _inputPtr + + ] & 0xFF ) ; } / / And there we have it ! return resetInt ( negative , intPartLength ) ; if ( ! eof ) { / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; * NOTE : caller MUST ensure there is at least one character available ; * and that input pointer is AT given char ( not past ) private final void _verifyRootSpace ( int ch ) throws IOException { / / caller had pushed it back , before calling ; reset + + _inputPtr ; / / TODO ? Handle UTF - 8 char decoding for error reporting switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_2"}
{"buggy_code": "- ptr ; / / need to push back following separator _inputPtr = ptr ; / / As per # 105 , need separating space between root values ; check here int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { - _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! * NOTE : caller MUST ensure there is at least one character available ; * and that input pointer is AT given char ( not past ) / / caller had pushed it back , before calling ; reset", "fixed_code": "_inputPtr = ptr ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( ch ) ; } int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! * NOTE : caller MUST ensure there is at least one character available ; * and that input pointer is AT given char ( not past ) private final void _verifyRootSpace ( int ch ) throws IOException { / / caller had pushed it back , before calling ; reset + + _inputPtr ; switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_2"}
{"buggy_code": "public void writeEmbeddedObject ( Object object ) throws IOException { / / 01 - Sep - 2016 , tatu : As per [ core # 318 ] , handle small number of cases throw new JsonGenerationException ( \" No native support for writing embedded objects \" , this ) ; }", "fixed_code": "public void writeEmbeddedObject ( Object object ) throws IOException { / / 01 - Sep - 2016 , tatu : As per [ core # 318 ] , handle small number of cases if ( object = = null ) { writeNull ( ) ; return ; } if ( object instanceof byte [ ] ) { writeBinary ( ( byte [ ] ) object ) ; return ; } throw new JsonGenerationException ( \" No native support for writing embedded objects of type \" + object . getClass ( ) . getName ( ) , this ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_20"}
{"buggy_code": "/ / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { / / if not scalar and ended successfully , and ! includePath , then return null if ( _currToken . isStructEnd ( ) ) { if ( _headContext . isStartHandled ( ) ) { return ( _currToken = null ) ; if ( ! _headContext . isStartHandled ( ) & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } } / / Anything buffered ?", "fixed_code": "/ / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { / / if not scalar and ended successfully , and ! includePath , then return null if ( ! _includePath ) { if ( _currToken . isStructEnd ( ) ) { if ( _headContext . isStartHandled ( ) ) { return ( _currToken = null ) ; if ( ! _headContext . isStartHandled ( ) & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } } } / / Anything buffered ?", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_21"}
{"buggy_code": "} _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _includePath ) { return ( _currToken = t ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return ( _currToken = t ) ; } } / / Otherwise not included ( leaves must be explicitly included ) } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _includePath ) { return ( _currToken = t ) ; } / / if ( _includeImmediateParent ) { . . . f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return ( _currToken = t ) ; } } / / Otherwise not included ( leaves must be explicitly included ) continue main_loop ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { return _nextBuffered ( buffRoot ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return _nextBuffered ( buffRoot ) ; } } / / Otherwise not included ( leaves must be explicitly included ) } } @ Override public JsonToken nextValue ( ) throws IOException {", "fixed_code": "} _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _verifyAllowedMatches ( ) & & _includePath ) { return ( _currToken = t ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return ( _currToken = t ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _verifyAllowedMatches ( ) & & _includePath ) { return ( _currToken = t ) ; } / / if ( _includeImmediateParent ) { . . . f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return ( _currToken = t ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) continue main_loop ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL & & _verifyAllowedMatches ( ) ) { return _nextBuffered ( buffRoot ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return _nextBuffered ( buffRoot ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) } } private final boolean _verifyAllowedMatches ( ) throws IOException { if ( _matchCount = = 0 | | _allowMultipleMatches ) { + + _matchCount ; return true ; } return false ; } @ Override public JsonToken nextValue ( ) throws IOException {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_22"}
{"buggy_code": "@ Override public DefaultPrettyPrinter createInstance ( ) { return new DefaultPrettyPrinter ( this ) ; }", "fixed_code": "@ Override public DefaultPrettyPrinter createInstance ( ) { if ( getClass ( ) ! = DefaultPrettyPrinter . class ) { / / since 2 . 10 throw new IllegalStateException ( \" Failed ` createInstance ( ) ` : \" + getClass ( ) . getName ( ) + \" does not override method ; it has to \" ) ; } return new DefaultPrettyPrinter ( this ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_23"}
{"buggy_code": "/ / @ since 2 . 9 . 8 protected void _reportTooLongIntegral ( int expType , String rawNum ) throws IOException { final String numDesc = _longIntegerDesc ( rawNum ) ; _reportError ( \" Numeric value ( % s ) out of range of % s \" , numDesc , ( expType = = NR_LONG ) ? \" long \" : \" int \" ) ; }", "fixed_code": "/ / @ since 2 . 9 . 8 protected void _reportTooLongIntegral ( int expType , String rawNum ) throws IOException { if ( expType = = NR_INT ) { reportOverflowInt ( rawNum ) ; } else { reportOverflowLong ( rawNum ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_24"}
{"buggy_code": "/ / @ since 2 . 10 protected void reportOverflowInt ( String numDesc ) throws IOException { _reportError ( String . format ( \" Numeric value ( % s ) out of range of int ( % d - % s ) \" , _longIntegerDesc ( numDesc ) , Integer . MIN_VALUE , Integer . MAX_VALUE ) ) ; } / / @ since 2 . 10", "fixed_code": "/ / @ since 2 . 10 protected void reportOverflowInt ( String numDesc ) throws IOException { reportOverflowInt ( numDesc , JsonToken . VALUE_NUMBER_INT ) ; } / / @ since 2 . 10 protected void reportOverflowInt ( String numDesc , JsonToken inputType ) throws IOException { _reportInputCoercion ( String . format ( \" Numeric value ( % s ) out of range of int ( % d - % s ) \" , _longIntegerDesc ( numDesc ) , Integer . MIN_VALUE , Integer . MAX_VALUE ) , inputType , Integer . TYPE ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_24"}
{"buggy_code": "} char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i < = maxCode ) { if ( codes [ i ] ! = 0 ) { break ; }", "fixed_code": "} char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i < maxCode ) { if ( codes [ i ] ! = 0 ) { break ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_25"}
{"buggy_code": "_currInputRowStart = start - ( _inputEnd - _currInputRowStart ) ; / / And then update buffer settings _inputBuffer = buf ; _inputPtr = start ; _inputEnd = end ;", "fixed_code": "_currInputRowStart = start - ( _inputEnd - _currInputRowStart ) ; / / And then update buffer settings _currBufferStart = start ; _inputBuffer = buf ; _inputPtr = start ; _inputEnd = end ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_26"}
{"buggy_code": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; / / If we have offset , need to omit that from byte offset , so : _bufferRecyclable = bufferRecyclable ; }", "fixed_code": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; _currInputRowStart = start ; / / If we have offset , need to omit that from byte offset , so : _currInputProcessed = - start ; _bufferRecyclable = bufferRecyclable ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_3"}
{"buggy_code": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; / / but above intended maximum , slow to increase by 25 % int newLen = ( len = = MAX_SEGMENT_LEN ) ? ( MAX_SEGMENT_LEN + 1 ) : Math . min ( MAX_SEGMENT_LEN , len + ( len > > 1 ) ) ; return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; }", "fixed_code": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; int newLen = len + ( len > > 1 ) ; / / but above intended maximum , slow to increase by 25 % if ( newLen > MAX_SEGMENT_LEN ) { newLen = len + ( len > > 2 ) ; } return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_4"}
{"buggy_code": "return - 1 ; } for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i + + ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "fixed_code": "return - 1 ; } for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_5"}
{"buggy_code": "return - 1 ; } / / [ core # 176 ] : no leading zeroes allowed for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "fixed_code": "return - 1 ; } / / [ core # 176 ] : no leading zeroes allowed char c = str . charAt ( 0 ) ; if ( c < = ' 0 ' ) { return ( len = = 1 & & c = = ' 0 ' ) ? 0 : - 1 ; } if ( c > ' 9 ' ) { return - 1 ; } for ( int i = 1 ; i < len ; + + i ) { c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_6"}
{"buggy_code": "public int writeValue ( ) { / / Most likely , object : if ( _type = = TYPE_OBJECT ) { _gotName = false ; return STATUS_OK_AFTER_COLON ;", "fixed_code": "public int writeValue ( ) { / / Most likely , object : if ( _type = = TYPE_OBJECT ) { if ( ! _gotName ) { return STATUS_EXPECT_NAME ; } _gotName = false ; + _index ; return STATUS_OK_AFTER_COLON ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_7"}
{"buggy_code": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "fixed_code": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments & & _currentSegment ! = null ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_8"}
{"buggy_code": "} return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( null ) ; } } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( defValue ) ; }", "fixed_code": "} return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( null ) ; } } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( defValue ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonCore_9"}
{"buggy_code": "if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } return getValueAsString ( null ) ; } if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; }", "fixed_code": "if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return getValueAsString ( null ) ; } if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonCore_9"}
{"buggy_code": "} else { / / can NOT suppress entries in tabular output jgen . writeNull ( ) ; } } / / otherwise find serializer to use JsonSerializer < Object > ser = _serializer ;", "fixed_code": "} else { / / can NOT suppress entries in tabular output jgen . writeNull ( ) ; } return ; } / / otherwise find serializer to use JsonSerializer < Object > ser = _serializer ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_1"}
{"buggy_code": "TypeSerializer typeSer = createTypeSerializer ( config , valueType ) ; / / last 2 nulls ; don ' t know key , value serializers ( yet ) / / 23 - Feb - 2015 , tatu : As per [ # 705 ] , need to support custom serializers MapSerializer anySer = MapSerializer . construct ( null , type , staticTyping , typeSer , null , null , null ) ; / / TODO : support ' @ JsonIgnoreProperties ' with any setter ? / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "fixed_code": "TypeSerializer typeSer = createTypeSerializer ( config , valueType ) ; / / last 2 nulls ; don ' t know key , value serializers ( yet ) / / 23 - Feb - 2015 , tatu : As per [ # 705 ] , need to support custom serializers JsonSerializer < ? > anySer = findSerializerFromAnnotation ( prov , anyGetter ) ; if ( anySer = = null ) { / / TODO : support ' @ JsonIgnoreProperties ' with any setter ? } / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_10"}
{"buggy_code": "protected final AnnotatedMember _accessor ; protected MapSerializer _mapSerializer ; @ SuppressWarnings ( \" unchecked \" ) public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , MapSerializer serializer ) { _accessor = accessor ; _property = property ; _mapSerializer = ( MapSerializer ) serializer ; } public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } }", "fixed_code": "protected final AnnotatedMember _accessor ; protected JsonSerializer < Object > _serializer ; protected MapSerializer _mapSerializer ; @ SuppressWarnings ( \" unchecked \" ) public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , JsonSerializer < ? > serializer ) { _accessor = accessor ; _property = property ; _serializer = ( JsonSerializer < Object > ) serializer ; if ( serializer instanceof MapSerializer ) { _mapSerializer = ( MapSerializer ) serializer ; } } public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } _serializer . serialize ( value , gen , provider ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_10"}
{"buggy_code": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : byte [ ] data = n . binaryValue ( ) ; if ( data ! = null ) { return data ; } if ( n . isPojo ( ) ) { Object ob = ( ( POJONode ) n ) . getPojo ( ) ; if ( ob instanceof byte [ ] ) { return ( byte [ ] ) ob ; } } } / / otherwise return null to mark we have no binary content return null ;", "fixed_code": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : if ( n instanceof TextNode ) { return ( ( TextNode ) n ) . getBinaryValue ( b64variant ) ; } return n . binaryValue ( ) ; } / / otherwise return null to mark we have no binary content return null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_100"}
{"buggy_code": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "fixed_code": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants if ( t ! = JsonToken . END_OBJECT ) { ctxt . reportWrongTokenException ( this , JsonToken . END_OBJECT , \" Attempted to unwrap ' % s ' value \" , handledType ( ) . getName ( ) ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_101"}
{"buggy_code": "{ / / Note ! Should not skip if ` property ` null since that ' d skip check / / for config overrides , in case of root value if ( property = = null ) { return this ; } JsonFormat . Value format = findFormatOverrides ( serializers , property , handledType ( ) ) ; if ( format = = null ) { return this ;", "fixed_code": "{ / / Note ! Should not skip if ` property ` null since that ' d skip check / / for config overrides , in case of root value JsonFormat . Value format = findFormatOverrides ( serializers , property , handledType ( ) ) ; if ( format = = null ) { return this ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_102"}
{"buggy_code": "/ / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; / / doesn ' t matter but compiler whines otherwise reportMappingProblem ( iae , iae . getMessage ( ) ) ; } if ( ser ! = null ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; reportMappingProblem ( iae , iae . getMessage ( ) ) ; } if ( ser ! = null ) {", "fixed_code": "/ / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; / / doesn ' t matter but compiler whines otherwise reportMappingProblem ( iae , ClassUtil . exceptionMessage ( iae ) ) ; } if ( ser ! = null ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; reportMappingProblem ( iae , ClassUtil . exceptionMessage ( iae ) ) ; } if ( ser ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_103"}
{"buggy_code": "serializationType = findSerializationType ( am , defaultUseStaticTyping , declaredType ) ; } catch ( JsonMappingException e ) { if ( propDef = = null ) { return prov . reportBadDefinition ( declaredType , e . getMessage ( ) ) ; } return prov . reportBadPropertyDefinition ( _beanDesc , propDef , e . getMessage ( ) ) ; } / / Container types can have separate type serializers for content ( value / element ) type", "fixed_code": "serializationType = findSerializationType ( am , defaultUseStaticTyping , declaredType ) ; } catch ( JsonMappingException e ) { if ( propDef = = null ) { return prov . reportBadDefinition ( declaredType , ClassUtil . exceptionMessage ( e ) ) ; } return prov . reportBadPropertyDefinition ( _beanDesc , propDef , ClassUtil . exceptionMessage ( e ) ) ; } / / Container types can have separate type serializers for content ( value / element ) type", "label": 1, "tool_name": "Developer", "patch_name": "patch10", "project_name": "JacksonDatabind_103"}
{"buggy_code": "/ / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , e . getMessage ( ) , beanDesc , null ) ; } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder ( ctxt , beanDesc ) ; / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , e . getMessage ( ) , builderDesc , null ) ; } final DeserializationConfig config = ctxt . getConfig ( ) ;", "fixed_code": "/ / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , ClassUtil . exceptionMessage ( e ) , beanDesc , null ) ; } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder ( ctxt , beanDesc ) ; / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , ClassUtil . exceptionMessage ( e ) , builderDesc , null ) ; } final DeserializationConfig config = ctxt . getConfig ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch11", "project_name": "JacksonDatabind_103"}
{"buggy_code": "} catch ( Throwable t ) { String msg = String . format ( \" Problem determining whether filter of type ' % s ' should filter out ` null ` values : ( % s ) % s \" , filter . getClass ( ) . getName ( ) , t . getClass ( ) . getName ( ) , t . getMessage ( ) ) ; reportBadDefinition ( filter . getClass ( ) , msg , t ) ; return false ; / / never gets here } if ( e instanceof IOException ) { return ( IOException ) e ; } String msg = e . getMessage ( ) ; if ( msg = = null ) { msg = \" [ no message for \" + e . getClass ( ) . getName ( ) + \" ] \" ; }", "fixed_code": "} catch ( Throwable t ) { String msg = String . format ( \" Problem determining whether filter of type ' % s ' should filter out ` null ` values : ( % s ) % s \" , filter . getClass ( ) . getName ( ) , t . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( t ) ) ; reportBadDefinition ( filter . getClass ( ) , msg , t ) ; return false ; / / never gets here } if ( e instanceof IOException ) { return ( IOException ) e ; } String msg = ClassUtil . exceptionMessage ( e ) ; if ( msg = = null ) { msg = \" [ no message for \" + e . getClass ( ) . getName ( ) + \" ] \" ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch12", "project_name": "JacksonDatabind_103"}
{"buggy_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ;", "fixed_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( e ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch13", "project_name": "JacksonDatabind_103"}
{"buggy_code": ". append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , th . getMessage ( ) , th ) ; } @ Deprecated / / since 2 . 7", "fixed_code": ". append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , ClassUtil . exceptionMessage ( th ) , th ) ; } @ Deprecated / / since 2 . 7", "label": 1, "tool_name": "Developer", "patch_name": "patch14", "project_name": "JacksonDatabind_103"}
{"buggy_code": "} } return new JsonMappingException ( null , \" Instantiation of \" + getValueTypeDesc ( ) + \" value failed : \" + t . getMessage ( ) , t ) ; }", "fixed_code": "} } return new JsonMappingException ( null , \" Instantiation of \" + getValueTypeDesc ( ) + \" value failed : \" + ClassUtil . exceptionMessage ( t ) , t ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch15", "project_name": "JacksonDatabind_103"}
{"buggy_code": "} catch ( IllegalArgumentException iae ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle throw JsonMappingException . from ( ctxt , iae . getMessage ( ) , iae ) ; } if ( deser = = null ) { return null ;", "fixed_code": "} catch ( IllegalArgumentException iae ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle throw JsonMappingException . from ( ctxt , ClassUtil . exceptionMessage ( iae ) , iae ) ; } if ( deser = = null ) { return null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch16", "project_name": "JacksonDatabind_103"}
{"buggy_code": "import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ;", "fixed_code": "import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . util . ClassUtil ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_103"}
{"buggy_code": "StringBuilder msg = new StringBuilder ( \" Problem deserializing \\ \" any \\ \" property ' \" ) . append ( propName ) ; msg . append ( \" ' of class \" + getClassName ( ) + \" ( expected type : \" ) . append ( _type ) ; msg . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; } else { ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable t = ClassUtil . getRootCause ( e ) ; throw new JsonMappingException ( null , t . getMessage ( ) , t ) ; } private String getClassName ( ) { return _setter . getDeclaringClass ( ) . getName ( ) ; }", "fixed_code": "StringBuilder msg = new StringBuilder ( \" Problem deserializing \\ \" any \\ \" property ' \" ) . append ( propName ) ; msg . append ( \" ' of class \" + getClassName ( ) + \" ( expected type : \" ) . append ( _type ) ; msg . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; } else { ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable t = ClassUtil . getRootCause ( e ) ; throw new JsonMappingException ( null , ClassUtil . exceptionMessage ( t ) , t ) ; } private String getClassName ( ) { return _setter . getDeclaringClass ( ) . getName ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_103"}
{"buggy_code": "} catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , e . getMessage ( ) ) ) ; } } String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = cause . getMessage ( ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" ,", "fixed_code": "} catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , ClassUtil . exceptionMessage ( e ) ) ) ; } } String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = ClassUtil . exceptionMessage ( cause ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" ,", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "JacksonDatabind_103"}
{"buggy_code": "return b . buildTypeDeserializer ( config , baseType , subtypes ) ; } catch ( IllegalArgumentException e0 ) { InvalidDefinitionException e = InvalidDefinitionException . from ( ( JsonParser ) null , e0 . getMessage ( ) , baseType ) ; e . initCause ( e0 ) ; throw e ; }", "fixed_code": "return b . buildTypeDeserializer ( config , baseType , subtypes ) ; } catch ( IllegalArgumentException e0 ) { InvalidDefinitionException e = InvalidDefinitionException . from ( ( JsonParser ) null , ClassUtil . exceptionMessage ( e0 ) , baseType ) ; e . initCause ( e0 ) ; throw e ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "JacksonDatabind_103"}
{"buggy_code": "ClassUtil . throwIfRTE ( t ) ; throw new IllegalArgumentException ( \" Failed to instantiate bean of type \" + t . getMessage ( ) , t ) ; } }", "fixed_code": "ClassUtil . throwIfRTE ( t ) ; throw new IllegalArgumentException ( \" Failed to instantiate bean of type \" _classInfo . getAnnotated ( ) . getName ( ) + \" : ( \" + t . getClass ( ) . getName ( ) + \" ) \" + ClassUtil . exceptionMessage ( t ) , t ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch6", "project_name": "JacksonDatabind_103"}
{"buggy_code": "} catch ( IllegalArgumentException iae ) { return ( java . util . Date ) ctxt . handleWeirdStringValue ( _valueClass , value , \" not a valid representation ( error : % s ) \" , iae . getMessage ( ) ) ; } }", "fixed_code": "} catch ( IllegalArgumentException iae ) { return ( java . util . Date ) ctxt . handleWeirdStringValue ( _valueClass , value , \" not a valid representation ( error : % s ) \" , ClassUtil . exceptionMessage ( iae ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch7", "project_name": "JacksonDatabind_103"}
{"buggy_code": "} catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; / / @ since 2 . 9 protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , e . getMessage ( ) ) ; }", "fixed_code": "} catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( re ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; / / @ since 2 . 9 protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , ClassUtil . exceptionMessage ( e ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch8", "project_name": "JacksonDatabind_103"}
{"buggy_code": "import java . util . * ; import com . fasterxml . jackson . core . JsonGenerator ; import com . fasterxml . jackson . databind . DeserializationContext ; import com . fasterxml . jackson . databind . JavaType ; import com . fasterxml . jackson . databind . JsonMappingException ; * * @ since 2 . 9 . 7", "fixed_code": "import java . util . * ; import com . fasterxml . jackson . core . JsonGenerator ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . DeserializationContext ; import com . fasterxml . jackson . databind . JavaType ; import com . fasterxml . jackson . databind . JsonMappingException ; * * @ since 2 . 9 . 7 public static String exceptionMessage ( Throwable t ) { if ( t instanceof JsonProcessingException ) { return ( ( JsonProcessingException ) t ) . getOriginalMessage ( ) ; } return t . getMessage ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch9", "project_name": "JacksonDatabind_103"}
{"buggy_code": "final int year = cal . get ( Calendar . YEAR ) ; / / Assuming GregorianCalendar , special handling needed for BCE ( aka BC ) / / 22 - Nov - 2018 , tatu : Handling beyond 4 - digits is not well specified wrt ISO - 8601 , but / / it seems that plus prefix IS mandated . Padding is an open question , but since agreeement / / for max length would be needed , we ewould need to limit to arbitrary length / / like five digits ( erroring out if beyond or padding to that as minimum ) . / / Instead , let ' s just print number out as is and let decoder try to make sense of it . pad4 ( buffer , year ) ; buffer . append ( ' - ' ) ; pad2 ( buffer , cal . get ( Calendar . MONTH ) + 1 ) ; buffer . append ( ' - ' ) ; } } / / Ok . First of all , BCE 1 output ( given as value ` 1 ` in era BCE ) needs to become / / \" + 0000 \" , but rest ( from ` 2 ` up , in that era ) need minus sign . / / as with CE , 4 digit variant needs padding ; beyond that not ( although that part is / / open to debate , needs agreement with receiver ) / / But ` pad4 ( ) ` deals with \" big \" numbers now so : private static void pad2 ( StringBuffer buffer , int value ) { int tens = value / 10 ; if ( h = = 0 ) { buffer . append ( ' 0 ' ) . append ( ' 0 ' ) ; } else { pad2 ( buffer , h ) ; value - = ( 100 * h ) ; } pad2 ( buffer , value ) ;", "fixed_code": "final int year = cal . get ( Calendar . YEAR ) ; / / Assuming GregorianCalendar , special handling needed for BCE ( aka BC ) if ( cal . get ( Calendar . ERA ) = = GregorianCalendar . BC ) { _formatBCEYear ( buffer , year ) ; } else { if ( year > 9999 ) { / / 22 - Nov - 2018 , tatu : Handling beyond 4 - digits is not well specified wrt ISO - 8601 , but / / it seems that plus prefix IS mandated . Padding is an open question , but since agreeement / / for max length would be needed , we ewould need to limit to arbitrary length / / like five digits ( erroring out if beyond or padding to that as minimum ) . / / Instead , let ' s just print number out as is and let decoder try to make sense of it . buffer . append ( ' + ' ) ; } pad4 ( buffer , year ) ; } buffer . append ( ' - ' ) ; pad2 ( buffer , cal . get ( Calendar . MONTH ) + 1 ) ; buffer . append ( ' - ' ) ; } } protected void _formatBCEYear ( StringBuffer buffer , int bceYearNoSign ) { / / Ok . First of all , BCE 1 output ( given as value ` 1 ` in era BCE ) needs to become / / \" + 0000 \" , but rest ( from ` 2 ` up , in that era ) need minus sign . if ( bceYearNoSign = = 1 ) { buffer . append ( \" + 0000 \" ) ; return ; } final int isoYear = bceYearNoSign - 1 ; buffer . append ( ' - ' ) ; / / as with CE , 4 digit variant needs padding ; beyond that not ( although that part is / / open to debate , needs agreement with receiver ) / / But ` pad4 ( ) ` deals with \" big \" numbers now so : pad4 ( buffer , isoYear ) ; } private static void pad2 ( StringBuffer buffer , int value ) { int tens = value / 10 ; if ( h = = 0 ) { buffer . append ( ' 0 ' ) . append ( ' 0 ' ) ; } else { if ( h > 99 ) { / / [ databind # 2167 ] : handle above 9999 correctly buffer . append ( h ) ; } else { pad2 ( buffer , h ) ; } value - = ( 100 * h ) ; } pad2 ( buffer , value ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_104"}
{"buggy_code": "UUID . class , AtomicBoolean . class , StackTraceElement . class , ByteBuffer . class } ; for ( Class < ? > cls : types ) { _classNames . add ( cls . getName ( ) ) ; } for ( Class < ? > cls : FromStringDeserializer . types ( ) ) { _classNames . add ( cls . getName ( ) ) ; } if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } } return null ; }", "fixed_code": "UUID . class , AtomicBoolean . class , StackTraceElement . class , ByteBuffer . class , Void . class } ; for ( Class < ? > cls : types ) { _classNames . add ( cls . getName ( ) ) ; } for ( Class < ? > cls : FromStringDeserializer . types ( ) ) { _classNames . add ( cls . getName ( ) ) ; } if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } if ( rawType = = Void . class ) { return NullifyingDeserializer . instance ; } } return null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_105"}
{"buggy_code": "@ Override public int getIntValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; return node . intValue ( ) ; } @ Override public long getLongValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; return node . longValue ( ) ; }", "fixed_code": "@ Override public int getIntValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; if ( ! node . canConvertToInt ( ) ) { reportOverflowInt ( ) ; } return node . intValue ( ) ; } @ Override public long getLongValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; if ( ! node . canConvertToInt ( ) ) { reportOverflowLong ( ) ; } return node . longValue ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_106"}
{"buggy_code": "JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual = = null ) { / / what should this be taken to mean ? / / 17 - Jan - 2019 , tatu : As per [ databind # 2221 ] , better NOT return ` null ` but . . . return null ; } / / . . . would this actually work ? deser = ctxt . findContextualValueDeserializer ( actual , _property ) ;", "fixed_code": "JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual = = null ) { / / what should this be taken to mean ? / / 17 - Jan - 2019 , tatu : As per [ databind # 2221 ] , better NOT return ` null ` but . . . return NullifyingDeserializer . instance ; } / / . . . would this actually work ? deser = ctxt . findContextualValueDeserializer ( actual , _property ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_107"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) @ Override public < T extends TreeNode > T readTree ( JsonParser p ) throws IOException { return ( T ) _bindAsTree ( p ) ; } @ Override * Same as { @ link # _bindAsTree } except end - of - input is reported by returning * { @ code null } , not \" missing node \"", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) @ Override public < T extends TreeNode > T readTree ( JsonParser p ) throws IOException { return ( T ) _bindAsTreeOrNull ( p ) ; } @ Override * Same as { @ link # _bindAsTree } except end - of - input is reported by returning * { @ code null } , not \" missing node \" protected final JsonNode _bindAsTreeOrNull ( JsonParser p ) throws IOException { _config . initialize ( p ) ; if ( _schema ! = null ) { p . setSchema ( _schema ) ; } JsonToken t = p . getCurrentToken ( ) ; if ( t = = null ) { t = p . nextToken ( ) ; if ( t = = null ) { return null ; } } final JsonNode resultNode ; if ( t = = JsonToken . VALUE_NULL ) { resultNode = _config . getNodeFactory ( ) . nullNode ( ) ; } else { final DeserializationContext ctxt = createDeserializationContext ( p ) ; final JsonDeserializer < Object > deser = _findTreeDeserializer ( ctxt ) ; if ( _unwrapRoot ) { resultNode = ( JsonNode ) _unwrapAndDeserialize ( p , ctxt , JSON_NODE_TYPE , deser ) ; } else { resultNode = ( JsonNode ) deser . deserialize ( p , ctxt ) ; if ( _config . isEnabled ( DeserializationFeature . FAIL_ON_TRAILING_TOKENS ) ) { _verifyNoTrailingTokens ( p , ctxt , JSON_NODE_TYPE ) ; } } } return resultNode ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_108"}
{"buggy_code": "protected final boolean _isInt ; switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` return ToStringSerializer . instance ; default : } / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this / / . . . but wouldn ' t it be nice to trigger error via generator ? Alas , / / no method to do that . So we ' ll do . . . / / should never be called / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this }", "fixed_code": "protected final static int MAX_BIG_DECIMAL_SCALE = 9999 ; protected final boolean _isInt ; switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : } public static JsonSerializer < ? > bigDecimalAsStringSerializer ( ) { return BigDecimalAsStringSerializer . BD_INSTANCE ; } final static class BigDecimalAsStringSerializer extends ToStringSerializerBase { final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer ( ) ;  public BigDecimalAsStringSerializer ( ) { super ( BigDecimal . class ) ; } @ Override public boolean isEmpty ( SerializerProvider prov , Object value ) { return valueToString ( value ) . isEmpty ( ) ; } @ Override public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { final String text ; if ( gen . isEnabled ( JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { final BigDecimal bd = ( BigDecimal ) value ; / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this if ( ! _verifyBigDecimalRange ( gen , bd ) ) { / / . . . but wouldn ' t it be nice to trigger error via generator ? Alas , / / no method to do that . So we ' ll do . . . final String errorMsg = String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , bd . scale ( ) , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ; provider . reportMappingProblem ( errorMsg ) ; } text = bd . toPlainString ( ) ; } else { text = value . toString ( ) ; } gen . writeString ( text ) ; } @ Override public String valueToString ( Object value ) { / / should never be called throw new IllegalStateException ( ) ; } / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector , so we need this protected boolean _verifyBigDecimalRange ( JsonGenerator gen , BigDecimal value ) throws IOException { int scale = value . scale ( ) ; return ( ( scale > = - MAX_BIG_DECIMAL_SCALE ) & & ( scale < = MAX_BIG_DECIMAL_SCALE ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_109"}
{"buggy_code": "import java . io . IOException ; import java . lang . reflect . Type ; import java . util . Map ; import com . fasterxml . jackson . annotation . JsonFormat ; if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : return ToStringSerializer . instance ; default : }", "fixed_code": "import java . io . IOException ; import java . lang . reflect . Type ; import java . math . BigDecimal ; import java . util . Map ; import com . fasterxml . jackson . annotation . JsonFormat ; if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return NumberSerializer . bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_109"}
{"buggy_code": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : return _unknownType ( ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name ) ; if ( actualType ! = null ) { return actualType ; }", "fixed_code": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : context = new TypeBindings ( this , ( Class < ? > ) null ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name , false ) ; if ( actualType ! = null ) { return actualType ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_11"}
{"buggy_code": "private final static Class < ? > CLASS_UNMODIFIABLE_MAP ; static { CLASS_SINGLETON_LIST = list . getClass ( ) ; CLASS_UNMODIFIABLE_LIST = Collections . unmodifiableList ( list ) . getClass ( ) ; / / for [ databind # 2265 ] Map < ? , ? > map = Collections . singletonMap ( \" a \" , \" b \" ) ; CLASS_SINGLETON_MAP = map . getClass ( ) ; } else if ( type . hasRawClass ( CLASS_SINGLETON_SET ) ) { conv = converter ( TYPE_SINGLETON_SET , type , Set . class ) ; / / [ databind # 2265 ] : we may have another impl type for unmodifiable Lists , check both } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_LIST ) ) { conv = converter ( TYPE_UNMODIFIABLE_LIST , type , List . class ) ; } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_SET ) ) { conv = converter ( TYPE_UNMODIFIABLE_SET , type , Set . class ) ;", "fixed_code": "private final static Class < ? > CLASS_UNMODIFIABLE_LIST_ALIAS ; private final static Class < ? > CLASS_UNMODIFIABLE_MAP ; static { CLASS_SINGLETON_LIST = list . getClass ( ) ; CLASS_UNMODIFIABLE_LIST = Collections . unmodifiableList ( list ) . getClass ( ) ; / / for [ databind # 2265 ] CLASS_UNMODIFIABLE_LIST_ALIAS = Collections . unmodifiableList ( new LinkedList < Object > ( ) ) . getClass ( ) ; Map < ? , ? > map = Collections . singletonMap ( \" a \" , \" b \" ) ; CLASS_SINGLETON_MAP = map . getClass ( ) ; } else if ( type . hasRawClass ( CLASS_SINGLETON_SET ) ) { conv = converter ( TYPE_SINGLETON_SET , type , Set . class ) ; / / [ databind # 2265 ] : we may have another impl type for unmodifiable Lists , check both } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_LIST ) | | type . hasRawClass ( CLASS_UNMODIFIABLE_LIST_ALIAS ) ) { conv = converter ( TYPE_UNMODIFIABLE_LIST , type , List . class ) ; } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_SET ) ) { conv = converter ( TYPE_UNMODIFIABLE_SET , type , Set . class ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_110"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new CreatorProperty ( this , deser , _nullProvider ) ; } @ Override", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new CreatorProperty ( this , deser , nvp ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_111"}
{"buggy_code": "@ Override public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( ) ; } @ Override", "fixed_code": "@ Override public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( _valueDeserializer . getNullValue ( ctxt ) ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_111"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new FieldProperty ( this , deser , _nullProvider ) ; } @ Override Object readResolve ( ) { return new FieldProperty ( this ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new FieldProperty ( this , deser , nvp ) ; } @ Override Object readResolve ( ) { return new FieldProperty ( this ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_111"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new MethodProperty ( this , deser , _nullProvider ) ; } @ Override", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new MethodProperty ( this , deser , nvp ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "JacksonDatabind_111"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new SetterlessProperty ( this , deser , _nullProvider ) ; } @ Override set ( instance , value ) ; return instance ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new SetterlessProperty ( this , deser , nvp ) ; } @ Override set ( instance , value ) ; return instance ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "JacksonDatabind_111"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdReferenceProperty ( this , deser , _nullProvider ) ; } @ Override", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdReferenceProperty ( this , deser , nvp ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch6", "project_name": "JacksonDatabind_111"}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdValueProperty ( this , deser , _nullProvider ) ; } @ Override", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdValueProperty ( this , deser , nvp ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch7", "project_name": "JacksonDatabind_111"}
{"buggy_code": "JsonDeserializer < Object > delegate = null ; if ( _valueInstantiator ! = null ) { / / [ databind # 2324 ] : check both array - delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator . getDelegateCreator ( ) ; if ( delegateCreator ! = null ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; }", "fixed_code": "JsonDeserializer < Object > delegate = null ; if ( _valueInstantiator ! = null ) { / / [ databind # 2324 ] : check both array - delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator . getArrayDelegateCreator ( ) ; if ( delegateCreator ! = null ) { JavaType delegateType = _valueInstantiator . getArrayDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; } else if ( ( delegateCreator = _valueInstantiator . getDelegateCreator ( ) ) ! = null ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_112"}
{"buggy_code": "return ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; }", "fixed_code": "return ( _valueDeserializer = = null ) & & ( _keyDeserializer = = null ) & & ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_12"}
{"buggy_code": "* will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "fixed_code": "* will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_13"}
{"buggy_code": "final ObjectIdGenerator . IdKey key = gen . key ( id ) ;", "fixed_code": "if ( id = = null ) { return null ; } final ObjectIdGenerator . IdKey key = gen . key ( id ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_13"}
{"buggy_code": "result = NullNode . instance ; } else { DeserializationContext ctxt = createDeserializationContext ( jp , _config ) ; JsonDeserializer < Object > deser = _findRootDeserializer ( ctxt , JSON_NODE_TYPE ) ; if ( _unwrapRoot ) { result = ( JsonNode ) _unwrapAndDeserialize ( jp , ctxt , JSON_NODE_TYPE , deser ) ; } else { / / Nope : need to ask provider to resolve it", "fixed_code": "result = NullNode . instance ; } else { DeserializationContext ctxt = createDeserializationContext ( jp , _config ) ; JsonDeserializer < Object > deser = _findTreeDeserializer ( ctxt ) ; if ( _unwrapRoot ) { result = ( JsonNode ) _unwrapAndDeserialize ( jp , ctxt , JSON_NODE_TYPE , deser ) ; } else { protected JsonDeserializer < Object > _findTreeDeserializer ( DeserializationContext ctxt ) throws JsonMappingException { JsonDeserializer < Object > deser = _rootDeserializers . get ( JSON_NODE_TYPE ) ; if ( deser = = null ) { / / Nope : need to ask provider to resolve it deser = ctxt . findRootValueDeserializer ( JSON_NODE_TYPE ) ; if ( deser = = null ) { / / can this happen ? throw new JsonMappingException ( \" Can not find a deserializer for type \" + JSON_NODE_TYPE ) ; } _rootDeserializers . put ( JSON_NODE_TYPE , deser ) ; } return deser ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_14"}
{"buggy_code": "* * @ since 2 . 5", "fixed_code": "* * @ since 2 . 5 public final boolean isJavaLangObject ( ) { return _class = = Object . class ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_15"}
{"buggy_code": "delSer = provider . findValueSerializer ( delegateType ) ; } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } return ( delSer = = _delegateSerializer ) ? this : withDelegate ( _converter , delegateType , delSer ) ; } Object delegateValue = convertValue ( value ) ; _delegateSerializer . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } @ Override public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( delegateValue ) ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } * properly . . . but for now , try this : / / 02 - Apr - 2015 , tatu : For dynamic case , very little we can do _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } / / NOTE : will NOT call contextualization }", "fixed_code": "if ( ! delegateType . isJavaLangObject ( ) ) { delSer = provider . findValueSerializer ( delegateType ) ; } } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } if ( delSer = = _delegateSerializer & & delegateType = = _delegateType ) { return this ; } return withDelegate ( _converter , delegateType , delSer ) ; } Object delegateValue = convertValue ( value ) ; JsonSerializer < Object > ser = _delegateSerializer ; if ( ser = = null ) { ser = _findSerializer ( value , provider ) ; } ser . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } @ Override public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( delegateValue ) ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } * properly . . . but for now , try this : / / 02 - Apr - 2015 , tatu : For dynamic case , very little we can do if ( _delegateSerializer ! = null ) { _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } } protected JsonSerializer < Object > _findSerializer ( Object value , SerializerProvider serializers ) throws JsonMappingException { / / NOTE : will NOT call contextualization return serializers . findValueSerializer ( value . getClass ( ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_15"}
{"buggy_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object JsonSerializer < ? > ser = provider . findValueSerializer ( delegateType , prop ) ; return new StdDelegatingSerializer ( conv , delegateType , ser ) ; } }", "fixed_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object JsonSerializer < ? > ser = delegateType . isJavaLangObject ( ) ? null : provider . findValueSerializer ( delegateType , prop ) ; return new StdDelegatingSerializer ( conv , delegateType , ser ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_15"}
{"buggy_code": "ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ;", "fixed_code": "ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null & & ! delegateType . isJavaLangObject ( ) ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "JacksonDatabind_15"}
{"buggy_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "fixed_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null & & ! delegateType . hasRawClass ( Object . class ) ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "JacksonDatabind_15"}
{"buggy_code": "_annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous ! = null ) & & previous . equals ( ann ) ; } }", "fixed_code": "_annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous = = null ) | | ! previous . equals ( ann ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_16"}
{"buggy_code": "return ( t . getRawClass ( ) = = Object . class ) | | ( ! t . isConcrete ( ) / / [ databind # 88 ] Should not apply to JSON tree models : | | TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) {", "fixed_code": "return ( t . getRawClass ( ) = = Object . class ) | | ( ! t . isConcrete ( ) / / [ databind # 88 ] Should not apply to JSON tree models : & & ! TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_17"}
{"buggy_code": "protected JsonParser _parser ; protected boolean _hasNextChecked ; if ( managedParser & & ( p ! = null ) & & p . isExpectedStartArrayToken ( ) ) { / / If pointing to START_ARRAY , context should be that ARRAY p . clearCurrentToken ( ) ; / / regardless , recovery context should be whatever context we have now , / / with sole exception of pointing to a start marker , in which case it ' s / / the parent } } @ Override public void close ( ) throws IOException { if ( _parser ! = null ) { _parser . close ( ) ; } } public boolean hasNextValue ( ) throws IOException { if ( _parser = = null ) { return false ; / / fall - through } if ( ! _hasNextChecked ) { JsonToken t = _parser . getCurrentToken ( ) ; _hasNextChecked = true ; if ( t = = null ) { / / un - initialized or cleared ; find next t = _parser . nextToken ( ) ; / / If EOF , no more , or if we hit END_ARRAY ( although we don ' t clear the token ) . if ( t = = null | | t = = JsonToken . END_ARRAY ) { JsonParser jp = _parser ; _parser = null ; if ( _closeParser ) { jp . close ( ) ; } return false ; } } / / fall through } return true ; public T nextValue ( ) throws IOException { if ( ! _hasNextChecked ) { if ( ! hasNextValue ( ) ) { return _throwNoSuchElement ( ) ; } } if ( _parser = = null ) { return _throwNoSuchElement ( ) ; } _hasNextChecked = false ; try { T value ; if ( _updatedValue = = null ) { _deserializer . deserialize ( _parser , _context , _updatedValue ) ; value = _updatedValue ; } return value ; } finally { / / First , a quick check to see if we might have been lucky and no re - sync needed protected < R > R _throwNoSuchElement ( ) { throw new NoSuchElementException ( ) ;", "fixed_code": "protected final static int STATE_CLOSED = 0 ; protected final static int STATE_NEED_RESYNC = 1 ; protected final static int STATE_MAY_HAVE_VALUE = 2 ; protected final static int STATE_HAS_VALUE = 3 ; protected final JsonParser _parser ; protected final JsonStreamContext _seqContext ; protected int _state ; if ( p = = null ) { / / can this occur ? _seqContext = null ; _state = STATE_CLOSED ; } else { JsonStreamContext sctxt = p . getParsingContext ( ) ; if ( managedParser & & p . isExpectedStartArrayToken ( ) ) { / / If pointing to START_ARRAY , context should be that ARRAY p . clearCurrentToken ( ) ; } else { / / regardless , recovery context should be whatever context we have now , / / with sole exception of pointing to a start marker , in which case it ' s / / the parent JsonToken t = p . getCurrentToken ( ) ; if ( ( t = = JsonToken . START_OBJECT ) | | ( t = = JsonToken . START_ARRAY ) ) { sctxt = sctxt . getParent ( ) ; } } _seqContext = sctxt ; _state = STATE_MAY_HAVE_VALUE ; } } @ Override public void close ( ) throws IOException { if ( _state ! = STATE_CLOSED ) { _state = STATE_CLOSED ; if ( _parser ! = null ) { _parser . close ( ) ; } } } public boolean hasNextValue ( ) throws IOException { switch ( _state ) { case STATE_CLOSED : return false ; case STATE_NEED_RESYNC : _resync ( ) ; / / fall - through case STATE_MAY_HAVE_VALUE : JsonToken t = _parser . getCurrentToken ( ) ; if ( t = = null ) { / / un - initialized or cleared ; find next t = _parser . nextToken ( ) ; / / If EOF , no more , or if we hit END_ARRAY ( although we don ' t clear the token ) . if ( t = = null | | t = = JsonToken . END_ARRAY ) { _state = STATE_CLOSED ; if ( _closeParser & & ( _parser ! = null ) ) { _parser . close ( ) ; } return false ; } } _state = STATE_HAS_VALUE ; return true ; case STATE_HAS_VALUE : / / fall through } return true ; public T nextValue ( ) throws IOException { switch ( _state ) { case STATE_CLOSED : return _throwNoSuchElement ( ) ; case STATE_NEED_RESYNC : / / fall - through , will do re - sync case STATE_MAY_HAVE_VALUE : if ( ! hasNextValue ( ) ) { return _throwNoSuchElement ( ) ; } break ; case STATE_HAS_VALUE : break ; } int nextState = STATE_NEED_RESYNC ; try { T value ; if ( _updatedValue = = null ) { _deserializer . deserialize ( _parser , _context , _updatedValue ) ; value = _updatedValue ; } nextState = STATE_MAY_HAVE_VALUE ; return value ; } finally { _state = nextState ; protected void _resync ( ) throws IOException { final JsonParser p = _parser ; / / First , a quick check to see if we might have been lucky and no re - sync needed if ( p . getParsingContext ( ) = = _seqContext ) { return ; } while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = JsonToken . END_ARRAY ) | | ( t = = JsonToken . END_OBJECT ) ) { if ( p . getParsingContext ( ) = = _seqContext ) { p . clearCurrentToken ( ) ; return ; } } else if ( ( t = = JsonToken . START_ARRAY ) | | ( t = = JsonToken . START_OBJECT ) ) { p . skipChildren ( ) ; } else if ( t = = null ) { return ; } } } protected < R > R _throwNoSuchElement ( ) { throw new NoSuchElementException ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_18"}
{"buggy_code": "private JavaType _mapType ( Class < ? > rawClass ) { / / 28 - May - 2015 , tatu : Properties are special , as per [ databind # 810 ] JavaType [ ] typeParams = findTypeParameters ( rawClass , Map . class ) ; / / ok to have no types ( \" raw \" ) if ( typeParams = = null ) {", "fixed_code": "private JavaType _mapType ( Class < ? > rawClass ) { / / 28 - May - 2015 , tatu : Properties are special , as per [ databind # 810 ] if ( rawClass = = Properties . class ) { return MapType . construct ( rawClass , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } JavaType [ ] typeParams = findTypeParameters ( rawClass , Map . class ) ; / / ok to have no types ( \" raw \" ) if ( typeParams = = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_19"}
{"buggy_code": "@ Override public void writeObject ( Object value ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; } @ Override public void writeTree ( TreeNode node ) throws IOException { / / as with ' writeObject ( ) ' , is codec optional ? _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; }", "fixed_code": "@ Override public void writeObject ( Object value ) throws IOException { if ( value = = null ) { writeNull ( ) ; return ; } Class < ? > raw = value . getClass ( ) ; if ( raw = = byte [ ] . class ) { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; return ; } else if ( _objectCodec = = null ) { / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } } @ Override public void writeTree ( TreeNode node ) throws IOException { if ( node = = null ) { writeNull ( ) ; return ; } if ( _objectCodec = = null ) { / / as with ' writeObject ( ) ' , is codec optional ? _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_2"}
{"buggy_code": "package com . fasterxml . jackson . databind . node ; import com . fasterxml . jackson . annotation . JsonAutoDetect ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . JsonNode ; import com . fasterxml . jackson . databind . SerializerProvider ; * * @ since 2 . 1 public JsonNode setAll ( Map < String , ? extends JsonNode > properties ) { for ( Map . Entry < String , ? extends JsonNode > en : properties . entrySet ( ) ) {", "fixed_code": "package com . fasterxml . jackson . databind . node ; import com . fasterxml . jackson . annotation . JsonAutoDetect ; import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . JsonNode ; import com . fasterxml . jackson . databind . SerializerProvider ; * * @ since 2 . 1 @ JsonIgnore / / work - around for [ databind # 815 ] public JsonNode setAll ( Map < String , ? extends JsonNode > properties ) { for ( Map . Entry < String , ? extends JsonNode > en : properties . entrySet ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_20"}
{"buggy_code": "package com . fasterxml . jackson . databind . introspect ; import java . lang . annotation . Annotation ; import java . util . * ; import com . fasterxml . jackson . annotation . * ; * Since 2 . 6 , we have supported use of { @ link JsonProperty } for specifying * explicit serialized name / / 11 - Jun - 2015 , tatu : As per [ databind # 677 ] , need to allow explicit naming . / / Unfortunately can not quite use standard AnnotatedClass here ( due to various / / reasons , including odd representation JVM uses ) ; has to do for now / / We know that values are actually static fields with matching name so : / / no such field , or access ; neither which we can do much about", "fixed_code": "package com . fasterxml . jackson . databind . introspect ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . util . * ; import com . fasterxml . jackson . annotation . * ; * Since 2 . 6 , we have supported use of { @ link JsonProperty } for specifying * explicit serialized name @ Override public String findEnumValue ( Enum < ? > value ) { / / 11 - Jun - 2015 , tatu : As per [ databind # 677 ] , need to allow explicit naming . / / Unfortunately can not quite use standard AnnotatedClass here ( due to various / / reasons , including odd representation JVM uses ) ; has to do for now try { / / We know that values are actually static fields with matching name so : Field f = value . getClass ( ) . getField ( value . name ( ) ) ; if ( f ! = null ) { JsonProperty prop = f . getAnnotation ( JsonProperty . class ) ; String n = prop . value ( ) ; if ( n ! = null & & ! n . isEmpty ( ) ) { return n ; } } } catch ( Exception e ) { / / no such field , or access ; neither which we can do much about } return value . name ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_21"}
{"buggy_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( config , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom MapLikeType mlType = ( MapLikeType ) type ; ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( config , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( config , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; * * @ since 2 . 1 protected JsonSerializer < ? > buildCollectionSerializer ( SerializationConfig config , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } * Helper method that handles configuration details when constructing serializers for * { @ link java . util . Map } types . protected JsonSerializer < ? > buildMapSerializer ( SerializationConfig config , MapType type , BeanDescription beanDesc , boolean staticTyping , JsonSerializer < Object > keySerializer , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / 08 - Nov - 2014 , tatu : As per [ databind # 601 ] , better just use default Map serializer protected JsonSerializer < ? > buildArraySerializer ( SerializationConfig config , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) / / types can not be annotated ( in theory I guess we could have mix - ins but . . . ? ) / / so we need not do primary annotation lookup here . / / So all we need is ( 1 ) Custom , ( 2 ) Default array serializers JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom", "fixed_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( prov , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; MapLikeType mlType = ( MapLikeType ) type ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } } return ser ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( prov , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } } return ser ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( prov , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; * * @ since 2 . 1 protected JsonSerializer < ? > buildCollectionSerializer ( SerializerProvider prov , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } * Helper method that handles configuration details when constructing serializers for * { @ link java . util . Map } types . protected JsonSerializer < ? > buildMapSerializer ( SerializerProvider prov , MapType type , BeanDescription beanDesc , boolean staticTyping , JsonSerializer < Object > keySerializer , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { final SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : if ( ser ! = null ) { break ; } } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / 08 - Nov - 2014 , tatu : As per [ databind # 601 ] , better just use default Map serializer protected JsonSerializer < ? > buildArraySerializer ( SerializerProvider prov , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) / / types can not be annotated ( in theory I guess we could have mix - ins but . . . ? ) / / so we need not do primary annotation lookup here . / / So all we need is ( 1 ) Custom , ( 2 ) Default array serializers SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_22"}
{"buggy_code": "JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; if ( ser ! = null ) { return ser ; } final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . } if ( ser = = null ) {", "fixed_code": "JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = null ; final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } } if ( ser = = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_22"}
{"buggy_code": "protected abstract static class Base < T > extends StdScalarSerializer < T > implements ContextualSerializer { protected final JsonParser . NumberType _numberType ; protected final String _schemaType ; @ JacksonStdImpl public final static class ShortSerializer extends Base < Short > { final static ShortSerializer instance = new ShortSerializer ( ) ; public ShortSerializer ( ) { super ( Short . class , JsonParser . NumberType . INT , \" number \" ) ; } @ Override public void serialize ( Short value , JsonGenerator gen , SerializerProvider provider ) throws IOException { serialize ( value , gen , provider ) ; } }", "fixed_code": "protected abstract static class Base < T > extends StdScalarSerializer < T > implements ContextualSerializer { protected final static Integer EMPTY_INTEGER = Integer . valueOf ( 0 ) ; protected final JsonParser . NumberType _numberType ; protected final String _schemaType ; @ JacksonStdImpl public final static class ShortSerializer extends Base < Short > { private final static Short EMPTY = ( short ) 0 ; final static ShortSerializer instance = new ShortSerializer ( ) ; public ShortSerializer ( ) { super ( Short . class , JsonParser . NumberType . INT , \" number \" ) ; } @ Override public boolean isEmpty ( SerializerProvider prov , Short value ) { return EMPTY . equals ( value ) ; } @ Override public void serialize ( Short value , JsonGenerator gen , SerializerProvider provider ) throws IOException { serialize ( value , gen , provider ) ; } @ Override public boolean isEmpty ( SerializerProvider prov , Object value ) { return EMPTY_INTEGER . equals ( value ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_23"}
{"buggy_code": "if ( _dateFormat = = df ) { return this ; } TimeZone tz = ( df = = null ) ? _timeZone : df . getTimeZone ( ) ; return new BaseSettings ( _classIntrospector , _annotationIntrospector , _visibilityChecker , _propertyNamingStrategy , _typeFactory , _typeResolverBuilder , df , _handlerInstantiator , _locale , tz , _defaultBase64 ) ; } public BaseSettings withHandlerInstantiator ( HandlerInstantiator hi ) {", "fixed_code": "if ( _dateFormat = = df ) { return this ; } return new BaseSettings ( _classIntrospector , _annotationIntrospector , _visibilityChecker , _propertyNamingStrategy , _typeFactory , _typeResolverBuilder , df , _handlerInstantiator , _locale , _timeZone , _defaultBase64 ) ; } public BaseSettings withHandlerInstantiator ( HandlerInstantiator hi ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_24"}
{"buggy_code": "* important for some reason ? * Disabling the check will break 2 Enum - related tests . type = _baseType . narrowBy ( type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "fixed_code": "* important for some reason ? * Disabling the check will break 2 Enum - related tests . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_25"}
{"buggy_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "fixed_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_25"}
{"buggy_code": "return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return type . narrowBy ( dst ) ; }", "fixed_code": "return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return config . getTypeFactory ( ) . constructSpecializedType ( type , dst ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_25"}
{"buggy_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "fixed_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "JacksonDatabind_25"}
{"buggy_code": "@ JacksonStdImpl / / since 2 . 6 . NOTE : sub - classes typically are not public class BeanPropertyWriter extends PropertyWriter implements BeanProperty { / / as of 2 . 6 . 2", "fixed_code": "@ JacksonStdImpl / / since 2 . 6 . NOTE : sub - classes typically are not public class BeanPropertyWriter extends PropertyWriter implements BeanProperty , java . io . Serializable / / since 2 . 6 . 2 { / / as of 2 . 6 . 2 private static final long serialVersionUID = 4603296144163950020L ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_26"}
{"buggy_code": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , buffer ) ) { ; } else { / / Last creator property to set ?", "fixed_code": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) { ; } else { / / Last creator property to set ?", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_27"}
{"buggy_code": "@ Override public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . getCurrentToken ( ) = = JsonToken . START_OBJECT ) { p . nextToken ( ) ; return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . getCurrentToken ( ) = = JsonToken . FIELD_NAME ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "fixed_code": "@ Override public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . isExpectedStartObjectToken ( ) | | p . hasToken ( JsonToken . FIELD_NAME ) ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . hasToken ( JsonToken . END_OBJECT ) ) { return ctxt . getNodeFactory ( ) . objectNode ( ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_28"}
{"buggy_code": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "fixed_code": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { return null ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { _properties [ index ] . getProperty ( ) . set ( bean , null ) ; return ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_29"}
{"buggy_code": "if ( t = = JsonToken . VALUE_STRING ) { value = jp . getText ( ) ; } else if ( t = = JsonToken . VALUE_NULL ) { value = _elementDeserializer . getNullValue ( ) ; } else { value = _parseString ( jp , ctxt ) ; } while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? null : deser . deserialize ( jp , ctxt ) ; if ( ix > = chunk . length ) { chunk = buffer . appendCompletedChunk ( chunk ) ; ix = 0 ;", "fixed_code": "if ( t = = JsonToken . VALUE_STRING ) { value = jp . getText ( ) ; } else if ( t = = JsonToken . VALUE_NULL ) { value = null ; / / since we have established that ' _elementDeserializer = = null ' earlier } else { value = _parseString ( jp , ctxt ) ; } while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; if ( ix > = chunk . length ) { chunk = buffer . appendCompletedChunk ( chunk ) ; ix = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_3"}
{"buggy_code": "* * @ since 2 . 7 @ Override public Version version ( ) { } break ; case VALUE_NUMBER_FLOAT : switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } break ; case VALUE_TRUE :", "fixed_code": "* * @ since 2 . 7 protected boolean _forceBigDecimal ; public TokenBuffer forceUseOfBigDecimal ( boolean b ) { _forceBigDecimal = b ; return this ; } @ Override public Version version ( ) { } break ; case VALUE_NUMBER_FLOAT : if ( _forceBigDecimal ) { writeNumber ( p . getDecimalValue ( ) ) ; } else { switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } } break ; case VALUE_TRUE :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_30"}
{"buggy_code": "{ if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; JsonNode result ; try { writeValue ( buf , fromValue ) ; / / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing", "fixed_code": "{ if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } JsonNode result ; try { writeValue ( buf , fromValue ) ; / / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_30"}
{"buggy_code": "if ( text = = null ) { writeNull ( ) ; } else { _append ( JsonToken . VALUE_STRING , text ) ; } } if ( text = = null ) { writeNull ( ) ; } else { _append ( JsonToken . VALUE_STRING , text ) ; } } @ Override public void writeRawValue ( String text ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override if ( offset > 0 | | len ! = text . length ( ) ) { text = text . substring ( offset , offset + len ) ; } _append ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override public void writeRawValue ( char [ ] text , int offset , int len ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , new String ( text , offset , len ) ) ; } _append ( JsonToken . VALUE_NUMBER_FLOAT , encodedValue ) ; } @ Override public void writeBoolean ( boolean state ) throws IOException { _append ( state ? JsonToken . VALUE_TRUE : JsonToken . VALUE_FALSE ) ; } @ Override public void writeNull ( ) throws IOException { _append ( JsonToken . VALUE_NULL ) ; } / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } if ( _objectCodec = = null ) { / / as with ' writeObject ( ) ' , is codec optional ? _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } * * @ since 2 . 6 . 4 protected final void _appendRaw ( int rawType , Object value ) {", "fixed_code": "if ( text = = null ) { writeNull ( ) ; } else { _appendValue ( JsonToken . VALUE_STRING , text ) ; } } if ( text = = null ) { writeNull ( ) ; } else { _appendValue ( JsonToken . VALUE_STRING , text ) ; } } @ Override public void writeRawValue ( String text ) throws IOException { _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override if ( offset > 0 | | len ! = text . length ( ) ) { text = text . substring ( offset , offset + len ) ; } _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , new RawValue ( text ) ) ; } @ Override public void writeRawValue ( char [ ] text , int offset , int len ) throws IOException { _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , new String ( text , offset , len ) ) ; } _appendValue ( JsonToken . VALUE_NUMBER_FLOAT , encodedValue ) ; } @ Override public void writeBoolean ( boolean state ) throws IOException { _appendValue ( state ? JsonToken . VALUE_TRUE : JsonToken . VALUE_FALSE ) ; } @ Override public void writeNull ( ) throws IOException { _appendValue ( JsonToken . VALUE_NULL ) ; } / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } if ( _objectCodec = = null ) { / / as with ' writeObject ( ) ' , is codec optional ? _appendValue ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } * * @ since 2 . 6 . 4 protected final void _appendValue ( JsonToken type ) { _writeContext . writeValue ( ) ; Segment next = _hasNativeId ? _last . append ( _appendAt , type , _objectId , _typeId ) : _last . append ( _appendAt , type ) ; if ( next = = null ) { + + _appendAt ; } else { _last = next ; _appendAt = 1 ; / / since we added first at 0 } } protected final void _appendValue ( JsonToken type , Object value ) { _writeContext . writeValue ( ) ; Segment next = _hasNativeId ? _last . append ( _appendAt , type , value , _objectId , _typeId ) : _last . append ( _appendAt , type , value ) ; if ( next = = null ) { + + _appendAt ; } else { _last = next ; _appendAt = 1 ; } } protected final void _appendRaw ( int rawType , Object value ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_31"}
{"buggy_code": "case JsonTokenId . ID_FIELD_NAME : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( _mapDeserializer ! = null ) { return _mapDeserializer . deserialize ( p , ctxt ) ; } case JsonTokenId . ID_NULL : / / should not get this but . . . return null ; / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object / / case JsonTokenId . ID_END_ARRAY : / / invalid default :", "fixed_code": "case JsonTokenId . ID_FIELD_NAME : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object case JsonTokenId . ID_END_OBJECT : if ( _mapDeserializer ! = null ) { return _mapDeserializer . deserialize ( p , ctxt ) ; } case JsonTokenId . ID_NULL : / / should not get this but . . . return null ; case JsonTokenId . ID_END_OBJECT : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object return new LinkedHashMap < String , Object > ( 2 ) ; / / case JsonTokenId . ID_END_ARRAY : / / invalid default :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_32"}
{"buggy_code": "} else if ( _hasAnnotation ( a , JsonSerialize . class ) | | _hasAnnotation ( a , JsonView . class ) | | _hasAnnotation ( a , JsonRawValue . class ) ) { name = \" \" ; } else { return null ;", "fixed_code": "} else if ( _hasAnnotation ( a , JsonSerialize . class ) | | _hasAnnotation ( a , JsonView . class ) | | _hasAnnotation ( a , JsonRawValue . class ) | | _hasAnnotation ( a , JsonUnwrapped . class ) | | _hasAnnotation ( a , JsonBackReference . class ) | | _hasAnnotation ( a , JsonManagedReference . class ) ) { name = \" \" ; } else { return null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_33"}
{"buggy_code": "} else { Class < ? > h = handledType ( ) ; if ( h = = BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_INTEGER ) ; } else { / / otherwise bit unclear what to call . . . but let ' s try :", "fixed_code": "} else { Class < ? > h = handledType ( ) ; if ( h = = BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_DECIMAL ) ; } else { / / otherwise bit unclear what to call . . . but let ' s try :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_34"}
{"buggy_code": "} } / / first , sanity checks if ( p . getCurrentToken ( ) ! = JsonToken . START_OBJECT ) { throw ctxt . wrongTokenException ( p , JsonToken . START_OBJECT , \" need JSON Object to contain As . WRAPPER_OBJECT type information for class \" + baseTypeName ( ) ) ; } / / should always get field name , but just in case . . . if ( p . nextToken ( ) ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . FIELD_NAME , \" need JSON String that contains type id ( for subtype of \" + baseTypeName ( ) + \" ) \" ) ; } final String typeId = p . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; p . nextToken ( ) ;", "fixed_code": "} } / / first , sanity checks JsonToken t = p . getCurrentToken ( ) ; if ( t = = JsonToken . START_OBJECT ) { / / should always get field name , but just in case . . . if ( p . nextToken ( ) ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . FIELD_NAME , \" need JSON String that contains type id ( for subtype of \" + baseTypeName ( ) + \" ) \" ) ; } } else if ( t ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . START_OBJECT , \" need JSON Object to contain As . WRAPPER_OBJECT type information for class \" + baseTypeName ( ) ) ; } final String typeId = p . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; p . nextToken ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_35"}
{"buggy_code": "* and not via underlying { @ link Calendar } instance like base class * does . / / and since leniency settings may have been used : @ Override / / since 2 . 7 public boolean isLenient ( ) { df . setTimeZone ( tz ) ; } } return df ; }", "fixed_code": "* and not via underlying { @ link Calendar } instance like base class * does . @ Override / / since 2 . 7 public void setLenient ( boolean enabled ) { Boolean newValue = enabled ; if ( _lenient ! = newValue ) { _lenient = newValue ; / / and since leniency settings may have been used : _clearFormats ( ) ; } } @ Override / / since 2 . 7 public boolean isLenient ( ) { df . setTimeZone ( tz ) ; } } if ( lenient ! = null ) { df . setLenient ( lenient . booleanValue ( ) ) ; } return df ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_36"}
{"buggy_code": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , _superClass , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; }", "fixed_code": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_37"}
{"buggy_code": "package com . fasterxml . jackson . databind . type ; import com . fasterxml . jackson . databind . JavaType ; public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) return new CollectionType ( rawType , null , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ;", "fixed_code": "package com . fasterxml . jackson . databind . type ; import java . lang . reflect . TypeVariable ; import com . fasterxml . jackson . databind . JavaType ; public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 1 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , elemT ) ; } return new CollectionType ( rawType , bindings , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_38"}
{"buggy_code": "if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } return new SimpleType ( cls , TypeBindings . emptyBindings ( ) , _bogusSuperClass ( cls ) , null , null , null , false ) ; } @ Override * * @ since 2 . 7 - - remove when not needed ( 2 . 8 ? )", "fixed_code": "if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } TypeBindings b = TypeBindings . emptyBindings ( ) ; return new SimpleType ( cls , b , _buildSuperClass ( cls . getSuperclass ( ) , b ) , null , null , null , false ) ; } @ Override * * @ since 2 . 7 - - remove when not needed ( 2 . 8 ? ) private static JavaType _buildSuperClass ( Class < ? > superClass , TypeBindings b ) { if ( superClass = = null ) { return null ; } if ( superClass = = Object . class ) { return TypeFactory . unknownType ( ) ; } JavaType superSuper = _buildSuperClass ( superClass . getSuperclass ( ) , b ) ; return new SimpleType ( superClass , b , superSuper , null , null , null , false ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_38"}
{"buggy_code": "package com . fasterxml . jackson . databind . type ; import com . fasterxml . jackson . databind . JavaType ; { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , null , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; }", "fixed_code": "package com . fasterxml . jackson . databind . type ; import java . lang . reflect . TypeVariable ; import com . fasterxml . jackson . databind . JavaType ; { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 2 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , keyT , valueT ) ; } / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , bindings , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_38"}
{"buggy_code": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately p . skipChildren ( ) ; return null ; }", "fixed_code": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately if ( p . hasToken ( JsonToken . FIELD_NAME ) ) { while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = null ) | | ( t = = JsonToken . END_OBJECT ) ) { break ; } p . skipChildren ( ) ; } } else { p . skipChildren ( ) ; } return null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_39"}
{"buggy_code": "int ix = 0 ; JsonToken t ; while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value ; } chunk [ ix + + ] = value ; } / / note : pass String . class , not String [ ] . class , as we need element type for error info String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ; int ix = 0 ; JsonToken t ; while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; } chunk [ ix + + ] = value ; } / / note : pass String . class , not String [ ] . class , as we need element type for error info String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ;", "fixed_code": "int ix = 0 ; JsonToken t ; try { while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value ; } chunk [ ix + + ] = value ; } } catch ( Exception e ) { / / note : pass String . class , not String [ ] . class , as we need element type for error info throw JsonMappingException . wrapWithPath ( e , String . class , ix ) ; } String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ; int ix = 0 ; JsonToken t ; try { while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; } chunk [ ix + + ] = value ; } } catch ( Exception e ) { / / note : pass String . class , not String [ ] . class , as we need element type for error info throw JsonMappingException . wrapWithPath ( e , String . class , ix ) ; } String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_4"}
{"buggy_code": "return _nullValue ; } / / [ databind # 1095 ] : Should not allow coercion from into null from Empty String / / either , if ` null ` not allowed }", "fixed_code": "return _nullValue ; } @ Override public T getEmptyValue ( DeserializationContext ctxt ) throws JsonMappingException { / / [ databind # 1095 ] : Should not allow coercion from into null from Empty String / / either , if ` null ` not allowed if ( _primitive & & ctxt . isEnabled ( DeserializationFeature . FAIL_ON_NULL_FOR_PRIMITIVES ) ) { throw ctxt . mappingException ( \" Can not map Empty String as null into type % s ( set DeserializationConfig . DeserializationFeature . FAIL_ON_NULL_FOR_PRIMITIVES to ' false ' to allow ) \" , handledType ( ) . toString ( ) ) ; } return _nullValue ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_40"}
{"buggy_code": "@ Deprecated public JavaType constructType ( Type type , Class < ? > contextClass ) { return constructType ( type , constructType ( contextClass ) ) ; } @ Deprecated public JavaType constructType ( Type type , JavaType contextType ) { return _fromAny ( null , type , contextType . getBindings ( ) ) ; }", "fixed_code": "@ Deprecated public JavaType constructType ( Type type , Class < ? > contextClass ) { TypeBindings bindings = ( contextClass = = null ) ? TypeBindings . emptyBindings ( ) : constructType ( contextClass ) . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; } @ Deprecated public JavaType constructType ( Type type , JavaType contextType ) { TypeBindings bindings = ( contextType = = null ) ? TypeBindings . emptyBindings ( ) : contextType . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_41"}
{"buggy_code": "return URI . create ( \" \" ) ; } / / As per [ databind # 1123 ] , Locale too return super . _deserializeFromEmptyString ( ) ; } }", "fixed_code": "return URI . create ( \" \" ) ; } / / As per [ databind # 1123 ] , Locale too if ( _kind = = STD_LOCALE ) { return Locale . ROOT ; } return super . _deserializeFromEmptyString ( ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_42"}
{"buggy_code": "import java . lang . annotation . Annotation ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMember ; public Object deserializeSetAndReturn ( JsonParser p , DeserializationContext ctxt , Object instance ) throws IOException { Object id = _valueDeserializer . deserialize ( p , ctxt ) ; / / note : no null checks ( unlike usually ) ; deserializer should fail if one found if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ; / / also : may need to set a property value as well", "fixed_code": "import java . lang . annotation . Annotation ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . core . JsonToken ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMember ; public Object deserializeSetAndReturn ( JsonParser p , DeserializationContext ctxt , Object instance ) throws IOException { / / note : no null checks ( unlike usually ) ; deserializer should fail if one found if ( p . hasToken ( JsonToken . VALUE_NULL ) ) { return null ; } Object id = _valueDeserializer . deserialize ( p , ctxt ) ; ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ; / / also : may need to set a property value as well", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_43"}
{"buggy_code": "/ / 15 - Jan - 2016 , tatu : Almost yes , but there are some complications with / / placeholder values ( ` Void ` , ` NoClass ` ) , so can not quite do yet . / / TODO : fix in 2 . 8 return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; / / Otherwise , stitch together the hierarchy . First , super - class / / if not found , try a super - interface / / should not get here but . . . } @ Override", "fixed_code": "/ / 15 - Jan - 2016 , tatu : Almost yes , but there are some complications with / / placeholder values ( ` Void ` , ` NoClass ` ) , so can not quite do yet . / / TODO : fix in 2 . 8 if ( ! _class . isAssignableFrom ( subclass ) ) { return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } / / Otherwise , stitch together the hierarchy . First , super - class Class < ? > next = subclass . getSuperclass ( ) ; if ( next = = _class ) { / / straight up parent class ? Great . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } if ( ( next ! = null ) & & _class . isAssignableFrom ( next ) ) { JavaType superb = _narrow ( next ) ; return new SimpleType ( subclass , _bindings , superb , null , _valueHandler , _typeHandler , _asStatic ) ; } / / if not found , try a super - interface Class < ? > [ ] nextI = subclass . getInterfaces ( ) ; for ( Class < ? > iface : nextI ) { if ( iface = = _class ) { / / directly implemented return new SimpleType ( subclass , _bindings , null , new JavaType [ ] { this } , _valueHandler , _typeHandler , _asStatic ) ; } if ( _class . isAssignableFrom ( iface ) ) { / / indirect , so recurse JavaType superb = _narrow ( iface ) ; return new SimpleType ( subclass , _bindings , null , new JavaType [ ] { superb } , _valueHandler , _typeHandler , _asStatic ) ; } } / / should not get here but . . . throw new IllegalArgumentException ( \" Internal error : Can not resolve sub - type for Class \" + subclass . getName ( ) + \" to \" + _class . getName ( ) ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_44"}
{"buggy_code": "return withFormat ( Boolean . TRUE , null ) ; } if ( format . getShape ( ) = = JsonFormat . Shape . STRING ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( )", "fixed_code": "return withFormat ( Boolean . TRUE , null ) ; } if ( ( shape = = JsonFormat . Shape . STRING ) | | format . hasPattern ( ) | | format . hasLocale ( ) | | format . hasTimeZone ( ) ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_45"}
{"buggy_code": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( ' ; ' ) ; return sb ; }", "fixed_code": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( \" > ; \" ) ; return sb ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_46"}
{"buggy_code": "/ / static typing this way type = type . withStaticTyping ( ) ; } else { try { / / 11 - Oct - 2015 , tatu : For deser , we call ` TypeFactory . constructSpecializedType ( ) ` , / / may be needed here too in future ? type = tf . constructGeneralizedType ( type , serClass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( null , String . format ( \" Failed to widen type % s with annotation ( value % s ) , from ' % s ' : % s \" ,", "fixed_code": "/ / static typing this way type = type . withStaticTyping ( ) ; } else { Class < ? > currRaw = type . getRawClass ( ) ; try { / / 11 - Oct - 2015 , tatu : For deser , we call ` TypeFactory . constructSpecializedType ( ) ` , / / may be needed here too in future ? if ( serClass . isAssignableFrom ( currRaw ) ) { / / common case type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , type , serClass . getName ( ) ) ) ; } } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( null , String . format ( \" Failed to widen type % s with annotation ( value % s ) , from ' % s ' : % s \" ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_47"}
{"buggy_code": "{ VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "fixed_code": "{ VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_SETTERS ) ) { vchecker = vchecker . withSetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_48"}
{"buggy_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; }", "fixed_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_IS_GETTERS ) ) { vchecker = vchecker . withIsGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_48"}
{"buggy_code": "/ / 04 - Jun - 2016 , tatu : As per [ databind # 1255 ] , need to consider possibility of / / id being generated for \" alwaysAsId \" , but not being written as POJO ; regardless , / / need to use existing id if there is one : id = generator . generateId ( forPojo ) ; return id ; }", "fixed_code": "/ / 04 - Jun - 2016 , tatu : As per [ databind # 1255 ] , need to consider possibility of / / id being generated for \" alwaysAsId \" , but not being written as POJO ; regardless , / / need to use existing id if there is one : if ( id = = null ) { id = generator . generateId ( forPojo ) ; } return id ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_49"}
{"buggy_code": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . mixIns . add ( _constructMethod ( m ) ) ; } } }", "fixed_code": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . am = mixIns . find ( m ) ; if ( am ! = null ) { _addMixUnders ( m , am ) ; } else { mixIns . add ( _constructMethod ( m ) ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_5"}
{"buggy_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . impl . * ; import com . fasterxml . jackson . databind . util . NameTransformer ; import com . fasterxml . jackson . databind . util . TokenBuffer ; TokenBuffer unknown = null ; JsonToken t = p . getCurrentToken ( ) ; for ( ; t = = JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; / / to point to value / / regular property ? needs buffering SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop ! = null ) { buffer . bufferProperty ( prop , _deserializeWithErrorWrapping ( p , ctxt , prop ) ) ; / / 14 - Jun - 2016 , tatu : As per [ databind # 1261 ] , looks like we need additional / / handling of forward references here . Not exactly sure why existing / / facilities did not cover , but this does appear to solve the problem continue ; } / / Things marked as ignorable should not be passed to any setter wrapInstantiationProblem ( e , ctxt ) ; bean = null ; / / never gets here } if ( unknown ! = null ) { / / polymorphic ? if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { protected final Object _deserializeWithErrorWrapping ( JsonParser p , DeserializationContext ctxt , SettableBeanProperty prop ) }", "fixed_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . deser . impl . * ; import com . fasterxml . jackson . databind . deser . impl . ReadableObjectId . Referring ; import com . fasterxml . jackson . databind . util . NameTransformer ; import com . fasterxml . jackson . databind . util . TokenBuffer ; TokenBuffer unknown = null ; JsonToken t = p . getCurrentToken ( ) ; List < BeanReferring > referrings = null ; for ( ; t = = JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; / / to point to value / / regular property ? needs buffering SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop ! = null ) { try { buffer . bufferProperty ( prop , _deserializeWithErrorWrapping ( p , ctxt , prop ) ) ; } catch ( UnresolvedForwardReference reference ) { / / 14 - Jun - 2016 , tatu : As per [ databind # 1261 ] , looks like we need additional / / handling of forward references here . Not exactly sure why existing / / facilities did not cover , but this does appear to solve the problem BeanReferring referring = handleUnresolvedReference ( p , prop , buffer , reference ) ; if ( referrings = = null ) { referrings = new ArrayList < BeanReferring > ( ) ; } referrings . add ( referring ) ; } continue ; } / / Things marked as ignorable should not be passed to any setter wrapInstantiationProblem ( e , ctxt ) ; bean = null ; / / never gets here } if ( referrings ! = null ) { for ( BeanReferring referring : referrings ) { referring . setBean ( bean ) ; } } if ( unknown ! = null ) { / / polymorphic ? if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { private BeanReferring handleUnresolvedReference ( JsonParser p , SettableBeanProperty prop , PropertyValueBuffer buffer , UnresolvedForwardReference reference ) throws JsonMappingException { BeanReferring referring = new BeanReferring ( reference , prop . getType ( ) . getRawClass ( ) , buffer , prop ) ; reference . getRoid ( ) . appendReferring ( referring ) ; return referring ; } protected final Object _deserializeWithErrorWrapping ( JsonParser p , DeserializationContext ctxt , SettableBeanProperty prop ) static class BeanReferring extends Referring { private final SettableBeanProperty _prop ; private Object _bean ; public void setBean ( Object bean ) { _bean = bean ; } BeanReferring ( UnresolvedForwardReference ref , Class < ? > valueType , PropertyValueBuffer buffer , SettableBeanProperty prop ) { super ( ref , valueType ) ; _prop = prop ; } @ Override public void handleResolvedForwardReference ( Object id , Object value ) throws IOException { _prop . set ( _bean , value ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_50"}
{"buggy_code": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "fixed_code": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . if ( ! type . hasGenericTypes ( ) ) { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_51"}
{"buggy_code": "* * @ since 2 . 8 / / 21 - Jun - 2016 , tatu : as per [ databind # 999 ] , may need to link type id property also @ Deprecated / / since 2 . 8 ; may be removed as early as 2 . 9 public ExternalTypeHandler build ( ) {", "fixed_code": "* * @ since 2 . 8 public ExternalTypeHandler build ( BeanPropertyMap otherProps ) { / / 21 - Jun - 2016 , tatu : as per [ databind # 999 ] , may need to link type id property also final int len = _properties . size ( ) ; ExtTypedProperty [ ] extProps = new ExtTypedProperty [ len ] ; for ( int i = 0 ; i < len ; + + i ) { ExtTypedProperty extProp = _properties . get ( i ) ; String typePropId = extProp . getTypePropertyName ( ) ; SettableBeanProperty typeProp = otherProps . find ( typePropId ) ; if ( typeProp ! = null ) { extProp . linkTypeProperty ( typeProp ) ; } extProps [ i ] = extProp ; } return new ExternalTypeHandler ( extProps , _nameToPropertyIndex , null , null ) ; } @ Deprecated / / since 2 . 8 ; may be removed as early as 2 . 9 public ExternalTypeHandler build ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_52"}
{"buggy_code": "if ( extTypes ! = null ) { / / 21 - Jun - 2016 , tatu : related to [ databind # 999 ] , may need to link type ids too , / / so need to pass collected properties _externalTypeIdHandler = extTypes . build ( ) ; / / we consider this non - standard , to offline handling _nonStandardCreation = true ; }", "fixed_code": "if ( extTypes ! = null ) { / / 21 - Jun - 2016 , tatu : related to [ databind # 999 ] , may need to link type ids too , / / so need to pass collected properties _externalTypeIdHandler = extTypes . build ( _beanProperties ) ; / / we consider this non - standard , to offline handling _nonStandardCreation = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_52"}
{"buggy_code": "* actual generic types ) , we will use small cache to avoid repetitive * resolution of core types protected final LRUMap < Class < ? > , JavaType > _typeCache = new LRUMap < Class < ? > , JavaType > ( 16 , 100 ) ; } / / But otherwise gets bit tricky , as we need to partially resolve the type hierarchy / / ( hopefully passing null Class for root is ok ) / / Otherwise , two choices : match N first , or empty . Do latter , for now", "fixed_code": "* actual generic types ) , we will use small cache to avoid repetitive * resolution of core types protected final LRUMap < Object , JavaType > _typeCache = new LRUMap < Object , JavaType > ( 16 , 100 ) ; } private TypeBindings _bindingsForSubtype ( JavaType baseType , int typeParamCount , Class < ? > subclass ) { / / But otherwise gets bit tricky , as we need to partially resolve the type hierarchy / / ( hopefully passing null Class for root is ok ) int baseCount = baseType . containedTypeCount ( ) ; if ( baseCount = = typeParamCount ) { if ( typeParamCount = = 1 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } if ( typeParamCount = = 2 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } List < JavaType > types = new ArrayList < JavaType > ( baseCount ) ; for ( int i = 0 ; i < baseCount ; + + i ) { types . add ( baseType . containedType ( i ) ) ; } return TypeBindings . create ( subclass , types ) ; } / / Otherwise , two choices : match N first , or empty . Do latter , for now return TypeBindings . emptyBindings ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_53"}
{"buggy_code": "* * @ since 2 . 8 / / safe to pass _types array without copy since it is not exposed via / / any access , nor modified by this class }", "fixed_code": "* * @ since 2 . 8 public Object asKey ( Class < ? > rawBase ) { / / safe to pass _types array without copy since it is not exposed via / / any access , nor modified by this class return new AsKey ( rawBase , _types , _hashCode ) ; } final static class AsKey { private final Class < ? > _raw ; private final JavaType [ ] _params ; private final int _hash ;  public AsKey ( Class < ? > raw , JavaType [ ] params , int hash ) { _raw = raw ; _params = params ; _hash = hash ; } @ Override public int hashCode ( ) { return _hash ; }  @ Override public boolean equals ( Object o ) { if ( o = = this ) return true ; if ( o = = null ) return false ; if ( o . getClass ( ) ! = getClass ( ) ) return false ; AsKey other = ( AsKey ) o ;  if ( ( _hash = = other . _hash ) & & ( _raw = = other . _raw ) ) { final JavaType [ ] otherParams = other . _params ; final int len = _params . length ;  if ( len = = otherParams . length ) { for ( int i = 0 ; i < len ; + + i ) { if ( ! _params [ i ] . equals ( otherParams [ i ] ) ) { return false ; } } return true ; } } return false ; } @ Override public String toString ( ) { return _raw . getName ( ) + \" < > \" ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_53"}
{"buggy_code": "/ / always suppress nulls suppressNulls = true ; / / and for referential types , also \" empty \" , which in their case means \" absent \" if ( declaredType . isReferenceType ( ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; } break ; case ALWAYS : / / default default : / / we may still want to suppress empty collections , as per [ JACKSON - 254 ] : if ( declaredType . isContainerType ( ) & & ! _config . isEnabled ( SerializationFeature . WRITE_EMPTY_JSON_ARRAYS ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; }", "fixed_code": "/ / always suppress nulls suppressNulls = true ; / / and for referential types , also \" empty \" , which in their case means \" absent \" if ( actualType . isReferenceType ( ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; } break ; case ALWAYS : / / default default : / / we may still want to suppress empty collections , as per [ JACKSON - 254 ] : if ( actualType . isContainerType ( ) & & ! _config . isEnabled ( SerializationFeature . WRITE_EMPTY_JSON_ARRAYS ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_54"}
{"buggy_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . ser . impl . PropertySerializerMap ; @ SuppressWarnings ( \" serial \" ) public class StdKeySerializers return new Dynamic ( ) ; } if ( rawKeyType . isEnum ( ) ) { return new Default ( Default . TYPE_ENUM , rawKeyType ) ; } } return DEFAULT_KEY_SERIALIZER ; * * @ since 2 . 8 }", "fixed_code": "import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . ser . impl . PropertySerializerMap ; import com . fasterxml . jackson . databind . util . EnumValues ; @ SuppressWarnings ( \" serial \" ) public class StdKeySerializers return new Dynamic ( ) ; } if ( rawKeyType . isEnum ( ) ) { return EnumKeySerializer . construct ( rawKeyType , EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) rawKeyType ) ) ; } } return DEFAULT_KEY_SERIALIZER ; * * @ since 2 . 8 public static class EnumKeySerializer extends StdSerializer < Object > { protected final EnumValues _values ; protected EnumKeySerializer ( Class < ? > enumType , EnumValues values ) { super ( enumType , false ) ; _values = values ; } public static EnumKeySerializer construct ( Class < ? > enumType , EnumValues enumValues ) { return new EnumKeySerializer ( enumType , enumValues ) ; } @ Override public void serialize ( Object value , JsonGenerator g , SerializerProvider serializers ) throws IOException { if ( serializers . isEnabled ( SerializationFeature . WRITE_ENUMS_USING_TO_STRING ) ) { g . writeFieldName ( value . toString ( ) ) ; return ; } Enum < ? > en = ( Enum < ? > ) value ; g . writeFieldName ( _values . serializedValueFor ( en ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_55"}
{"buggy_code": "return Pattern . compile ( value ) ; case STD_LOCALE : { int ix = value . indexOf ( ' _ ' ) ; if ( ix < 0 ) { / / single argument return new Locale ( value ) ; } String first = value . substring ( 0 , ix ) ; value = value . substring ( ix + 1 ) ; ix = value . indexOf ( ' _ ' ) ; if ( ix < 0 ) { / / two pieces return new Locale ( first , value ) ; } } } }", "fixed_code": "return Pattern . compile ( value ) ; case STD_LOCALE : { int ix = _firstHyphenOrUnderscore ( value ) ; if ( ix < 0 ) { / / single argument return new Locale ( value ) ; } String first = value . substring ( 0 , ix ) ; value = value . substring ( ix + 1 ) ; ix = _firstHyphenOrUnderscore ( value ) ; if ( ix < 0 ) { / / two pieces return new Locale ( first , value ) ; } } protected int _firstHyphenOrUnderscore ( String str ) { for ( int i = 0 , end = str . length ( ) ; i < end ; + + i ) { char c = str . charAt ( i ) ; if ( c = = ' _ ' | | c = = ' - ' ) { return i ; } } return - 1 ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_56"}
{"buggy_code": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src ) , true ) ) ; }", "fixed_code": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src , offset , length ) , true ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_57"}
{"buggy_code": "/ / [ databind # 877 ] : explicitly prevent forced access to ` cause ` of ` Throwable ` ; / / never needed and attempts may cause problems on some platforms . / / ! ! ! NOTE : should be handled better for 2 . 8 and later mutator . fixAccess ( ctxt . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } / / note : this works since we know there ' s exactly one argument for methods BeanProperty . Std property = new BeanProperty . Std ( propDef . getFullName ( ) ,", "fixed_code": "/ / [ databind # 877 ] : explicitly prevent forced access to ` cause ` of ` Throwable ` ; / / never needed and attempts may cause problems on some platforms . / / ! ! ! NOTE : should be handled better for 2 . 8 and later if ( ( mutator instanceof AnnotatedField ) & & \" cause \" . equals ( mutator . getName ( ) ) ) { ; } else { mutator . fixAccess ( ctxt . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } } / / note : this works since we know there ' s exactly one argument for methods BeanProperty . Std property = new BeanProperty . Std ( propDef . getFullName ( ) ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_58"}
{"buggy_code": "_valueHandler , _typeHandler , _asStatic ) ; } / / \" withKeyType ( ) \" not part of JavaType , hence must verify : @ Override public MapLikeType withStaticTyping ( ) {", "fixed_code": "_valueHandler , _typeHandler , _asStatic ) ; } @ Override public JavaType withHandlersFrom ( JavaType src ) { JavaType type = super . withHandlersFrom ( src ) ; JavaType srcKeyType = src . getKeyType ( ) ; / / \" withKeyType ( ) \" not part of JavaType , hence must verify : if ( type instanceof MapLikeType ) { if ( srcKeyType ! = null ) { JavaType ct = _keyType . withHandlersFrom ( srcKeyType ) ; if ( ct ! = _keyType ) { type = ( ( MapLikeType ) type ) . withKeyType ( ct ) ; } } } JavaType srcCt = src . getContentType ( ) ; if ( srcCt ! = null ) { JavaType ct = _valueType . withHandlersFrom ( srcCt ) ; if ( ct ! = _valueType ) { type = type . withContentType ( ct ) ; } } return type ; } @ Override public MapLikeType withStaticTyping ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_59"}
{"buggy_code": "* * @ since 2 . 8 . 4", "fixed_code": "* * @ since 2 . 8 . 4 public JavaType withHandlersFrom ( JavaType src ) { JavaType type = this ; Object h = src . getTypeHandler ( ) ; if ( h ! = _typeHandler ) { type = type . withTypeHandler ( h ) ; } h = src . getValueHandler ( ) ; if ( h ! = _valueHandler ) { type = type . withValueHandler ( h ) ; } return type ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_59"}
{"buggy_code": "/ / 25 - Sep - 2016 , tatu : As per [ databind # 1384 ] also need to ensure handlers get / / copied as well return newType ; / / 20 - Oct - 2015 , tatu : Old simplistic approach", "fixed_code": "/ / 25 - Sep - 2016 , tatu : As per [ databind # 1384 ] also need to ensure handlers get / / copied as well newType = newType . withHandlersFrom ( baseType ) ; return newType ; / / 20 - Oct - 2015 , tatu : Old simplistic approach", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_59"}
{"buggy_code": "_valueHandler , _typeHandler , _asStatic ) ; } @ Override public CollectionLikeType withStaticTyping ( ) {", "fixed_code": "_valueHandler , _typeHandler , _asStatic ) ; } @ Override public JavaType withHandlersFrom ( JavaType src ) { JavaType type = super . withHandlersFrom ( src ) ; JavaType srcCt = src . getContentType ( ) ; if ( srcCt ! = null ) { JavaType ct = _elementType . withHandlersFrom ( srcCt ) ; if ( ct ! = _elementType ) { type = type . withContentType ( ct ) ; } } return type ; } @ Override public CollectionLikeType withStaticTyping ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "JacksonDatabind_59"}
{"buggy_code": "/ / Milliseconds partial or missing ; and even seconds are optional len = dateStr . length ( ) ; / / remove ' T ' , ' + ' / ' - ' and 4 - digit timezone - offset c = dateStr . charAt ( len - 9 ) ; if ( Character . isDigit ( c ) ) { StringBuilder sb = new StringBuilder ( dateStr ) ; sb . insert ( len - 5 , \" . 000 \" ) ; dateStr = sb . toString ( ) ; } df = _formatISO8601 ; StringBuilder sb = new StringBuilder ( dateStr ) ; / / And possible also millisecond part if missing int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; if ( timeLen < = 8 ) { sb . append ( \" . 000 \" ) ; } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ;", "fixed_code": "/ / Milliseconds partial or missing ; and even seconds are optional len = dateStr . length ( ) ; / / remove ' T ' , ' + ' / ' - ' and 4 - digit timezone - offset int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 6 ; if ( timeLen < 12 ) { / / 8 for hh : mm : ss , 4 for . sss int offset = len - 5 ; / / insertion offset , before tz - offset StringBuilder sb = new StringBuilder ( dateStr ) ; switch ( timeLen ) { case 11 : sb . insert ( offset , ' 0 ' ) ; break ; case 10 : sb . insert ( offset , \" 00 \" ) ; break ; case 9 : / / is this legal ? ( just second fraction marker ) sb . insert ( offset , \" 000 \" ) ; break ; case 8 : sb . insert ( offset , \" . 000 \" ) ; break ; case 7 : / / not legal to have single - digit second break ; case 6 : / / probably not legal , but let ' s allow sb . insert ( offset , \" 00 . 000 \" ) ; case 5 : / / is legal to omit seconds sb . insert ( offset , \" : 00 . 000 \" ) ; } dateStr = sb . toString ( ) ; } df = _formatISO8601 ; StringBuilder sb = new StringBuilder ( dateStr ) ; / / And possible also millisecond part if missing int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; if ( timeLen < 12 ) { / / missing , or partial switch ( timeLen ) { case 11 : sb . append ( ' 0 ' ) ; case 10 : sb . append ( ' 0 ' ) ; case 9 : sb . append ( ' 0 ' ) ; break ; default : sb . append ( \" . 000 \" ) ; } } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_6"}
{"buggy_code": "import java . util . LinkedHashSet ; import java . util . Set ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . annotation . JacksonStdImpl ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonFormatVisitorWrapper ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonStringFormatVisitor ; import com . fasterxml . jackson . databind . jsonschema . SchemaAware ; import com . fasterxml . jackson . databind . jsontype . TypeSerializer ; import com . fasterxml . jackson . databind . ser . BeanSerializer ; import com . fasterxml . jackson . databind . ser . ContextualSerializer ; / / 28 - Sep - 2016 , tatu : As per [ databind # 1385 ] , we do need to do some juggling / / to use different Object for type id ( logical type ) and actual serialization / / ( delegat type ) . ser . serializeWithType ( value , gen , provider , typeSer0 ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { * override Object to use for type id ( logical type ) even when asking serialization * of something else ( delegate type ) }", "fixed_code": "import java . util . LinkedHashSet ; import java . util . Set ; import com . fasterxml . jackson . annotation . JsonTypeInfo . As ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . annotation . JacksonStdImpl ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonFormatVisitorWrapper ; import com . fasterxml . jackson . databind . jsonFormatVisitors . JsonStringFormatVisitor ; import com . fasterxml . jackson . databind . jsonschema . SchemaAware ; import com . fasterxml . jackson . databind . jsontype . TypeIdResolver ; import com . fasterxml . jackson . databind . jsontype . TypeSerializer ; import com . fasterxml . jackson . databind . ser . BeanSerializer ; import com . fasterxml . jackson . databind . ser . ContextualSerializer ; / / 28 - Sep - 2016 , tatu : As per [ databind # 1385 ] , we do need to do some juggling / / to use different Object for type id ( logical type ) and actual serialization / / ( delegat type ) . TypeSerializerRerouter rr = new TypeSerializerRerouter ( typeSer0 , bean ) ; ser . serializeWithType ( value , gen , provider , rr ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { * override Object to use for type id ( logical type ) even when asking serialization * of something else ( delegate type ) static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer ; protected final Object _forObject ; public TypeSerializerRerouter ( TypeSerializer ts , Object ob ) { _typeSerializer = ts ; _forObject = ob ; } @ Override public TypeSerializer forProperty ( BeanProperty prop ) { / / should never get called throw new UnsupportedOperationException ( ) ; } @ Override public As getTypeInclusion ( ) { return _typeSerializer . getTypeInclusion ( ) ; } @ Override public String getPropertyName ( ) { return _typeSerializer . getPropertyName ( ) ; } @ Override public TypeIdResolver getTypeIdResolver ( ) { return _typeSerializer . getTypeIdResolver ( ) ; } @ Override public void writeTypePrefixForScalar ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForScalar ( _forObject , gen ) ; } @ Override public void writeTypePrefixForObject ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForObject ( _forObject , gen ) ; } @ Override public void writeTypePrefixForArray ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForArray ( _forObject , gen ) ; } @ Override public void writeTypeSuffixForScalar ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForScalar ( _forObject , gen ) ; } @ Override public void writeTypeSuffixForObject ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForObject ( _forObject , gen ) ; } @ Override public void writeTypeSuffixForArray ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForArray ( _forObject , gen ) ; } public void writeTypePrefixForScalar ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForScalar ( _forObject , gen , type ) ; } public void writeTypePrefixForObject ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForObject ( _forObject , gen , type ) ; } public void writeTypePrefixForArray ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForArray ( _forObject , gen , type ) ; } @ Override public void writeCustomTypePrefixForScalar ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForScalar ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypePrefixForObject ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForObject ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypePrefixForArray ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForArray ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypeSuffixForScalar ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForScalar ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypeSuffixForObject ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForObject ( _forObject , gen , typeId ) ; } @ Override public void writeCustomTypeSuffixForArray ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForArray ( _forObject , gen , typeId ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_60"}
{"buggy_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS :", "fixed_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless if ( t . isPrimitive ( ) ) { return false ; } switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_61"}
{"buggy_code": "if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ;", "fixed_code": "if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_61"}
{"buggy_code": "} delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } } / / [ databind # 1043 ] : allow per - property allow - wrapping of single overrides :", "fixed_code": "\" ) returned true for ' canCreateUsingDelegate ( ) ' , but null for ' getDelegateType ( ) ' \" ) ; } delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } else if ( _valueInstantiator . canCreateUsingArrayDelegate ( ) ) { JavaType delegateType = _valueInstantiator . getArrayDelegateType ( ctxt . getConfig ( ) ) ; if ( delegateType = = null ) { throw new IllegalArgumentException ( \" Invalid array - delegate - creator definition for \" + _collectionType + \" : value instantiator ( \" + _valueInstantiator . getClass ( ) . getName ( ) + \" ) returned true for ' canCreateUsingArrayDelegate ( ) ' , but null for ' getArrayDelegateType ( ) ' \" ) ; } delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } } / / [ databind # 1043 ] : allow per - property allow - wrapping of single overrides :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_62"}
{"buggy_code": "import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; import com . fasterxml . jackson . databind . util . ClassUtil ; } sb . append ( ' [ ' ) ; if ( _fieldName ! = null ) {", "fixed_code": "import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . core . * ; } sb . append ( ' [ ' ) ; if ( _fieldName ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_63"}
{"buggy_code": "/ / whereas for global defaults OR per - property overrides , we have more / / static definition . Sigh . / / First : case of class / type specifying it ; try to find POJO property defaults / / 16 - Oct - 2016 , tatu : Note : if we can not for some reason create \" default instance \" , / / revert logic to the case of general / per - property handling , so both / / type - default AND null are to be excluded . / / ( as per [ databind # 1417 ] if ( _useRealPropertyDefaults ) { / / 07 - Sep - 2016 , tatu : may also need to front - load access forcing now if ( prov . isEnabled ( MapperFeature . CAN_OVERRIDE_ACCESS_MODIFIERS ) ) { am . fixAccess ( _config . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } valueToSuppress = getPropertyDefaultValue ( propDef . getName ( ) , am , actualType ) ; } else { valueToSuppress = getDefaultValue ( actualType ) ; suppressNulls = true ;", "fixed_code": "/ / whereas for global defaults OR per - property overrides , we have more / / static definition . Sigh . / / First : case of class / type specifying it ; try to find POJO property defaults Object defaultBean ; / / 16 - Oct - 2016 , tatu : Note : if we can not for some reason create \" default instance \" , / / revert logic to the case of general / per - property handling , so both / / type - default AND null are to be excluded . / / ( as per [ databind # 1417 ] if ( _useRealPropertyDefaults & & ( defaultBean = getDefaultBean ( ) ) ! = null ) { / / 07 - Sep - 2016 , tatu : may also need to front - load access forcing now if ( prov . isEnabled ( MapperFeature . CAN_OVERRIDE_ACCESS_MODIFIERS ) ) { am . fixAccess ( _config . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } try { valueToSuppress = am . getValue ( defaultBean ) ; } catch ( Exception e ) { _throwWrapped ( e , propDef . getName ( ) , defaultBean ) ; } } else { valueToSuppress = getDefaultValue ( actualType ) ; suppressNulls = true ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_64"}
{"buggy_code": "/ / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { return true ; } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "fixed_code": "/ / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) & & am . getParameterCount ( ) = = 1 ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { if ( am . getParameterCount ( ) = = 1 ) { return true ; } } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_65"}
{"buggy_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : % s \" , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "fixed_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_65"}
{"buggy_code": "import java . net . URL ; import java . util . * ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . core . io . NumberInput ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMethod ; import com . fasterxml . jackson . databind . util . ClassUtil ; import com . fasterxml . jackson . databind . util . EnumResolver ;", "fixed_code": "import java . net . URL ; import java . util . * ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . core . io . NumberInput ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . introspect . AnnotatedMethod ; import com . fasterxml . jackson . databind . util . ClassUtil ; import com . fasterxml . jackson . databind . util . EnumResolver ; import com . fasterxml . jackson . databind . util . TokenBuffer ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_66"}
{"buggy_code": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { return _createEnumKeyDeserializer ( ctxt , type ) ; } deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } / / and then post - processing if ( deser ! = null ) {", "fixed_code": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { deser = _createEnumKeyDeserializer ( ctxt , type ) ; } else { deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } } / / and then post - processing if ( deser ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_67"}
{"buggy_code": "protected Object deserializeFromObjectUsingNonDefault ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( _delegateDeserializer ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; } if ( _propertyBasedCreator ! = null ) { return _deserializeUsingPropertyBased ( p , ctxt ) ; if ( _objectIdReader ! = null ) { return deserializeFromObjectId ( p , ctxt ) ; } switch ( p . getNumberType ( ) ) { case INT : if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } } return _valueInstantiator . createFromInt ( ctxt , p . getIntValue ( ) ) ; case LONG : if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromLong ( ctxt , p . getLongValue ( ) ) ; } / / actually , could also be BigInteger , so : if ( _delegateDeserializer ! = null ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromString ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } NumberType t = p . getNumberType ( ) ; / / no separate methods for taking float . . . if ( ( t = = NumberType . DOUBLE ) | | ( t = = NumberType . FLOAT ) ) { if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromDouble ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromDouble ( ctxt , p . getDoubleValue ( ) ) ; } / / actually , could also be BigDecimal , so : if ( _delegateDeserializer ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; } return ctxt . handleMissingInstantiator ( handledType ( ) , p , \" no suitable creator method found to deserialize from Number value ( % s ) \" , public Object deserializeFromBoolean ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( _delegateDeserializer ! = null ) { if ( ! _valueInstantiator . canCreateFromBoolean ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } public Object deserializeFromArray ( JsonParser p , DeserializationContext ctxt ) throws IOException { / / note : can not call ` _delegateDeserializer ( ) ` since order reversed here : if ( _arrayDelegateDeserializer ! = null ) { try { Object bean = _valueInstantiator . createUsingArrayDelegate ( ctxt , _arrayDelegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return bean ; } catch ( Exception e ) { return wrapInstantiationProblem ( e , ctxt ) ; } } / / fallback to non - array delegate if ( _delegateDeserializer ! = null ) { try { Object bean = _valueInstantiator . createUsingArrayDelegate ( ctxt , _delegateDeserializer . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return bean ; } catch ( Exception e ) { wrapInstantiationProblem ( e , ctxt ) ; return null ; } } if ( ctxt . isEnabled ( DeserializationFeature . UNWRAP_SINGLE_VALUE_ARRAYS ) ) { JsonToken t = p . nextToken ( ) ;", "fixed_code": "protected Object deserializeFromObjectUsingNonDefault ( JsonParser p , DeserializationContext ctxt ) throws IOException { final JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; } if ( _propertyBasedCreator ! = null ) { return _deserializeUsingPropertyBased ( p , ctxt ) ; if ( _objectIdReader ! = null ) { return deserializeFromObjectId ( p , ctxt ) ; } final JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; switch ( p . getNumberType ( ) ) { case INT : if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } } return _valueInstantiator . createFromInt ( ctxt , p . getIntValue ( ) ) ; case LONG : if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromInt ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromLong ( ctxt , p . getLongValue ( ) ) ; } / / actually , could also be BigInteger , so : if ( delegateDeser ! = null ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromString ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } NumberType t = p . getNumberType ( ) ; / / no separate methods for taking float . . . if ( ( t = = NumberType . DOUBLE ) | | ( t = = NumberType . FLOAT ) ) { JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromDouble ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return _valueInstantiator . createFromDouble ( ctxt , p . getDoubleValue ( ) ) ; } / / actually , could also be BigDecimal , so : JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { return _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; } return ctxt . handleMissingInstantiator ( handledType ( ) , p , \" no suitable creator method found to deserialize from Number value ( % s ) \" , public Object deserializeFromBoolean ( JsonParser p , DeserializationContext ctxt ) throws IOException { JsonDeserializer < Object > delegateDeser = _delegateDeserializer ( ) ; if ( delegateDeser ! = null ) { if ( ! _valueInstantiator . canCreateFromBoolean ( ) ) { Object bean = _valueInstantiator . createUsingDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } public Object deserializeFromArray ( JsonParser p , DeserializationContext ctxt ) throws IOException { / / note : can not call ` _delegateDeserializer ( ) ` since order reversed here : JsonDeserializer < Object > delegateDeser = _arrayDelegateDeserializer ; / / fallback to non - array delegate if ( ( delegateDeser ! = null ) | | ( ( delegateDeser = _delegateDeserializer ) ! = null ) ) { Object bean = _valueInstantiator . createUsingArrayDelegate ( ctxt , delegateDeser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { injectValues ( ctxt , bean ) ; } return bean ; } if ( ctxt . isEnabled ( DeserializationFeature . UNWRAP_SINGLE_VALUE_ARRAYS ) ) { JsonToken t = p . nextToken ( ) ; private final JsonDeserializer < Object > _delegateDeserializer ( ) { JsonDeserializer < Object > deser = _delegateDeserializer ; if ( deser = = null ) { deser = _arrayDelegateDeserializer ; } return deser ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_68"}
{"buggy_code": "SettableBeanProperty [ ] injectables ) { if ( creator . getParameterType ( 0 ) . isCollectionLikeType ( ) ) { verifyNonDup ( creator , C_ARRAY_DELEGATE , explicit ) ; _arrayDelegateArgs = injectables ; } else { verifyNonDup ( creator , C_DELEGATE , explicit ) ; _delegateArgs = injectables ; } } public void addPropertyCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] properties ) { verifyNonDup ( creator , C_PROPS , explicit ) ; / / Better ensure we have no duplicate names either . . . if ( properties . length > 1 ) { HashMap < String , Integer > names = new HashMap < String , Integer > ( ) ; } } _propertyBasedArgs = properties ; } public void addIncompeteParameter ( AnnotatedParameter parameter ) { protected void verifyNonDup ( AnnotatedWithParams newOne , int typeIndex , boolean explicit ) { final int mask = ( 1 < < typeIndex ) ; _hasNonDefaultCreator = true ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated if ( ! explicit ) { return ; } / / both explicit : verify verify = true ; / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } _explicitCreators | = mask ; } _creators [ typeIndex ] = _fixAccess ( newOne ) ; }", "fixed_code": "SettableBeanProperty [ ] injectables ) { if ( creator . getParameterType ( 0 ) . isCollectionLikeType ( ) ) { if ( verifyNonDup ( creator , C_ARRAY_DELEGATE , explicit ) ) { _arrayDelegateArgs = injectables ; } } else { if ( verifyNonDup ( creator , C_DELEGATE , explicit ) ) { _delegateArgs = injectables ; } } } public void addPropertyCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] properties ) { if ( verifyNonDup ( creator , C_PROPS , explicit ) ) { / / Better ensure we have no duplicate names either . . . if ( properties . length > 1 ) { HashMap < String , Integer > names = new HashMap < String , Integer > ( ) ; } } _propertyBasedArgs = properties ; } } public void addIncompeteParameter ( AnnotatedParameter parameter ) { protected boolean verifyNonDup ( AnnotatedWithParams newOne , int typeIndex , boolean explicit ) { final int mask = ( 1 < < typeIndex ) ; _hasNonDefaultCreator = true ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated if ( ! explicit ) { return false ; } / / both explicit : verify verify = true ; / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return false ; } / / new type more specific , use it } _explicitCreators | = mask ; } _creators [ typeIndex ] = _fixAccess ( newOne ) ; return true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_69"}
{"buggy_code": "public TokenBuffer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException { copyCurrentStructure ( jp ) ; return this ; }", "fixed_code": "public TokenBuffer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException { if ( jp . getCurrentTokenId ( ) ! = JsonToken . FIELD_NAME . id ( ) ) { copyCurrentStructure ( jp ) ; return this ; } JsonToken t ; writeStartObject ( ) ; do { copyCurrentStructure ( jp ) ; } while ( ( t = jp . nextToken ( ) ) = = JsonToken . FIELD_NAME ) ; if ( t ! = JsonToken . END_OBJECT ) { throw ctxt . mappingException ( \" Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer , got \" + t ) ; } writeEndObject ( ) ; return this ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_7"}
{"buggy_code": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( prop . getName ( ) ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "fixed_code": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( _hashArea [ i - 1 ] ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_70"}
{"buggy_code": "int kind ; / / first common types : if ( raw = = String . class | | raw = = Object . class ) { return StringKD . forType ( raw ) ; } else if ( raw = = UUID . class ) { kind = TYPE_UUID ;", "fixed_code": "int kind ; / / first common types : if ( raw = = String . class | | raw = = Object . class | | raw = = CharSequence . class ) { return StringKD . forType ( raw ) ; } else if ( raw = = UUID . class ) { kind = TYPE_UUID ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_71"}
{"buggy_code": "@ Override public int getPropertyIndex ( ) { return _delegate . getPropertyIndex ( ) ; } / / / / / / BeanProperty impl } return new InnerClassProperty ( this , new AnnotatedConstructor ( null , _creator , null , null ) ) ; } } \\ No newline at end of file", "fixed_code": "@ Override public int getPropertyIndex ( ) { return _delegate . getPropertyIndex ( ) ; } @ Override public int getCreatorIndex ( ) { return _delegate . getCreatorIndex ( ) ; } / / / / / / BeanProperty impl } return new InnerClassProperty ( this , new AnnotatedConstructor ( null , _creator , null , null ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_72"}
{"buggy_code": "* @ param inferMutators Whether mutators can be \" pulled in \" by visible * accessors or not . public void removeNonVisible ( boolean inferMutators ) {", "fixed_code": "* @ param inferMutators Whether mutators can be \" pulled in \" by visible * accessors or not . public JsonProperty . Access removeNonVisible ( boolean inferMutators ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_73"}
{"buggy_code": "import java . util . * ; import com . fasterxml . jackson . annotation . JsonAnySetter ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . cfg . HandlerInstantiator ; import com . fasterxml . jackson . databind . cfg . MapperConfig ; while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of prop . removeNonVisible ( inferMutators ) ; } }", "fixed_code": "import java . util . * ; import com . fasterxml . jackson . annotation . JsonAnySetter ; import com . fasterxml . jackson . annotation . JsonProperty . Access ; import com . fasterxml . jackson . databind . * ; import com . fasterxml . jackson . databind . cfg . HandlerInstantiator ; import com . fasterxml . jackson . databind . cfg . MapperConfig ; while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of Access acc = prop . removeNonVisible ( inferMutators ) ; if ( ! _forSerialization & & ( acc = = Access . READ_ONLY ) ) { _collectIgnorals ( prop . getName ( ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_73"}
{"buggy_code": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "fixed_code": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } else if ( p . getCurrentToken ( ) = = JsonToken . VALUE_STRING ) { if ( ctxt . isEnabled ( DeserializationFeature . ACCEPT_EMPTY_STRING_AS_NULL_OBJECT ) ) { String str = p . getText ( ) . trim ( ) ; if ( str . isEmpty ( ) ) { return null ; } } } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_74"}
{"buggy_code": "* handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * index ( number ) or not . protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return null ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return null ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) {", "fixed_code": "* handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true , null ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false , _serializeAsIndex ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * index ( number ) or not . protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass , Boolean defaultValue ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return defaultValue ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return defaultValue ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_75"}
{"buggy_code": "/ / creator property ? SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp ! = null ) { if ( buffer . assignParameter ( creatorProp , creatorProp . deserialize ( p , ctxt ) ) ) { t = p . nextToken ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrapAndThrow ( e , _beanType . getRawClass ( ) , propName , ctxt ) ; continue ; } while ( t = = JsonToken . FIELD_NAME ) { p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { ctxt . reportMappingException ( \" Can not create polymorphic instances with unwrapped values \" ) ; return null ; } return _unwrappedPropertyHandler . processUnwrapped ( p , ctxt , bean , tokens ) ; } continue ; } / / Object Id property ?", "fixed_code": "/ / creator property ? SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp ! = null ) { buffer . assignParameter ( creatorProp , creatorProp . deserialize ( p , ctxt ) ) ; continue ; } / / Object Id property ?", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_76"}
{"buggy_code": "return null ; } / / For checks like [ databind # 1599 ] / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; } / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here .  }", "fixed_code": "return null ; } / / For checks like [ databind # 1599 ] checkIllegalTypes ( ctxt , type , beanDesc ) ; / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; } protected void checkIllegalTypes ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here . Class < ? > raw = type . getRawClass ( ) ; String name = raw . getSimpleName ( ) ;  if ( \" TemplatesImpl \" . equals ( name ) ) { / / [ databind # 1599 ] if ( raw . getName ( ) . startsWith ( \" com . sun . org . apache . xalan \" ) ) { throw JsonMappingException . from ( ctxt , String . format ( \" Illegal type ( % s ) to deserialize : prevented for security reasons \" , name ) ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_77"}
{"buggy_code": "* * @ since 2 . 8 . 9 / / Courtesy of [ https : / / github . com / kantega / notsoserial ] : / / ( and wrt [ databind # 1599 ] / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here . }", "fixed_code": "* * @ since 2 . 8 . 9 protected final static Set < String > DEFAULT_NO_DESER_CLASS_NAMES ; static { Set < String > s = new HashSet < > ( ) ; / / Courtesy of [ https : / / github . com / kantega / notsoserial ] : / / ( and wrt [ databind # 1599 ] s . add ( \" org . apache . commons . collections . functors . InvokerTransformer \" ) ; s . add ( \" org . apache . commons . collections . functors . InstantiateTransformer \" ) ; s . add ( \" org . apache . commons . collections4 . functors . InvokerTransformer \" ) ; s . add ( \" org . apache . commons . collections4 . functors . InstantiateTransformer \" ) ; s . add ( \" org . codehaus . groovy . runtime . ConvertedClosure \" ) ; s . add ( \" org . codehaus . groovy . runtime . MethodClosure \" ) ; s . add ( \" org . springframework . beans . factory . ObjectFactory \" ) ; s . add ( \" com . sun . org . apache . xalan . internal . xsltc . trax . TemplatesImpl \" ) ; DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; } protected Set < String > _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES ; protected void checkIllegalTypes ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { / / There are certain nasty classes that could cause problems , mostly / / via default typing - - catch them here . String full = type . getRawClass ( ) . getName ( ) ; if ( _cfgIllegalClassNames . contains ( full ) ) { ctxt . reportBadTypeDefinition ( beanDesc , \" Illegal type ( % s ) to deserialize : prevented for security reasons \" , full ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_78"}
{"buggy_code": "if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( NAME_FOR_OBJECT_REF , null , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "fixed_code": "if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , null ) ; if ( objectIdInfo ! = null ) { oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_79"}
{"buggy_code": "public ObjectIdInfo ( PropertyName name , Class < ? > scope , Class < ? extends ObjectIdGenerator < ? > > gen , Class < ? extends ObjectIdResolver > resolver ) _resolver = resolver ; } public ObjectIdInfo withAlwaysAsId ( boolean state ) { if ( _alwaysAsId = = state ) {", "fixed_code": "private final static ObjectIdInfo EMPTY = new ObjectIdInfo ( PropertyName . NO_NAME , Object . class , null , false , null ) ; public ObjectIdInfo ( PropertyName name , Class < ? > scope , Class < ? extends ObjectIdGenerator < ? > > gen , Class < ? extends ObjectIdResolver > resolver ) _resolver = resolver ; } public static ObjectIdInfo empty ( ) { return EMPTY ; } public ObjectIdInfo withAlwaysAsId ( boolean state ) { if ( _alwaysAsId = = state ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_79"}
{"buggy_code": "@ Override public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref ! = null ) { objectIdInfo = objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } return objectIdInfo ; }", "fixed_code": "@ Override public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref = = null ) { return objectIdInfo ; } if ( objectIdInfo = = null ) { objectIdInfo = ObjectIdInfo . empty ( ) ; } return objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JacksonDatabind_79"}
{"buggy_code": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify / / otherwise only verify if neither explicitly annotated . } / / one more thing : ok to override in sub - class if ( oldOne . getClass ( ) = = newOne . getClass ( ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] / / otherwise , which one to choose ? / / new type more generic , use old / / new type more specific , use it } }", "fixed_code": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { boolean verify ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify verify = true ; } else { / / otherwise only verify if neither explicitly annotated . verify = ! explicit ; } / / one more thing : ok to override in sub - class if ( verify & & ( oldOne . getClass ( ) = = newOne . getClass ( ) ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems Class < ? > oldType = oldOne . getRawParameterType ( 0 ) ; Class < ? > newType = newOne . getRawParameterType ( 0 ) ; if ( oldType = = newType ) { throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] \" creators : already had explicitly marked \" + oldOne + \" , encountered \" + newOne ) ; } / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_8"}
{"buggy_code": "} / / then annotated types for property itself Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { nt . getType ( ) ) ; _collectAndResolve ( ac , nt , config , ai , collected ) ; } } NamedType rootType = new NamedType ( rawBase , null ) ; _collectAndResolveByTypeId ( ac , rootType , config , typesHandled , byName ) ; / / then with definitions from property Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { ac = AnnotatedClassResolver . resolveWithoutSuperTypes ( config , nt . getType ( ) ) ; _collectAndResolveByTypeId ( ac , nt , config , typesHandled , byName ) ; } } / / and finally explicit type registrations ( highest precedence ) if ( _registeredSubtypes ! = null ) {", "fixed_code": "} / / then annotated types for property itself if ( property ! = null ) { Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { nt . getType ( ) ) ; _collectAndResolve ( ac , nt , config , ai , collected ) ; } } } NamedType rootType = new NamedType ( rawBase , null ) ; _collectAndResolveByTypeId ( ac , rootType , config , typesHandled , byName ) ; / / then with definitions from property if ( property ! = null ) { Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { ac = AnnotatedClassResolver . resolveWithoutSuperTypes ( config , nt . getType ( ) ) ; _collectAndResolveByTypeId ( ac , nt , config , typesHandled , byName ) ; } } } / / and finally explicit type registrations ( highest precedence ) if ( _registeredSubtypes ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_80"}
{"buggy_code": "type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , keyType = tf . constructGeneralizedType ( keyType , keyClass ) ; } else if ( currRaw . isAssignableFrom ( keyClass ) ) { / / specialization , ok as well keyType = tf . constructSpecializedType ( keyType , keyClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization key type % s into % s ; types not related \" , contentType = tf . constructGeneralizedType ( contentType , contentClass ) ; } else if ( currRaw . isAssignableFrom ( contentClass ) ) { / / specialization , ok as well contentType = tf . constructSpecializedType ( contentType , contentClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization content type % s into % s ; types not related \" , / / Ok : start by refining the main type itself ; common to all types final Class < ? > valueClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . as ( ) ) ; if ( ( valueClass ! = null ) & & ! type . hasRawClass ( valueClass ) ) { try { type = tf . constructSpecializedType ( type , valueClass ) ; } catch ( IllegalArgumentException iae ) { if ( type . isMapLikeType ( ) ) { JavaType keyType = type . getKeyType ( ) ; final Class < ? > keyClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . keyAs ( ) ) ; if ( keyClass ! = null ) { try { keyType = tf . constructSpecializedType ( keyType , keyClass ) ; type = ( ( MapLikeType ) type ) . withKeyType ( keyType ) ; if ( contentType ! = null ) { / / collection [ like ] , map [ like ] , array , reference / / And then value types for all containers : final Class < ? > contentClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . contentAs ( ) ) ; if ( contentClass ! = null ) { try { contentType = tf . constructSpecializedType ( contentType , contentClass ) ; type = type . withContentType ( contentType ) ; return StdTypeResolverBuilder . noTypeInfoBuilder ( ) ; } }", "fixed_code": "type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; } else if ( _primitiveAndWrapper ( currRaw , serClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements type = type . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , keyType = tf . constructGeneralizedType ( keyType , keyClass ) ; } else if ( currRaw . isAssignableFrom ( keyClass ) ) { / / specialization , ok as well keyType = tf . constructSpecializedType ( keyType , keyClass ) ; } else if ( _primitiveAndWrapper ( currRaw , keyClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements keyType = keyType . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization key type % s into % s ; types not related \" , contentType = tf . constructGeneralizedType ( contentType , contentClass ) ; } else if ( currRaw . isAssignableFrom ( contentClass ) ) { / / specialization , ok as well contentType = tf . constructSpecializedType ( contentType , contentClass ) ; } else if ( _primitiveAndWrapper ( currRaw , contentClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements contentType = contentType . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization content type % s into % s ; types not related \" , / / Ok : start by refining the main type itself ; common to all types final Class < ? > valueClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . as ( ) ) ; if ( ( valueClass ! = null ) & & ! type . hasRawClass ( valueClass ) & & ! _primitiveAndWrapper ( type , valueClass ) ) { try { type = tf . constructSpecializedType ( type , valueClass ) ; } catch ( IllegalArgumentException iae ) { if ( type . isMapLikeType ( ) ) { JavaType keyType = type . getKeyType ( ) ; final Class < ? > keyClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . keyAs ( ) ) ; if ( ( keyClass ! = null ) & & ! _primitiveAndWrapper ( keyType , keyClass ) ) { try { keyType = tf . constructSpecializedType ( keyType , keyClass ) ; type = ( ( MapLikeType ) type ) . withKeyType ( keyType ) ; if ( contentType ! = null ) { / / collection [ like ] , map [ like ] , array , reference / / And then value types for all containers : final Class < ? > contentClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . contentAs ( ) ) ; if ( ( contentClass ! = null ) & & ! _primitiveAndWrapper ( contentType , contentClass ) ) { try { contentType = tf . constructSpecializedType ( contentType , contentClass ) ; type = type . withContentType ( contentType ) ; return StdTypeResolverBuilder . noTypeInfoBuilder ( ) ; } private boolean _primitiveAndWrapper ( Class < ? > baseType , Class < ? > refinement ) { if ( baseType . isPrimitive ( ) ) { return baseType = = ClassUtil . primitiveType ( refinement ) ; } if ( refinement . isPrimitive ( ) ) { return refinement = = ClassUtil . primitiveType ( baseType ) ; } return false ; } private boolean _primitiveAndWrapper ( JavaType baseType , Class < ? > refinement ) { if ( baseType . isPrimitive ( ) ) { return baseType . hasRawClass ( ClassUtil . primitiveType ( refinement ) ) ; } if ( refinement . isPrimitive ( ) ) { return refinement = = ClassUtil . primitiveType ( baseType . getRawClass ( ) ) ; } return false ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_81"}
{"buggy_code": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . getIgnored ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "fixed_code": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . findIgnoredForDeserialization ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_82"}
{"buggy_code": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . if ( _deserialize ( text , ctxt ) ! = null ) { return _deserialize ( text , ctxt ) ; } } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "fixed_code": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . return _deserialize ( text , ctxt ) ; } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_83"}
{"buggy_code": "/ / 08 - Jun - 2017 , tatu : With [ databind # 1648 ] , this gets bit tricky . . / / First : custom pattern will override things if ( ( shape = = JsonFormat . Shape . STRING ) | | format . hasPattern ( ) | | format . hasLocale ( ) | | format . hasTimeZone ( ) ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( ) : StdDateFormat . DATE_FORMAT_STR_ISO8601 ; final Locale loc = format . hasLocale ( ) ? format . getLocale ( ) : serializers . getLocale ( ) ; SimpleDateFormat df = new SimpleDateFormat ( pattern , loc ) ; if ( tz = = null ) { tz = serializers . getTimeZone ( ) ; } df . setTimeZone ( tz ) ; return withFormat ( Boolean . FALSE , df ) ; } / / Otherwise , need one of these changes : / / Jackson ' s own ` StdDateFormat ` is quite easy to deal with . . . / / 08 - Jun - 2017 , tatu : Unfortunately there ' s no generally usable / / mechanism for changing ` DateFormat ` instances ( or even clone ( ) ing ) / / So : require it be ` SimpleDateFormat ` ; can ' t config other types / / serializers . reportBadDefinition ( handledType ( ) , String . format ( / / Ugh . No way to change ` Locale ` , create copy ; must re - crete completely : return this ; }", "fixed_code": "/ / 08 - Jun - 2017 , tatu : With [ databind # 1648 ] , this gets bit tricky . . / / First : custom pattern will override things if ( format . hasPattern ( ) ) { final Locale loc = format . hasLocale ( ) ? format . getLocale ( ) : serializers . getLocale ( ) ; SimpleDateFormat df = new SimpleDateFormat ( format . getPattern ( ) , loc ) ; TimeZone tz = format . hasTimeZone ( ) ? format . getTimeZone ( ) : serializers . getTimeZone ( ) ; df . setTimeZone ( tz ) ; return withFormat ( Boolean . FALSE , df ) ; } / / Otherwise , need one of these changes : final boolean hasLocale = format . hasLocale ( ) ; final boolean hasTZ = format . hasTimeZone ( ) ; final boolean asString = ( shape = = JsonFormat . Shape . STRING ) ; if ( ! hasLocale & & ! hasTZ & & ! asString ) { return this ; } DateFormat df0 = serializers . getConfig ( ) . getDateFormat ( ) ; / / Jackson ' s own ` StdDateFormat ` is quite easy to deal with . . . if ( df0 instanceof StdDateFormat ) { StdDateFormat std = ( StdDateFormat ) df0 ; if ( format . hasLocale ( ) ) { std = std . withLocale ( format . getLocale ( ) ) ; } if ( format . hasTimeZone ( ) ) { std = std . withTimeZone ( format . getTimeZone ( ) ) ; } return withFormat ( Boolean . FALSE , std ) ; } / / 08 - Jun - 2017 , tatu : Unfortunately there ' s no generally usable / / mechanism for changing ` DateFormat ` instances ( or even clone ( ) ing ) / / So : require it be ` SimpleDateFormat ` ; can ' t config other types if ( ! ( df0 instanceof SimpleDateFormat ) ) { / / serializers . reportBadDefinition ( handledType ( ) , String . format ( serializers . reportMappingProblem ( \" Configured ` DateFormat ` ( % s ) not a ` SimpleDateFormat ` ; can not configure ` Locale ` or ` TimeZone ` \" , df0 . getClass ( ) . getName ( ) ) ; } SimpleDateFormat df = ( SimpleDateFormat ) df0 ; if ( hasLocale ) { / / Ugh . No way to change ` Locale ` , create copy ; must re - crete completely : df = new SimpleDateFormat ( df . toPattern ( ) , format . getLocale ( ) ) ; } else { df = ( SimpleDateFormat ) df . clone ( ) ; } TimeZone newTz = format . getTimeZone ( ) ; boolean changeTZ = ( newTz ! = null ) & & ! newTz . equals ( df . getTimeZone ( ) ) ; if ( changeTZ ) { df . setTimeZone ( newTz ) ; } return withFormat ( Boolean . FALSE , df ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_85"}
{"buggy_code": "_referencedType = ref ; } public JavaType getSelfReferencedType ( ) { return _referencedType ; }", "fixed_code": "_referencedType = ref ; } @ Override public JavaType getSuperClass ( ) { if ( _referencedType ! = null ) { return _referencedType . getSuperClass ( ) ; } return super . getSuperClass ( ) ; } public JavaType getSelfReferencedType ( ) { return _referencedType ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_86"}
{"buggy_code": "* * @ since 2 . 8 . 10", "fixed_code": "* * @ since 2 . 8 . 10 protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = \" yyyy - MM - dd ' T ' HH : mm : ss . SSS \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_87"}
{"buggy_code": "/ / compatibility - - needed later anyway , and not doing so may open / / security issues . JavaType t = tf . constructFromCanonical ( id ) ; / / Probably cleaner to have a method in ` TypeFactory ` but can ' t add in patch return t ; } Class < ? > cls ;", "fixed_code": "/ / compatibility - - needed later anyway , and not doing so may open / / security issues . JavaType t = tf . constructFromCanonical ( id ) ; if ( ! t . isTypeOrSubTypeOf ( _baseType . getRawClass ( ) ) ) { / / Probably cleaner to have a method in ` TypeFactory ` but can ' t add in patch throw new IllegalArgumentException ( String . format ( \" Class % s not subtype of % s \" , t . getRawClass ( ) . getName ( ) , _baseType ) ) ; } return t ; } Class < ? > cls ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_88"}
{"buggy_code": "@ Override public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; if ( value instanceof Date ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else { str = value . toString ( ) ; }", "fixed_code": "@ Override public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; Class < ? > cls = value . getClass ( ) ; if ( cls = = String . class ) { str = ( String ) value ; } else if ( Date . class . isAssignableFrom ( cls ) ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else if ( cls = = Class . class ) { str = ( ( Class < ? > ) value ) . getName ( ) ; } else { str = value . toString ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_9"}
{"buggy_code": "public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "fixed_code": "public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_90"}
{"buggy_code": "return ( _withArgsCreator ! = null ) ; } @ Override public JavaType getDelegateType ( DeserializationConfig config ) {", "fixed_code": "return ( _withArgsCreator ! = null ) ; } @ Override public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ; } @ Override public JavaType getDelegateType ( DeserializationConfig config ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_90"}
{"buggy_code": "/ / First : value types may have both value and type handlers JavaType ct = t . getContentType ( ) ; if ( ct ! = null ) { return ( ct . getValueHandler ( ) ! = null ) | | ( ct . getTypeHandler ( ) ! = null ) ; / / Second : map ( - like ) types may have value handler for key ( but not type ; keys are untyped ) } } return false ;", "fixed_code": "/ / First : value types may have both value and type handlers JavaType ct = t . getContentType ( ) ; if ( ct ! = null ) { if ( ( ct . getValueHandler ( ) ! = null ) | | ( ct . getTypeHandler ( ) ! = null ) ) { return true ; } } / / Second : map ( - like ) types may have value handler for key ( but not type ; keys are untyped ) if ( t . isMapLikeType ( ) ) { JavaType kt = t . getKeyType ( ) ; if ( kt . getValueHandler ( ) ! = null ) { return true ; } } } return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_91"}
{"buggy_code": "/ / [ databind # 1680 ] : may or may not be problem , take no chance s . add ( \" com . sun . rowset . JdbcRowSetImpl \" ) ; / / [ databind # 1737 ] ; JDK provided / / [ databind # 1737 ] ; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; }", "fixed_code": "/ / [ databind # 1680 ] : may or may not be problem , take no chance s . add ( \" com . sun . rowset . JdbcRowSetImpl \" ) ; / / [ databind # 1737 ] ; JDK provided s . add ( \" java . util . logging . FileHandler \" ) ; s . add ( \" java . rmi . server . UnicastRemoteObject \" ) ; / / [ databind # 1737 ] ; 3rd party s . add ( \" org . springframework . aop . support . AbstractBeanFactoryPointcutAdvisor \" ) ; s . add ( \" org . springframework . beans . factory . config . PropertyPathFactoryBean \" ) ; s . add ( \" com . mchange . v2 . c3p0 . JndiRefForwardingDataSource \" ) ; s . add ( \" com . mchange . v2 . c3p0 . WrapperConnectionPoolDataSource \" ) ; DEFAULT_NO_DESER_CLASS_NAMES = Collections . unmodifiableSet ( s ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_92"}
{"buggy_code": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; cls ! = Object . class ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "fixed_code": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( ! raw . isInterface ( ) & & full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; ( cls ! = null ) & & ( cls ! = Object . class ) ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_93"}
{"buggy_code": "{ protected final static String PREFIX_SPRING = \" org . springframework . \" ;", "fixed_code": "{ protected final static String PREFIX_SPRING = \" org . springframework . \" ; protected final static String PREFIX_C3P0 = \" com . mchange . v2 . c3p0 . \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_94"}
{"buggy_code": "/ / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , null ) ; } protected List < JavaType > parseTypes ( MyTokenizer tokens )", "fixed_code": "/ / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , TypeBindings . emptyBindings ( ) ) ; } protected List < JavaType > parseTypes ( MyTokenizer tokens )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_95"}
{"buggy_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , null ) ; } return constructParametricType ( parametrized , pt ) ; }", "fixed_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , EMPTY_BINDINGS ) ; } return constructParametricType ( parametrized , pt ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JacksonDatabind_95"}
{"buggy_code": "/ / 25 - May - 2018 , tatu : as per [ databind # 2051 ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / paramName = candidate . findImplicitParamName ( 0 ) ; paramName = candidate . findImplicitParamName ( 0 ) ; useProps = ( paramName ! = null ) & & paramDef . couldSerialize ( ) ; } if ( useProps ) {", "fixed_code": "/ / 25 - May - 2018 , tatu : as per [ databind # 2051 ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / paramName = candidate . findImplicitParamName ( 0 ) ; paramName = candidate . paramName ( 0 ) ; useProps = ( paramName ! = null ) & & paramDef . couldSerialize ( ) ; } if ( useProps ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_96"}
{"buggy_code": "} else { / / 25 - May - 2018 , tatu : [ databind # 1991 ] do not call via generator but through context ; / / this to preserve contextual information gen . writeObject ( _value ) ; } }", "fixed_code": "} else { / / 25 - May - 2018 , tatu : [ databind # 1991 ] do not call via generator but through context ; / / this to preserve contextual information ctxt . defaultSerializeValue ( _value , gen ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_97"}
{"buggy_code": "if ( ( typeProp ! = null ) & & ( typeProp . getCreatorIndex ( ) > = 0 ) ) { / / 31 - May - 2018 , tatu : [ databind # 1328 ] if id is NOT plain ` String ` , need to / / apply deserializer . . . fun fun . buffer . assignParameter ( typeProp , typeId ) ; } } }", "fixed_code": "if ( ( typeProp ! = null ) & & ( typeProp . getCreatorIndex ( ) > = 0 ) ) { / / 31 - May - 2018 , tatu : [ databind # 1328 ] if id is NOT plain ` String ` , need to / / apply deserializer . . . fun fun . final Object v ; if ( typeProp . getType ( ) . hasRawClass ( String . class ) ) { v = typeId ; } else { TokenBuffer tb = new TokenBuffer ( p , ctxt ) ; tb . writeString ( typeId ) ; v = typeProp . getValueDeserializer ( ) . deserialize ( tb . asParserOnFirstToken ( ) , ctxt ) ; tb . close ( ) ; } buffer . assignParameter ( typeProp , v ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_98"}
{"buggy_code": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; return sb . toString ( ) ; }", "fixed_code": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; sb . append ( ' > ' ) ; return sb . toString ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonDatabind_99"}
{"buggy_code": "/ / Simple , except that if this is a leaf , need to suppress end : if ( _mayBeLeaf ) { _mayBeLeaf = false ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _currToken = JsonToken . END_ARRAY ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; } } return ( _currToken = JsonToken . VALUE_STRING ) ;", "fixed_code": "/ / Simple , except that if this is a leaf , need to suppress end : if ( _mayBeLeaf ) { _mayBeLeaf = false ; if ( _parsingContext . inArray ( ) ) { / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } } return ( _currToken = JsonToken . VALUE_STRING ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonXml_1"}
{"buggy_code": "* * @ since 2 . 8", "fixed_code": "* * @ since 2 . 8 protected boolean _mixedText ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonXml_2"}
{"buggy_code": "} break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; _currToken = JsonToken . VALUE_STRING ; break ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) {", "fixed_code": "} break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currToken = JsonToken . VALUE_STRING ; return ( _currText = _xmlTokens . getText ( ) ) ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonXml_3"}
{"buggy_code": "{ / / 14 - Nov - 2016 , tatu : As per [ dataformat - xml # 213 ] , we may have explicitly / / configured root name . . . if ( jgen instanceof ToXmlGenerator ) { _initWithRootName ( ( ToXmlGenerator ) jgen , ROOT_NAME_FOR_NULL ) ; } super . serializeValue ( jgen , null ) ; }", "fixed_code": "{ / / 14 - Nov - 2016 , tatu : As per [ dataformat - xml # 213 ] , we may have explicitly / / configured root name . . . QName rootName = _rootNameFromConfig ( ) ; if ( rootName = = null ) { rootName = ROOT_NAME_FOR_NULL ; } if ( jgen instanceof ToXmlGenerator ) { _initWithRootName ( ( ToXmlGenerator ) jgen , rootName ) ; } super . serializeValue ( jgen , null ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonXml_4"}
{"buggy_code": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = src . _rootNameLookup ; }", "fixed_code": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = new XmlRootNameLookup ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonXml_5"}
{"buggy_code": "} } / / Stax2 API only has ' full buffer ' write method : / / should we consider pretty - printing or not ? / / base64 encodes up to 3 bytes into a 4 bytes string / / we still have < 3 bytes in the buffer private byte [ ] toFullBuffer ( byte [ ] data , int offset , int len ) return result ; }", "fixed_code": "} } @ Override public int writeBinary ( Base64Variant b64variant , InputStream data , int dataLength ) throws IOException { if ( data = = null ) { writeNull ( ) ; return 0 ; } _verifyValueWrite ( \" write Binary value \" ) ; if ( _nextName = = null ) { handleMissingName ( ) ; } try { if ( _nextIsAttribute ) { / / Stax2 API only has ' full buffer ' write method : byte [ ] fullBuffer = toFullBuffer ( data , dataLength ) ; _xmlWriter . writeBinaryAttribute ( \" \" , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , fullBuffer ) ; } else if ( checkNextIsUnwrapped ( ) ) { / / should we consider pretty - printing or not ? writeStreamAsBinary ( data , dataLength ) ; } else { if ( _xmlPrettyPrinter ! = null ) { _xmlPrettyPrinter . writeLeafElement ( _xmlWriter , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , toFullBuffer ( data , dataLength ) , 0 , dataLength ) ; } else { _xmlWriter . writeStartElement ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) ) ; writeStreamAsBinary ( data , dataLength ) ; _xmlWriter . writeEndElement ( ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwAsGenerationException ( e , this ) ; } return dataLength ; } private void writeStreamAsBinary ( InputStream data , int len ) throws IOException , XMLStreamException { / / base64 encodes up to 3 bytes into a 4 bytes string byte [ ] tmp = new byte [ 3 ] ; int offset = 0 ; int read ; while ( ( read = data . read ( tmp , offset , Math . min ( 3 - offset , len ) ) ) ! = - 1 ) { offset + = read ; len - = read ; if ( offset = = 3 ) { offset = 0 ; _xmlWriter . writeBinary ( tmp , 0 , 3 ) ; } if ( len = = 0 ) { break ; } } / / we still have < 3 bytes in the buffer if ( offset > 0 ) { _xmlWriter . writeBinary ( tmp , 0 , offset ) ; } } private byte [ ] toFullBuffer ( byte [ ] data , int offset , int len ) return result ; } private byte [ ] toFullBuffer ( InputStream data , final int len ) throws IOException { byte [ ] result = new byte [ len ] ; int offset = 0 ; for ( ; offset < len ; ) { int count = data . read ( result , offset , len - offset ) ; if ( count < 0 ) { _reportError ( \" Too few bytes available : missing \" + ( len - offset ) + \" bytes ( out of \" + len + \" ) \" ) ; } offset + = count ; } return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JacksonXml_6"}
{"buggy_code": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . appendChild ( new TextNode ( \" \" , \" \" ) ) ; body ( ) . appendChild ( node ) ; } }", "fixed_code": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode ( \" \" , \" \" ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_1"}
{"buggy_code": "return abs . toExternalForm ( ) ; } / / workaround : java resolves ' / / path / file + ? foo ' to ' / / path / ? foo ' , not ' / / path / file ? foo ' as desired URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) {", "fixed_code": "return abs . toExternalForm ( ) ; } / / workaround : java resolves ' / / path / file + ? foo ' to ' / / path / ? foo ' , not ' / / path / file ? foo ' as desired if ( relUrl . startsWith ( \" ? \" ) ) relUrl = base . getPath ( ) + relUrl ; URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_10"}
{"buggy_code": "if ( tq . matchesAny ( combinators ) ) { / / if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; / / chomp first element matcher off queue } return matches ( false ) ; } else if ( tq . matches ( \" : matchesOwn ( \" ) ) { return matches ( true ) ; } else { / / unhandled throw new SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ; } } / / : not ( selector ) / / direct child descendants private static Elements filterForChildren ( Collection < Element > parents , Collection < Element > candidates ) { } / / exclude set . package open so that Elements can implement . not ( ) selector . public static class SelectorParseException extends IllegalStateException { public SelectorParseException ( String msg , Object . . . params ) {", "fixed_code": "if ( tq . matchesAny ( combinators ) ) { / / if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( tq . matches ( \" : has ( \" ) ) { elements . addAll ( root . getAllElements ( ) ) ; } else { addElements ( findElements ( ) ) ; / / chomp first element matcher off queue } return matches ( false ) ; } else if ( tq . matches ( \" : matchesOwn ( \" ) ) { return matches ( true ) ; } else if ( tq . matches ( \" : not ( \" ) ) { return not ( ) ; } else { / / unhandled throw new SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ; } } / / : not ( selector ) private Elements not ( ) { tq . consume ( \" : not \" ) ; String subQuery = tq . chompBalanced ( ' ( ' , ' ) ' ) ; Validate . notEmpty ( subQuery , \" : not ( selector ) subselect must not be empty \" ) ; return filterOut ( root . getAllElements ( ) , select ( subQuery , root ) ) ; } / / direct child descendants private static Elements filterForChildren ( Collection < Element > parents , Collection < Element > candidates ) { } / / exclude set . package open so that Elements can implement . not ( ) selector . static Elements filterOut ( Collection < Element > elements , Collection < Element > outs ) { Elements output = new Elements ( ) ; for ( Element el : elements ) { boolean found = false ; for ( Element out : outs ) { if ( el . equals ( out ) ) { found = true ; break ; } } if ( ! found ) output . add ( el ) ; } return output ; } public static class SelectorParseException extends IllegalStateException { public SelectorParseException ( String msg , Object . . . params ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_11"}
{"buggy_code": "private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } private Elements findElements ( ) { if ( tq . matchChomp ( \" # \" ) ) {", "fixed_code": "private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } private String consumeSubQuery ( ) { StringBuilder sq = new StringBuilder ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( \" ( \" ) ) sq . append ( \" ( \" ) . append ( tq . chompBalanced ( ' ( ' , ' ) ' ) ) . append ( \" ) \" ) ; else if ( tq . matches ( \" [ \" ) ) sq . append ( \" [ \" ) . append ( tq . chompBalanced ( ' [ ' , ' ] ' ) ) . append ( \" ] \" ) ; else if ( tq . matchesAny ( combinators ) ) break ; else sq . append ( tq . consume ( ) ) ; } return sq . toString ( ) ; } private Elements findElements ( ) { if ( tq . matchChomp ( \" # \" ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_12"}
{"buggy_code": "public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; return attributes . hasKey ( attributeKey ) ; }", "fixed_code": "public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; if ( attributeKey . toLowerCase ( ) . startsWith ( \" abs : \" ) ) { String key = attributeKey . substring ( \" abs : \" . length ( ) ) ; if ( attributes . hasKey ( key ) & & ! absUrl ( key ) . equals ( \" \" ) ) return true ; } return attributes . hasKey ( attributeKey ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_13"}
{"buggy_code": "if ( r . matches ( ' / ' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( RCDATAEndTagOpen ) ; / / diverge from spec : got a start tag , but there ' s no appropriate end tag ( < / title > ) , so rather than / / consuming to EOF ; break out here } else { t . emit ( \" < \" ) ; t . transition ( Rcdata ) ;", "fixed_code": "if ( r . matches ( ' / ' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( RCDATAEndTagOpen ) ; } else if ( r . matchesLetter ( ) & & ! r . containsIgnoreCase ( \" < / \" + t . appropriateEndTagName ( ) ) ) { / / diverge from spec : got a start tag , but there ' s no appropriate end tag ( < / title > ) , so rather than / / consuming to EOF ; break out here t . tagPending = new Token . EndTag ( t . appropriateEndTagName ( ) ) ; t . emitTagPending ( ) ; r . unconsume ( ) ; / / undo \" < \" t . transition ( Data ) ; } else { t . emit ( \" < \" ) ; t . transition ( Rcdata ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_14"}
{"buggy_code": "return tagPending . tagName . equals ( lastStartTag . tagName ) ; } boolean isTrackErrors ( ) { return trackErrors ;", "fixed_code": "return tagPending . tagName . equals ( lastStartTag . tagName ) ; } String appropriateEndTagName ( ) { return lastStartTag . tagName ; } boolean isTrackErrors ( ) { return trackErrors ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_14"}
{"buggy_code": "if ( ! html . hasAttr ( attribute . getKey ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( StringUtil . in ( name , \" base \" , \" basefont \" , \" bgsound \" , \" command \" , \" link \" , \" meta \" , \" noframes \" , \" style \" , \" title \" ) ) { return tb . process ( t , InHead ) ; } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ;", "fixed_code": "if ( ! html . hasAttr ( attribute . getKey ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( StringUtil . in ( name , \" base \" , \" basefont \" , \" bgsound \" , \" command \" , \" link \" , \" meta \" , \" noframes \" , \" script \" , \" style \" , \" title \" ) ) { return tb . process ( t , InHead ) ; } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_15"}
{"buggy_code": "package org . jsoup . nodes ; import org . jsoup . helper . StringUtil ;", "fixed_code": "package org . jsoup . nodes ; import org . jsoup . helper . StringUtil ; import org . jsoup . helper . Validate ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_16"}
{"buggy_code": "} } ; private static String nullString = String . valueOf ( 0x0000 ) ; abstract boolean process ( Token t , TreeBuilder tb ) ;", "fixed_code": "} } ; private static String nullString = String . valueOf ( ' \\ u0000 ' ) ; abstract boolean process ( Token t , TreeBuilder tb ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_17"}
{"buggy_code": "CharacterReader ( String input ) { Validate . notNull ( input ) ; this . input = input ; this . length = input . length ( ) ; } String consumeToEnd ( ) { String data = input . substring ( pos , input . length ( ) - 1 ) ; pos = input . length ( ) ; return data ; }", "fixed_code": "CharacterReader ( String input ) { Validate . notNull ( input ) ; input = input . replaceAll ( \" \\ r \\ n ? \" , \" \\ n \" ) ; / / normalise carriage returns to newlines this . input = input ; this . length = input . length ( ) ; } String consumeToEnd ( ) { String data = input . substring ( pos , input . length ( ) ) ; pos = input . length ( ) ; return data ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_18"}
{"buggy_code": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "fixed_code": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( value . length ( ) = = 0 ) value = attr . getValue ( ) ; / / if it could not be made abs , run as - is to allow custom unknown protocols if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_19"}
{"buggy_code": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "fixed_code": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; popStackToClose ( tag ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_2"}
{"buggy_code": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "fixed_code": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode if ( docData . charAt ( 0 ) = = 65279 ) docData = docData . substring ( 1 ) ; doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_20"}
{"buggy_code": "/ / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( \" , \" ) ) { CombiningEvaluator . Or or = new CombiningEvaluator . Or ( evals ) ; evals . clear ( ) ; evals . add ( or ) ; while ( ! tq . isEmpty ( ) ) { String subQuery = tq . chompTo ( \" , \" ) ; or . add ( parse ( subQuery ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; }", "fixed_code": "/ / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else if ( combinator = = ' , ' ) { / / group or CombiningEvaluator . Or or ; if ( e instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) e ; or . add ( f ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( e ) ; or . add ( f ) ; } evals . add ( or ) ; } else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_21"}
{"buggy_code": "this . evaluators . addAll ( evaluators ) ; } public void add ( Evaluator e ) { evaluators . add ( e ) ;", "fixed_code": "this . evaluators . addAll ( evaluators ) ; } Or ( ) { super ( ) ; } public void add ( Evaluator e ) { evaluators . add ( e ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_21"}
{"buggy_code": "contents = new ArrayList < Element > ( ) ; } public Elements ( Collection < Element > elements ) { contents = new ArrayList < Element > ( elements ) ;", "fixed_code": "contents = new ArrayList < Element > ( ) ; } public Elements ( int initialCapacity ) { contents = new ArrayList < Element > ( initialCapacity ) ; } public Elements ( Collection < Element > elements ) { contents = new ArrayList < Element > ( elements ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_22"}
{"buggy_code": "* @ return sibling elements public Elements siblingElements ( ) { return parent ( ) . children ( ) ; } public Element nextElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; * @ see # nextElementSibling ( ) public Element previousElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ;", "fixed_code": "* @ return sibling elements public Elements siblingElements ( ) { if ( parentNode = = null ) return new Elements ( 0 ) ; List < Element > elements = parent ( ) . children ( ) ; Elements siblings = new Elements ( elements . size ( ) - 1 ) ; for ( Element el : elements ) if ( el ! = this ) siblings . add ( el ) ; return siblings ; } public Element nextElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; * @ see # nextElementSibling ( ) public Element previousElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_22"}
{"buggy_code": "@ return node siblings . If the node has no parent , returns an empty list . public List < Node > siblingNodes ( ) { return parent ( ) . childNodes ( ) ; } public Node previousSibling ( ) { List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ;", "fixed_code": "@ return node siblings . If the node has no parent , returns an empty list . public List < Node > siblingNodes ( ) { if ( parentNode = = null ) return Collections . emptyList ( ) ; List < Node > nodes = parentNode . childNodes ; List < Node > siblings = new ArrayList < Node > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node ! = this ) siblings . add ( node ) ; return siblings ; } public Node previousSibling ( ) { if ( parentNode = = null ) return null ; / / root List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_22"}
{"buggy_code": "} } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "fixed_code": "} } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterThenDigitSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_23"}
{"buggy_code": "return input . substring ( start , pos ) ; } String consumeHexSequence ( ) { int start = pos ;", "fixed_code": "return input . substring ( start , pos ) ; } String consumeLetterThenDigitSequence ( ) { int start = pos ; while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ) pos + + ; else break ; } while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( c > = ' 0 ' & & c < = ' 9 ' ) pos + + ; else break ; } return input . substring ( start , pos ) ; } String consumeHexSequence ( ) { int start = pos ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_23"}
{"buggy_code": "String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name . toLowerCase ( ) ) ; t . dataBuffer . append ( name ) ; r . advance ( ) ; return ; }", "fixed_code": "String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name . toLowerCase ( ) ) ; t . dataBuffer . append ( name ) ; return ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_24"}
{"buggy_code": "private static final String [ ] formatAsInlineTags = { \" title \" , \" a \" , \" p \" , \" h1 \" , \" h2 \" , \" h3 \" , \" h4 \" , \" h5 \" , \" h6 \" , \" pre \" , \" address \" , \" li \" , \" th \" , \" td \" , \" script \" , \" style \" } ; private static final String [ ] preserveWhitespaceTags = { \" pre \" , \" plaintext \" , \" title \" } ; static { / / creates", "fixed_code": "private static final String [ ] formatAsInlineTags = { \" title \" , \" a \" , \" p \" , \" h1 \" , \" h2 \" , \" h3 \" , \" h4 \" , \" h5 \" , \" h6 \" , \" pre \" , \" address \" , \" li \" , \" th \" , \" td \" , \" script \" , \" style \" } ; private static final String [ ] preserveWhitespaceTags = { \" pre \" , \" plaintext \" , \" title \" , \" textarea \" } ; static { / / creates", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_25"}
{"buggy_code": "Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ;", "fixed_code": "Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; if ( dirtyDocument . body ( ) ! = null ) / / frameset documents won ' t have a body . the clean doc will have empty body . copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_26"}
{"buggy_code": "Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; return charset ; } return null ; }", "fixed_code": "Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } return null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_27"}
{"buggy_code": "} else { / / named / / get as many letters as possible , and look for matching entities . String nameRef = reader . consumeLetterThenDigitSequence ( ) ; String origNameRef = new String ( nameRef ) ; boolean looksLegit = reader . matches ( ' ; ' ) ; / / found if a base named entity without a ; , or an extended entity with the ; . boolean found = false ; while ( nameRef . length ( ) > 0 & & ! found ) { if ( Entities . isNamedEntity ( nameRef ) ) found = true ; else { nameRef = nameRef . substring ( 0 , nameRef . length ( ) - 1 ) ; reader . unconsume ( ) ; } } if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) / / named with semicolon characterReferenceError ( String . format ( \" invalid named referenece ' % s ' \" , origNameRef ) ) ; return null ; } if ( inAttribute & & ( reader . matchesLetter ( ) | | reader . matchesDigit ( ) | | reader . matchesAny ( ' = ' , ' - ' , ' _ ' ) ) ) { * @ param inAttribute * @ return unescaped string from reader }", "fixed_code": "} else { / / named / / get as many letters as possible , and look for matching entities . String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ' ; ' ) ; / / found if a base named entity without a ; , or an extended entity with the ; . boolean found = ( Entities . isBaseNamedEntity ( nameRef ) | | ( Entities . isNamedEntity ( nameRef ) & & looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) / / named with semicolon characterReferenceError ( String . format ( \" invalid named referenece ' % s ' \" , nameRef ) ) ; return null ; } if ( inAttribute & & ( reader . matchesLetter ( ) | | reader . matchesDigit ( ) | | reader . matchesAny ( ' = ' , ' - ' , ' _ ' ) ) ) { * @ param inAttribute * @ return unescaped string from reader String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = new StringBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( ' & ' ) ) ; if ( reader . matches ( ' & ' ) ) { reader . consume ( ) ; Character c = consumeCharacterReference ( null , inAttribute ) ; if ( c = = null ) builder . append ( ' & ' ) ; else builder . append ( c ) ; } } return builder . toString ( ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_28"}
{"buggy_code": "* @ param inAttribute if the string is to be escaped in strict mode ( as attributes are ) * @ return an unescaped string", "fixed_code": "* @ param inAttribute if the string is to be escaped in strict mode ( as attributes are ) * @ return an unescaped string public static String unescapeEntities ( String string , boolean inAttribute ) { Tokeniser tokeniser = new Tokeniser ( new CharacterReader ( string ) , ParseErrorList . noTracking ( ) ) ; return tokeniser . unescapeEntities ( inAttribute ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_28"}
{"buggy_code": "package org . jsoup . nodes ; import java . io . IOException ; import java . io . InputStream ; * @ return true if a known named entity in the base set * @ see # isNamedEntity ( String ) static String unescape ( String string , boolean strict ) { if ( ! string . contains ( \" & \" ) ) return string ; Matcher m = strict ? strictUnescapePattern . matcher ( string ) : unescapePattern . matcher ( string ) ; StringBuffer accum = new StringBuffer ( string . length ( ) ) ; while ( m . find ( ) ) { int charval = - 1 ; String num = m . group ( 3 ) ; if ( num ! = null ) { try { int base = m . group ( 2 ) ! = null ? 16 : 10 ; charval = Integer . valueOf ( num , base ) ; } catch ( NumberFormatException e ) { } } else { String name = m . group ( 1 ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } if ( charval ! = - 1 | | charval > 0xFFFF ) { String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , Matcher . quoteReplacement ( c ) ) ; } else { m . appendReplacement ( accum , Matcher . quoteReplacement ( m . group ( 0 ) ) ) ; } } m . appendTail ( accum ) ; return accum . toString ( ) ; } / / xhtml has restricted entities", "fixed_code": "package org . jsoup . nodes ; import org . jsoup . parser . Parser ; import java . io . IOException ; import java . io . InputStream ; * @ return true if a known named entity in the base set * @ see # isNamedEntity ( String ) public static boolean isBaseNamedEntity ( String name ) { return base . containsKey ( name ) ; } static String unescape ( String string , boolean strict ) { return Parser . unescapeEntities ( string , strict ) ; } / / xhtml has restricted entities", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_28"}
{"buggy_code": "package org . jsoup . nodes ; import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import org . jsoup . select . Elements ; public String title ( ) { / / title is a preserve whitespace tag ( for document output ) , but normalised here Element titleEl = getElementsByTag ( \" title \" ) . first ( ) ; return titleEl ! = null ? titleEl . text ( ) . trim ( ) : \" \" ; }", "fixed_code": "package org . jsoup . nodes ; import org . jsoup . helper . StringUtil ; import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import org . jsoup . select . Elements ; public String title ( ) { / / title is a preserve whitespace tag ( for document output ) , but normalised here Element titleEl = getElementsByTag ( \" title \" ) . first ( ) ; return titleEl ! = null ? StringUtil . normaliseWhitespace ( titleEl . text ( ) ) . trim ( ) : \" \" ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_29"}
{"buggy_code": "private final TokenQueue tq ; private final Document doc ; private String baseUri ; private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; @ param baseUri base URI of document ( i . e . original fetch location ) , for resolving relative URLs . @ return Document , with empty head , and HTML parsed into body private Document parse ( ) { while ( ! tq . isEmpty ( ) ) { Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node / / otherwise , look up the stack for valid ancestors for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } }", "fixed_code": "private final TokenQueue tq ; private final Document doc ; private String baseUri ; private boolean relaxed = false ; private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; @ param baseUri base URI of document ( i . e . original fetch location ) , for resolving relative URLs . @ return Document , with empty head , and HTML parsed into body public static Document parseBodyFragmentRelaxed ( String bodyHtml , String baseUri ) { Parser parser = new Parser ( bodyHtml , baseUri , true ) ; parser . relaxed = true ; return parser . parse ( ) ; } private Document parse ( ) { while ( ! tq . isEmpty ( ) ) { Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor & & ! relaxed ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node if ( childTag . requiresSpecificParent ( ) ) return stack . getLast ( ) . tag ( ) . isValidParent ( childTag ) ; / / otherwise , look up the stack for valid ancestors for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidAncestor ( childTag ) ) { return true ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_3"}
{"buggy_code": "public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop", "fixed_code": "public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragmentRelaxed ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_3"}
{"buggy_code": "private boolean empty = false ; / / can hold nothing ; e . g . img private boolean preserveWhitespace = false ; / / for pre , textarea , script etc private List < Tag > ancestors ; / / elements must be a descendant of one of these ancestors private Tag ( String tagName ) { this . tagName = tagName . toLowerCase ( ) ; return false ; / / don ' t allow children to contain their parent ( directly ) return true ; } return ( ! ancestors . isEmpty ( ) ) ? ancestors . get ( 0 ) : null ; } boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; / / HTML tag createBlock ( \" TITLE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setContainDataOnly ( ) ; createInline ( \" BASE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setEmpty ( ) ; createBlock ( \" FRAME \" ) . setAncestor ( \" FRAMESET \" ) . setEmpty ( ) ; createBlock ( \" NOFRAMES \" ) . setAncestor ( \" FRAMESET \" ) . setContainDataOnly ( ) ; createInline ( \" TEXTAREA \" ) . setAncestor ( \" FORM \" ) . setContainDataOnly ( ) ; createInline ( \" LABEL \" ) . setAncestor ( \" FORM \" ) . setOptionalClosing ( ) ; / / not self createInline ( \" BUTTON \" ) . setAncestor ( \" FORM \" ) ; / / bunch of excludes not defined createInline ( \" OPTGROUP \" ) . setAncestor ( \" SELECT \" ) ; createInline ( \" OPTION \" ) . setAncestor ( \" SELECT \" ) . setContainDataOnly ( ) ; createBlock ( \" FIELDSET \" ) . setAncestor ( \" FORM \" ) ; createInline ( \" LEGEND \" ) . setAncestor ( \" FIELDSET \" ) ; / / other createInline ( \" AREA \" ) . setEmpty ( ) ; / / not an inline per - se createInline ( \" PARAM \" ) . setAncestor ( \" OBJECT \" ) . setEmpty ( ) ; createBlock ( \" INS \" ) ; / / only within body createBlock ( \" DEL \" ) ; / / only within body createBlock ( \" DL \" ) ; createInline ( \" DT \" ) . setAncestor ( \" DL \" ) . setOptionalClosing ( ) ; createInline ( \" DD \" ) . setAncestor ( \" DL \" ) . setOptionalClosing ( ) ; createBlock ( \" LI \" ) . setAncestor ( \" UL \" , \" OL \" ) . setOptionalClosing ( ) ; / / only within OL or UL . / / tables createBlock ( \" TABLE \" ) ; / / specific list of only includes ( tr , td , thead etc ) not implemented createBlock ( \" CAPTION \" ) . setAncestor ( \" TABLE \" ) ; createBlock ( \" THEAD \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" TFOOT \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" TBODY \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" COLGROUP \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" COL \" ) . setAncestor ( \" COLGROUP \" ) . setEmpty ( ) ; createBlock ( \" TR \" ) . setAncestor ( \" TABLE \" ) . setOptionalClosing ( ) ; createBlock ( \" TH \" ) . setAncestor ( \" TR \" ) . setOptionalClosing ( ) ; createBlock ( \" TD \" ) . setAncestor ( \" TR \" ) . setOptionalClosing ( ) ; } private static Tag createBlock ( String tagName ) { return this ; } }", "fixed_code": "private boolean empty = false ; / / can hold nothing ; e . g . img private boolean preserveWhitespace = false ; / / for pre , textarea , script etc private List < Tag > ancestors ; / / elements must be a descendant of one of these ancestors private Tag parent ; / / if not null , elements must be a direct child of parent private Tag ( String tagName ) { this . tagName = tagName . toLowerCase ( ) ; return false ; / / don ' t allow children to contain their parent ( directly ) if ( this . requiresSpecificParent ( ) & & this . getImplicitParent ( ) . equals ( child ) ) return false ; return true ; } return ( ! ancestors . isEmpty ( ) ) ? ancestors . get ( 0 ) : null ; } boolean requiresSpecificParent ( ) { return this . parent ! = null ; } boolean isValidParent ( Tag child ) { return this . equals ( child . parent ) ; } boolean isValidAncestor ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; / / HTML tag createBlock ( \" TITLE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setContainDataOnly ( ) ; createInline ( \" BASE \" ) . setAncestor ( \" HEAD \" , \" BODY \" ) . setEmpty ( ) ; createBlock ( \" FRAME \" ) . setParent ( \" FRAMESET \" ) . setEmpty ( ) ; createBlock ( \" NOFRAMES \" ) . setParent ( \" FRAMESET \" ) . setContainDataOnly ( ) ; createInline ( \" TEXTAREA \" ) . setAncestor ( \" FORM \" ) . setContainDataOnly ( ) ; createInline ( \" LABEL \" ) . setAncestor ( \" FORM \" ) . setOptionalClosing ( ) ; / / not self createInline ( \" BUTTON \" ) . setAncestor ( \" FORM \" ) ; / / bunch of excludes not defined createInline ( \" OPTGROUP \" ) . setParent ( \" SELECT \" ) ; / / only contain option createInline ( \" OPTION \" ) . setParent ( \" SELECT \" ) . setContainDataOnly ( ) ; createBlock ( \" FIELDSET \" ) . setAncestor ( \" FORM \" ) ; createInline ( \" LEGEND \" ) . setAncestor ( \" FIELDSET \" ) ; / / other createInline ( \" AREA \" ) . setEmpty ( ) ; / / not an inline per - se createInline ( \" PARAM \" ) . setParent ( \" OBJECT \" ) . setEmpty ( ) ; createBlock ( \" INS \" ) ; / / only within body createBlock ( \" DEL \" ) ; / / only within body createBlock ( \" DL \" ) ; createInline ( \" DT \" ) . setParent ( \" DL \" ) . setOptionalClosing ( ) ; / / only within DL . createInline ( \" DD \" ) . setParent ( \" DL \" ) . setOptionalClosing ( ) ; / / only within DL . createBlock ( \" LI \" ) . setAncestor ( \" UL \" , \" OL \" ) . setOptionalClosing ( ) ; / / only within OL or UL . / / tables createBlock ( \" TABLE \" ) ; / / specific list of only includes ( tr , td , thead etc ) not implemented createBlock ( \" CAPTION \" ) . setParent ( \" TABLE \" ) ; createBlock ( \" THEAD \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just TR createBlock ( \" TFOOT \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just TR createBlock ( \" TBODY \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / optional / implicit open too . just TR createBlock ( \" COLGROUP \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just COL createBlock ( \" COL \" ) . setParent ( \" COLGROUP \" ) . setEmpty ( ) ; createBlock ( \" TR \" ) . setParent ( \" TABLE \" ) . setOptionalClosing ( ) ; / / just TH , TD createBlock ( \" TH \" ) . setParent ( \" TR \" ) . setOptionalClosing ( ) ; createBlock ( \" TD \" ) . setParent ( \" TR \" ) . setOptionalClosing ( ) ; } private static Tag createBlock ( String tagName ) { return this ; } private Tag setParent ( String tagName ) { parent = Tag . valueOf ( tagName ) ; setAncestor ( tagName ) ; return this ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_3"}
{"buggy_code": "import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; import org . jsoup . parser . Tag ; import java . util . List ; private int copySafeNodes ( Element root , Element destination ) { List < Node > sourceChildren = root . childNodes ( ) ; int numDiscarded = 0 ; for ( Node source : sourceChildren ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; } else { numDiscarded + + ; numDiscarded + = copySafeNodes ( sourceEl , destination ) ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } } return numDiscarded ; } private ElementMeta createSafeElement ( Element sourceEl ) {", "fixed_code": "import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; import org . jsoup . parser . Tag ; import org . jsoup . select . NodeTraversor ; import org . jsoup . select . NodeVisitor ; import java . util . List ; private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0 ; private final Element root ; private Element destination ; / / current element to append nodes to  private CleaningVisitor ( Element root , Element destination ) { this . root = root ; this . destination = destination ; } public void head ( Node source , int depth ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; destination = destChild ; } else if ( source ! = root ) { / / not a safe tag , so don ' t add . don ' t count root against discarded . numDiscarded + + ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } else { / / else , we don ' t care about comments , xml proc instructions , etc numDiscarded + + ; } } public void tail ( Node source , int depth ) { if ( source instanceof Element & & whitelist . isSafeTag ( source . nodeName ( ) ) ) { destination = destination . parent ( ) ; / / would have descended , so pop destination stack } } } private int copySafeNodes ( Element source , Element dest ) { CleaningVisitor cleaningVisitor = new CleaningVisitor ( source , dest ) ; NodeTraversor traversor = new NodeTraversor ( cleaningVisitor ) ; traversor . traverse ( source ) ; return cleaningVisitor . numDiscarded ; } private ElementMeta createSafeElement ( Element sourceEl ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_30"}
{"buggy_code": "void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; insertNode ( insert ) ; }", "fixed_code": "void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; if ( commentToken . bogus ) { / / xml declarations are emitted as bogus comments ( which is right for html , but not xml ) String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_31"}
{"buggy_code": "/ / rewind to capture character that lead us here r . unconsume ( ) ; Token . Comment comment = new Token . Comment ( ) ; comment . data . append ( r . consumeTo ( ' > ' ) ) ; / / todo : replace nullChar with replaceChar t . emit ( comment ) ;", "fixed_code": "/ / rewind to capture character that lead us here r . unconsume ( ) ; Token . Comment comment = new Token . Comment ( ) ; comment . bogus = true ; comment . data . append ( r . consumeTo ( ' > ' ) ) ; / / todo : replace nullChar with replaceChar t . emit ( comment ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_31"}
{"buggy_code": "static class Comment extends Token { final StringBuilder data = new StringBuilder ( ) ; Comment ( ) { type = TokenType . Comment ;", "fixed_code": "static class Comment extends Token { final StringBuilder data = new StringBuilder ( ) ; boolean bogus = false ; Comment ( ) { type = TokenType . Comment ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_31"}
{"buggy_code": "@ Override public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames ( ) ; return clone ; } }", "fixed_code": "@ Override public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames = null ; / / derived on first hit , otherwise gets a pointer to source classnames return clone ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_32"}
{"buggy_code": "if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; / / ensure we get out of whatever state we are in . emitted for yielded processing return el ; }", "fixed_code": "if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . transition ( TokeniserState . Data ) ; / / handles < script / > , otherwise needs breakout steps from script data tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; / / ensure we get out of whatever state we are in . emitted for yielded processing return el ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_33"}
{"buggy_code": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "fixed_code": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length & & last < = length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_34"}
{"buggy_code": "} Element adopter = new Element ( formatEl . tag ( ) , tb . getBaseUri ( ) ) ; Node [ ] childNodes = furthestBlock . childNodes ( ) . toArray ( new Node [ furthestBlock . childNodeSize ( ) ] ) ; for ( Node childNode : childNodes ) { adopter . appendChild ( childNode ) ; / / append will reparent . thus the clone to avoid concurrent mod .", "fixed_code": "} Element adopter = new Element ( formatEl . tag ( ) , tb . getBaseUri ( ) ) ; adopter . attributes ( ) . addAll ( formatEl . attributes ( ) ) ; Node [ ] childNodes = furthestBlock . childNodes ( ) . toArray ( new Node [ furthestBlock . childNodeSize ( ) ] ) ; for ( Node childNode : childNodes ) { adopter . appendChild ( childNode ) ; / / append will reparent . thus the clone to avoid concurrent mod .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_35"}
{"buggy_code": "import java . io . * ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . Locale ; * public class DataUtil { private static final Pattern charsetPattern = Pattern . compile ( \" ( ? i ) \\ \\ bcharset = \\ \\ s * \\ \" ? ( [ ^ \\ \\ s ; \\ \" ] * ) \" ) ; static final String defaultCharset = \" UTF - 8 \" ; / / used if not found in header or meta charset private static final int bufferSize = 0x20000 ; / / ~ 130K . String foundCharset ; if ( meta . hasAttr ( \" http - equiv \" ) ) { foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } else { foundCharset = meta . attr ( \" charset \" ) ; } if ( foundCharset ! = null & & foundCharset . length ( ) ! = 0 & & ! foundCharset . equals ( defaultCharset ) ) { / / need to re - decode charsetName = foundCharset ; byteData . rewind ( ) ; docData = Charset . forName ( foundCharset ) . decode ( byteData ) . toString ( ) ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; / / if our advanced charset matching fails . . . . we just take the default } return null ; }", "fixed_code": "import java . io . * ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . nio . charset . IllegalCharsetNameException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . Locale ; * public class DataUtil { private static final Pattern charsetPattern = Pattern . compile ( \" ( ? i ) \\ \\ bcharset = \\ \\ s * ( ? : \\ \" | ' ) ? ( [ ^ \\ \\ s , ; \\ \" ' ] * ) \" ) ; static final String defaultCharset = \" UTF - 8 \" ; / / used if not found in header or meta charset private static final int bufferSize = 0x20000 ; / / ~ 130K . String foundCharset ; if ( meta . hasAttr ( \" http - equiv \" ) ) { foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } else { foundCharset = meta . attr ( \" charset \" ) ; } if ( foundCharset ! = null & & foundCharset . length ( ) ! = 0 & & ! foundCharset . equals ( defaultCharset ) ) { / / need to re - decode foundCharset = foundCharset . trim ( ) . replaceAll ( \" [ \\ \" ' ] \" , \" \" ) ; charsetName = foundCharset ; byteData . rewind ( ) ; docData = Charset . forName ( foundCharset ) . decode ( byteData ) . toString ( ) ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . replace ( \" charset = \" , \" \" ) ; if ( charset . isEmpty ( ) ) return null ; try { if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } catch ( IllegalCharsetNameException e ) { / / if our advanced charset matching fails . . . . we just take the default return null ; } } return null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_36"}
{"buggy_code": "public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return accum . toString ( ) . trim ( ) ; } private void html ( StringBuilder accum ) {", "fixed_code": "public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return getOutputSettings ( ) . prettyPrint ( ) ? accum . toString ( ) . trim ( ) : accum . toString ( ) ; } private void html ( StringBuilder accum ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_37"}
{"buggy_code": "tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( \" image \" ) ) { return tb . process ( startTag . name ( \" img \" ) ) ; / / change < image > to < img > , unless in svg } else if ( name . equals ( \" isindex \" ) ) { / / how much do we care about the early 90s ? tb . error ( this ) ;", "fixed_code": "tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( \" image \" ) ) { if ( tb . getFromStack ( \" svg \" ) = = null ) return tb . process ( startTag . name ( \" img \" ) ) ; / / change < image > to < img > , unless in svg else tb . insert ( startTag ) ; } else if ( name . equals ( \" isindex \" ) ) { / / how much do we care about the early 90s ? tb . error ( this ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_38"}
{"buggy_code": "docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ;", "fixed_code": "docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; doc = null ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_39"}
{"buggy_code": "} catch ( NumberFormatException e ) { } / / skip } else { String name = m . group ( 1 ) . toLowerCase ( ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } for ( Object [ ] entity : baseArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; baseByVal . put ( c , ( ( String ) entity [ 0 ] ) . toLowerCase ( ) ) ; } for ( Object [ ] entity : fullArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; full . put ( ( String ) entity [ 0 ] , c ) ; fullByVal . put ( c , ( ( String ) entity [ 0 ] ) . toLowerCase ( ) ) ; } }", "fixed_code": "} catch ( NumberFormatException e ) { } / / skip } else { String name = m . group ( 1 ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } for ( Object [ ] entity : baseArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; baseByVal . put ( c , ( ( String ) entity [ 0 ] ) ) ; } for ( Object [ ] entity : fullArray ) { Character c = Character . valueOf ( ( char ) ( ( Integer ) entity [ 1 ] ) . intValue ( ) ) ; full . put ( ( String ) entity [ 0 ] , c ) ; fullByVal . put ( c , ( ( String ) entity [ 0 ] ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_4"}
{"buggy_code": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; Validate . notEmpty ( name ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "fixed_code": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_40"}
{"buggy_code": "Element element = ( Element ) o ; return this = = o ; } @ Override", "fixed_code": "Element element = ( Element ) o ; return tag . equals ( element . tag ) ; } @ Override", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_41"}
{"buggy_code": "/ / iterate the form control elements and accumulate their values for ( Element el : elements ) { if ( ! el . tag ( ) . isFormSubmittable ( ) ) continue ; / / contents are form listable , superset of submitable String name = el . attr ( \" name \" ) ; if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; } else if ( \" checkbox \" . equalsIgnoreCase ( type ) | | \" radio \" . equalsIgnoreCase ( type ) ) { / / only add checkbox or radio if they have the checked attribute if ( el . hasAttr ( \" checked \" ) ) { final String val = el . val ( ) ; data . add ( HttpConnection . KeyVal . create ( name , val ) ) ; } } else {", "fixed_code": "/ / iterate the form control elements and accumulate their values for ( Element el : elements ) { if ( ! el . tag ( ) . isFormSubmittable ( ) ) continue ; / / contents are form listable , superset of submitable if ( el . hasAttr ( \" disabled \" ) ) continue ; / / skip disabled form inputs String name = el . attr ( \" name \" ) ; if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; } else if ( \" checkbox \" . equalsIgnoreCase ( type ) | | \" radio \" . equalsIgnoreCase ( type ) ) { / / only add checkbox or radio if they have the checked attribute if ( el . hasAttr ( \" checked \" ) ) { final String val = el . val ( ) . length ( ) > 0 ? el . val ( ) : \" on \" ; data . add ( HttpConnection . KeyVal . create ( name , val ) ) ; } } else {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_42"}
{"buggy_code": "for ( int i = 0 ; i < elements . size ( ) ; i + + ) { E element = elements . get ( i ) ; if ( element . equals ( search ) ) return i ; } return null ;", "fixed_code": "for ( int i = 0 ; i < elements . size ( ) ; i + + ) { E element = elements . get ( i ) ; if ( element = = search ) return i ; } return null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_43"}
{"buggy_code": "protected abstract boolean process ( Token token ) ; protected boolean processStartTag ( String name ) { return process ( start . reset ( ) . name ( name ) ) ; } public boolean processStartTag ( String name , Attributes attrs ) { start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; } protected boolean processEndTag ( String name ) { return process ( end . reset ( ) . name ( name ) ) ; }", "fixed_code": "protected abstract boolean process ( Token token ) ; protected boolean processStartTag ( String name ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . name ( name ) ) ; } return process ( start . reset ( ) . name ( name ) ) ; } public boolean processStartTag ( String name , Attributes attrs ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . nameAttr ( name , attrs ) ) ; } start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; } protected boolean processEndTag ( String name ) { if ( currentToken = = end ) { / / don ' t recycle an in - use token return process ( new Token . EndTag ( ) . name ( name ) ) ; } return process ( end . reset ( ) . name ( name ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_44"}
{"buggy_code": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" td \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "fixed_code": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" th \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_45"}
{"buggy_code": "if ( escapeMode ! = EscapeMode . xhtml ) accum . append ( \" & nbsp ; \" ) ; else accum . append ( c ) ; break ; case ' < ' : if ( ! inAttribute )", "fixed_code": "if ( escapeMode ! = EscapeMode . xhtml ) accum . append ( \" & nbsp ; \" ) ; else accum . append ( \" & # xa0 ; \" ) ; break ; case ' < ' : if ( ! inAttribute )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_46"}
{"buggy_code": "break ; case ' < ' : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! inAttribute ) accum . append ( \" & lt ; \" ) ; else accum . append ( c ) ;", "fixed_code": "break ; case ' < ' : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! inAttribute | | escapeMode = = EscapeMode . xhtml ) accum . append ( \" & lt ; \" ) ; else accum . append ( c ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_47"}
{"buggy_code": "cookie ( cookieName , cookieVal ) ; } } else { / / combine same header names with comma : http : / / www . w3 . org / Protocols / rfc2616 / rfc2616 - sec4 . html # sec4 . 2 if ( ! values . isEmpty ( ) ) header ( name , values . get ( 0 ) ) ; } } }", "fixed_code": "cookie ( cookieName , cookieVal ) ; } } else { / / combine same header names with comma : http : / / www . w3 . org / Protocols / rfc2616 / rfc2616 - sec4 . html # sec4 . 2 if ( values . size ( ) = = 1 ) header ( name , values . get ( 0 ) ) ; else if ( values . size ( ) > 1 ) { StringBuilder accum = new StringBuilder ( ) ; for ( int i = 0 ; i < values . size ( ) ; i + + ) { final String val = values . get ( i ) ; if ( i ! = 0 ) accum . append ( \" , \" ) ; accum . append ( val ) ; } header ( name , accum . toString ( ) ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_48"}
{"buggy_code": "Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; } reindexChildren ( index ) ; } protected void ensureChildNodes ( ) {", "fixed_code": "Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; reindexChildren ( index ) ; } } protected void ensureChildNodes ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_49"}
{"buggy_code": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; }", "fixed_code": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { if ( value . length ( ) = = 0 ) / / no key , no val ; unknown char , keep popping so not get stuck tq . advance ( ) ; return null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_5"}
{"buggy_code": "Document doc = null ; / / look for BOM - overrides any other header or input if ( charsetName = = null ) { / / determine from meta . safe parse as UTF - 8 / / look for < meta http - equiv = \" Content - Type \" content = \" text / html ; charset = gb2312 \" > or HTML5 < meta charset = \" gb2312 \" > Validate . notEmpty ( charsetName , \" Must set charset arg to character set of file to parse . Set to null to attempt to detect from HTML \" ) ; docData = Charset . forName ( charsetName ) . decode ( byteData ) . toString ( ) ; } if ( docData . length ( ) > 0 & & docData . charAt ( 0 ) = = UNICODE_BOM ) { byteData . rewind ( ) ; docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; doc = null ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "fixed_code": "Document doc = null ; / / look for BOM - overrides any other header or input byteData . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; byteData . get ( bom ) ; byteData . rewind ( ) ; if ( bom [ 0 ] = = 0x00 & & bom [ 1 ] = = 0x00 & & bom [ 2 ] = = ( byte ) 0xFE & & bom [ 3 ] = = ( byte ) 0xFF | | / / BE bom [ 0 ] = = ( byte ) 0xFF & & bom [ 1 ] = = ( byte ) 0xFE & & bom [ 2 ] = = 0x00 & & bom [ 3 ] = = 0x00 ) { / / LE charsetName = \" UTF - 32 \" ; / / and I hope it ' s on your system } else if ( bom [ 0 ] = = ( byte ) 0xFE & & bom [ 1 ] = = ( byte ) 0xFF | | / / BE bom [ 0 ] = = ( byte ) 0xFF & & bom [ 1 ] = = ( byte ) 0xFE ) { charsetName = \" UTF - 16 \" ; / / in all Javas } else if ( bom [ 0 ] = = ( byte ) 0xEF & & bom [ 1 ] = = ( byte ) 0xBB & & bom [ 2 ] = = ( byte ) 0xBF ) { charsetName = \" UTF - 8 \" ; / / in all Javas byteData . position ( 3 ) ; / / 16 and 32 decoders consume the BOM to determine be / le ; utf - 8 should be consumed } if ( charsetName = = null ) { / / determine from meta . safe parse as UTF - 8 / / look for < meta http - equiv = \" Content - Type \" content = \" text / html ; charset = gb2312 \" > or HTML5 < meta charset = \" gb2312 \" > Validate . notEmpty ( charsetName , \" Must set charset arg to character set of file to parse . Set to null to attempt to detect from HTML \" ) ; docData = Charset . forName ( charsetName ) . decode ( byteData ) . toString ( ) ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_50"}
{"buggy_code": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ; } boolean matchesDigit ( ) {", "fixed_code": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) | | Character . isLetter ( c ) ; } boolean matchesDigit ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_51"}
{"buggy_code": "package org . jsoup . parser ; import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ;", "fixed_code": "package org . jsoup . parser ; import org . jsoup . Jsoup ; import org . jsoup . helper . Validate ; import org . jsoup . nodes . * ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( el . tagName ( ) , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_52"}
{"buggy_code": "@ return XML declaration public String getWholeDeclaration ( ) { final String decl = this . name ; if ( decl . equals ( \" xml \" ) & & attributes . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( decl ) ; final String version = attributes . get ( \" version \" ) ; if ( version ! = null ) { sb . append ( \" version = \\ \" \" ) . append ( version ) . append ( \" \\ \" \" ) ; } final String encoding = attributes . get ( \" encoding \" ) ; if ( encoding ! = null ) { sb . append ( \" encoding = \\ \" \" ) . append ( encoding ) . append ( \" \\ \" \" ) ; } return sb . toString ( ) ; } else { return this . name ; } } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( getWholeDeclaration ( ) ) . append ( \" > \" ) ; }", "fixed_code": "@ return XML declaration public String getWholeDeclaration ( ) { return attributes . html ( ) . trim ( ) ; / / attr html starts with a \" \" } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( name ) ; attributes . html ( accum , out ) ; accum . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( \" > \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_52"}
{"buggy_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? >", "fixed_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? >", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_52"}
{"buggy_code": "int end = - 1 ; int depth = 0 ; char last = 0 ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = 0 | | last ! = ESC ) { if ( c . equals ( open ) ) { depth + + ; if ( start = = - 1 )", "fixed_code": "int end = - 1 ; int depth = 0 ; char last = 0 ; boolean inQuote = false ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = 0 | | last ! = ESC ) { if ( c . equals ( ' \\ ' ' ) | | c . equals ( ' \" ' ) & & c ! = open ) inQuote = ! inQuote ; if ( inQuote ) continue ; if ( c . equals ( open ) ) { depth + + ; if ( start = = - 1 )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_53"}
{"buggy_code": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "fixed_code": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; if ( key . matches ( \" [ a - zA - Z_ : ] { 1 } [ - a - zA - Z0 - 9_ : . ] * \" ) ) el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_54"}
{"buggy_code": "break ; default : t . error ( this ) ; t . transition ( BeforeAttributeName ) ; } }", "fixed_code": "break ; default : t . error ( this ) ; r . unconsume ( ) ; t . transition ( BeforeAttributeName ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_55"}
{"buggy_code": "t . emitDoctypePending ( ) ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . PUBLIC_KEY ) ) { t . transition ( AfterDoctypePublicKeyword ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . SYSTEM_KEY ) ) { t . transition ( AfterDoctypeSystemKeyword ) ; } else { t . error ( this ) ;", "fixed_code": "t . emitDoctypePending ( ) ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . PUBLIC_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . PUBLIC_KEY ; t . transition ( AfterDoctypePublicKeyword ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . SYSTEM_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . SYSTEM_KEY ; t . transition ( AfterDoctypeSystemKeyword ) ; } else { t . error ( this ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_56"}
{"buggy_code": "public static final String PUBLIC_KEY = \" PUBLIC \" ; public static final String SYSTEM_KEY = \" SYSTEM \" ; private static final String NAME = \" name \" ; private static final String PUBLIC_ID = \" publicId \" ; private static final String SYSTEM_ID = \" systemId \" ; / / todo : quirk mode from publicId and systemId attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } * @ param systemId the doctype ' s system ID * @ param baseUri the doctype ' s base URI @ Override public String nodeName ( ) { } if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ;", "fixed_code": "public static final String PUBLIC_KEY = \" PUBLIC \" ; public static final String SYSTEM_KEY = \" SYSTEM \" ; private static final String NAME = \" name \" ; private static final String PUB_SYS_KEY = \" pubSysKey \" ; / / PUBLIC or SYSTEM private static final String PUBLIC_ID = \" publicId \" ; private static final String SYSTEM_ID = \" systemId \" ; / / todo : quirk mode from publicId and systemId attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; if ( has ( PUBLIC_ID ) ) { attr ( PUB_SYS_KEY , PUBLIC_KEY ) ; } attr ( SYSTEM_ID , systemId ) ; } * @ param systemId the doctype ' s system ID * @ param baseUri the doctype ' s base URI public DocumentType ( String name , String pubSysKey , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; if ( pubSysKey ! = null ) { attr ( PUB_SYS_KEY , pubSysKey ) ; } attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } @ Override public String nodeName ( ) { } if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUB_SYS_KEY ) ) accum . append ( \" \" ) . append ( attr ( PUB_SYS_KEY ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_56"}
{"buggy_code": "} void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; }", "fixed_code": "} void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_56"}
{"buggy_code": "/ / todo : quirk state check on doctype ids Token . Doctype d = t . asDoctype ( ) ; DocumentType doctype = new DocumentType ( tb . settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , tb . getBaseUri ( ) ) ; tb . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) tb . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ;", "fixed_code": "/ / todo : quirk state check on doctype ids Token . Doctype d = t . asDoctype ( ) ; DocumentType doctype = new DocumentType ( tb . settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , tb . getBaseUri ( ) ) ; tb . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) tb . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Jsoup_56"}
{"buggy_code": "static final class Doctype extends Token { final StringBuilder name = new StringBuilder ( ) ; final StringBuilder publicIdentifier = new StringBuilder ( ) ; final StringBuilder systemIdentifier = new StringBuilder ( ) ; boolean forceQuirks = false ; @ Override Token reset ( ) { reset ( name ) ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return name . toString ( ) ; } String getPublicIdentifier ( ) { return publicIdentifier . toString ( ) ;", "fixed_code": "static final class Doctype extends Token { final StringBuilder name = new StringBuilder ( ) ; String pubSysKey = null ; final StringBuilder publicIdentifier = new StringBuilder ( ) ; final StringBuilder systemIdentifier = new StringBuilder ( ) ; boolean forceQuirks = false ; @ Override Token reset ( ) { reset ( name ) ; pubSysKey = null ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return name . toString ( ) ; } String getPubSysKey ( ) { return pubSysKey ; } String getPublicIdentifier ( ) { return publicIdentifier . toString ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "Jsoup_56"}
{"buggy_code": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) attributes . remove ( attrKey ) ; } }", "fixed_code": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) it . remove ( ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_57"}
{"buggy_code": "import org . jsoup . select . NodeTraversor ; import org . jsoup . select . NodeVisitor ;", "fixed_code": "import org . jsoup . select . NodeTraversor ; import org . jsoup . select . NodeVisitor ; import java . util . List ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_58"}
{"buggy_code": "@ see # clean ( String , org . jsoup . safety . Whitelist ) public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } }", "fixed_code": "@ see # clean ( String , org . jsoup . safety . Whitelist ) public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_58"}
{"buggy_code": "* * @ return list of nodes parsed from the input HTML . Note that the context element , if supplied , is not modified .", "fixed_code": "* * @ return list of nodes parsed from the input HTML . Note that the context element , if supplied , is not modified . public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri , ParseErrorList errorList ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , errorList , treeBuilder . defaultSettings ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_58"}
{"buggy_code": "if ( pendingAttributeName ! = null ) { / / the tokeniser has skipped whitespace control chars , but trimming could collapse to empty for other control codes , so verify here pendingAttributeName = pendingAttributeName . trim ( ) ; Attribute attribute ; if ( hasPendingAttributeValue ) attribute = new Attribute ( pendingAttributeName , else attribute = new BooleanAttribute ( pendingAttributeName ) ; attributes . put ( attribute ) ; } pendingAttributeName = null ; hasEmptyAttributeValue = false ;", "fixed_code": "if ( pendingAttributeName ! = null ) { / / the tokeniser has skipped whitespace control chars , but trimming could collapse to empty for other control codes , so verify here pendingAttributeName = pendingAttributeName . trim ( ) ; if ( pendingAttributeName . length ( ) > 0 ) { Attribute attribute ; if ( hasPendingAttributeValue ) attribute = new Attribute ( pendingAttributeName , else attribute = new BooleanAttribute ( pendingAttributeName ) ; attributes . put ( attribute ) ; } } pendingAttributeName = null ; hasEmptyAttributeValue = false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_59"}
{"buggy_code": "if ( charval ! = - 1 | | charval > 0xFFFF ) { / / out of range String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , c ) ; } else { m . appendReplacement ( accum , m . group ( 0 ) ) ; } } m . appendTail ( accum ) ;", "fixed_code": "if ( charval ! = - 1 | | charval > 0xFFFF ) { / / out of range String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , Matcher . quoteReplacement ( c ) ) ; } else { m . appendReplacement ( accum , Matcher . quoteReplacement ( m . group ( 0 ) ) ) ; / / replace with original string } } m . appendTail ( accum ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_6"}
{"buggy_code": "* @ return Evaluator public static Evaluator parse ( String query ) { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; }", "fixed_code": "* @ return Evaluator public static Evaluator parse ( String query ) { try { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } catch ( IllegalArgumentException e ) { throw new Selector . SelectorParseException ( e . getMessage ( ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_60"}
{"buggy_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; return out ; }", "fixed_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; if ( depth > 0 ) { / / ran out of queue before seeing enough ) Validate . fail ( \" Did not find balanced maker at \" + out ) ; } return out ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_60"}
{"buggy_code": "/ / performance sensitive public boolean hasClass ( String className ) { final String classAttr = attributes . get ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "fixed_code": "/ / performance sensitive public boolean hasClass ( String className ) { final String classAttr = attributes . getIgnoreCase ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_61"}
{"buggy_code": "} boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ( ) ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ;", "fixed_code": "} boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . name ( ) ; / / matches with case sensitivity if enabled ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_62"}
{"buggy_code": "Token . Doctype doctypePending = new Token . Doctype ( ) ; / / doctype building up Token . Comment commentPending = new Token . Comment ( ) ; / / comment building up private String lastStartTag ; / / the last start tag emitted , to test appropriate end tag private boolean selfClosingFlagAcknowledged = true ; Tokeniser ( CharacterReader reader , ParseErrorList errors ) { this . reader = reader ; } Token read ( ) { if ( ! selfClosingFlagAcknowledged ) { error ( \" Self closing flag not acknowledged \" ) ; selfClosingFlagAcknowledged = true ; } while ( ! isEmitPending ) state . read ( this , reader ) ; if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; if ( startTag . selfClosing ) selfClosingFlagAcknowledged = false ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) this . state = state ; } void acknowledgeSelfClosingFlag ( ) { selfClosingFlagAcknowledged = true ; } final private int [ ] codepointHolder = new int [ 1 ] ; / / holder to not have to keep creating arrays final private int [ ] multipointHolder = new int [ 2 ] ; int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) {", "fixed_code": "Token . Doctype doctypePending = new Token . Doctype ( ) ; / / doctype building up Token . Comment commentPending = new Token . Comment ( ) ; / / comment building up private String lastStartTag ; / / the last start tag emitted , to test appropriate end tag Tokeniser ( CharacterReader reader , ParseErrorList errors ) { this . reader = reader ; } Token read ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) this . state = state ; } final private int [ ] codepointHolder = new int [ 1 ] ; / / holder to not have to keep creating arrays final private int [ ] multipointHolder = new int [ 2 ] ; int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_63"}
{"buggy_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( tag . isSelfClosing ( ) ) tokeniser . acknowledgeSelfClosingFlag ( ) ; } else { tag . setSelfClosing ( ) ; tokeniser . acknowledgeSelfClosingFlag ( ) ; } } return el ; }", "fixed_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( \" Tag cannot be self closing ; not a void tag \" ) ; } else / / unknown tag , remember this is self closing for output tag . setSelfClosing ( ) ; } return el ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_63"}
{"buggy_code": "} private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . insert ( startTag ) ; tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; } / / lists of tags to search through . A little harder to read here , but causes less GC than dynamic varargs .", "fixed_code": "} private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; tb . insert ( startTag ) ; } / / lists of tags to search through . A little harder to read here , but causes less GC than dynamic varargs .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_64"}
{"buggy_code": "} void clearStackToTableBodyContext ( ) { clearStackToContext ( \" tbody \" , \" tfoot \" , \" thead \" ) ; } void clearStackToTableRowContext ( ) { clearStackToContext ( \" tr \" ) ; } private void clearStackToContext ( String . . . nodeNames ) {", "fixed_code": "} void clearStackToTableBodyContext ( ) { clearStackToContext ( \" tbody \" , \" tfoot \" , \" thead \" , \" template \" ) ; } void clearStackToTableRowContext ( ) { clearStackToContext ( \" tr \" , \" template \" ) ; } private void clearStackToContext ( String . . . nodeNames ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_65"}
{"buggy_code": "case StartTag : Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( \" tr \" ) ) { tb . clearStackToTableBodyContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InRow ) ; Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( StringUtil . in ( name , \" th \" , \" td \" ) ) { tb . clearStackToTableRowContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InCell ) ;", "fixed_code": "case StartTag : Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( \" template \" ) ) { tb . insert ( startTag ) ; } else if ( name . equals ( \" tr \" ) ) { tb . clearStackToTableBodyContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InRow ) ; Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( \" template \" ) ) { tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , \" th \" , \" td \" ) ) { tb . clearStackToTableRowContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InCell ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_65"}
{"buggy_code": "protected List < Node > ensureChildNodes ( ) { if ( childNodes = = EMPTY_NODES ) { childNodes = new NodeList ( 4 ) ; } return childNodes ; } Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; } private final class NodeList extends ChangeNotifyingArrayList < Node > { NodeList ( int initialCapacity ) { super ( initialCapacity ) ; } public void onContentsChanged ( ) { nodelistChanged ( ) ; } } }", "fixed_code": "protected List < Node > ensureChildNodes ( ) { if ( childNodes = = EMPTY_NODES ) { childNodes = new NodeList ( this , 4 ) ; } return childNodes ; } Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( clone , childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; } private static final class NodeList extends ChangeNotifyingArrayList < Node > { private final Element owner ;  NodeList ( Element owner , int initialCapacity ) { super ( initialCapacity ) ; this . owner = owner ; } public void onContentsChanged ( ) { owner . nodelistChanged ( ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_66"}
{"buggy_code": "\" section \" , \" select \" , \" style \" , \" summary \" , \" table \" , \" tbody \" , \" td \" , \" textarea \" , \" tfoot \" , \" th \" , \" thead \" , \" title \" , \" tr \" , \" ul \" , \" wbr \" , \" xmp \" } ) ; private HtmlTreeBuilderState state ; / / the current state private HtmlTreeBuilderState originalState ; / / original / marked state private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { int depth = stack . size ( ) - 1 ; for ( int pos = depth ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ;", "fixed_code": "\" section \" , \" select \" , \" style \" , \" summary \" , \" table \" , \" tbody \" , \" td \" , \" textarea \" , \" tfoot \" , \" th \" , \" thead \" , \" title \" , \" tr \" , \" ul \" , \" wbr \" , \" xmp \" } ) ; public static final int MaxScopeSearchDepth = 100 ; / / prevents the parser bogging down in exceptionally broken pages private HtmlTreeBuilderState state ; / / the current state private HtmlTreeBuilderState originalState ; / / original / marked state private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { int depth = stack . size ( ) - 1 ; if ( depth > MaxScopeSearchDepth ) { depth = MaxScopeSearchDepth ; } for ( int pos = depth ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_67"}
{"buggy_code": "private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { / / https : / / html . spec . whatwg . org / multipage / parsing . html # has - an - element - in - the - specific - scope int bottom = stack . size ( ) - 1 ; if ( bottom > MaxScopeSearchDepth ) { bottom = MaxScopeSearchDepth ; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; / / don ' t walk too far up the tree", "fixed_code": "private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { / / https : / / html . spec . whatwg . org / multipage / parsing . html # has - an - element - in - the - specific - scope final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; / / don ' t walk too far up the tree", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_68"}
{"buggy_code": "return this ; }", "fixed_code": "return this ; } @ Override protected void removeChild ( Node out ) { super . removeChild ( out ) ; elements . remove ( out ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_69"}
{"buggy_code": "import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; return this ; } } / / merge multiple < head > or < body > contents into one , delete the remainder , and ensure they are owned by < html > / / ensure parented by < html > / / fast method to get first by tag name , used for html , head , body finders private Element findFirstElementByTagName ( String tag , Node node ) {", "fixed_code": "import org . jsoup . helper . Validate ; import org . jsoup . parser . Tag ; import org . jsoup . select . Elements ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; normaliseStructure ( \" head \" , htmlEl ) ; normaliseStructure ( \" body \" , htmlEl ) ; return this ; } } / / merge multiple < head > or < body > contents into one , delete the remainder , and ensure they are owned by < html > private void normaliseStructure ( String tag , Element htmlEl ) { Elements elements = this . getElementsByTag ( tag ) ; Element master = elements . first ( ) ; / / will always be available as created above if not existent if ( elements . size ( ) > 1 ) { / / dupes , move contents to master List < Node > toMove = new ArrayList < Node > ( ) ; for ( int i = 1 ; i < elements . size ( ) ; i + + ) { Node dupe = elements . get ( i ) ; for ( Node node : dupe . childNodes ) toMove . add ( node ) ; dupe . remove ( ) ; }  for ( Node dupe : toMove ) master . appendChild ( dupe ) ; } / / ensure parented by < html > if ( ! master . parent ( ) . equals ( htmlEl ) ) { htmlEl . appendChild ( master ) ; / / includes remove ( ) } } / / fast method to get first by tag name , used for html , head , body finders private Element findFirstElementByTagName ( String tag , Node node ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_7"}
{"buggy_code": "/ / looks only at this element and five levels up , to prevent recursion & needless stack searches if ( node ! = null & & node instanceof Element ) { Element el = ( Element ) node ; if ( el . tag . preserveWhitespace ( ) ) return true ; else return el . parent ( ) ! = null & & el . parent ( ) . tag . preserveWhitespace ( ) ; } return false ; }", "fixed_code": "/ / looks only at this element and five levels up , to prevent recursion & needless stack searches if ( node ! = null & & node instanceof Element ) { Element el = ( Element ) node ; int i = 0 ; do { if ( el . tag . preserveWhitespace ( ) ) return true ; el = el . parent ( ) ; i + + ; } while ( i < 6 & & el ! = null ) ; } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_70"}
{"buggy_code": "import org . jsoup . nodes . DocumentType ; import org . jsoup . nodes . Element ; import org . jsoup . nodes . Node ; import org . jsoup . nodes . XmlDeclaration ; import java . util . List ; } } }", "fixed_code": "import org . jsoup . nodes . DocumentType ; import org . jsoup . nodes . Element ; import org . jsoup . nodes . Node ; import org . jsoup . nodes . PseudoTextElement ; import org . jsoup . nodes . TextNode ; import org . jsoup . nodes . XmlDeclaration ; import java . util . List ; } } public static final class MatchText extends Evaluator { @ Override public boolean matches ( Element root , Element element ) { if ( element instanceof PseudoTextElement ) return true ;  List < TextNode > textNodes = element . textNodes ( ) ; for ( TextNode textNode : textNodes ) { PseudoTextElement pel = new PseudoTextElement ( org . jsoup . parser . Tag . valueOf ( element . tagName ( ) ) , element . baseUri ( ) , element . attributes ( ) ) ; textNode . replaceWith ( pel ) ; pel . appendChild ( textNode ) ; } return false ; } @ Override public String toString ( ) { return \" : matchText \" ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_71"}
{"buggy_code": "evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( \" : root \" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else / / unhandled throw new Selector . SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ;", "fixed_code": "evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( \" : root \" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else if ( tq . matchChomp ( \" : matchText \" ) ) evals . add ( new Evaluator . MatchText ( ) ) ; else / / unhandled throw new Selector . SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_71"}
{"buggy_code": "/ / limit ( no cache ) : if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; / / calculate hash : int hash = 0 ;", "fixed_code": "/ / limit ( no cache ) : if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return \" \" ; / / calculate hash : int hash = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_72"}
{"buggy_code": "import javax . xml . transform . stream . StreamResult ; import java . io . StringWriter ; import java . util . HashMap ;", "fixed_code": "import javax . xml . transform . stream . StreamResult ; import java . io . StringWriter ; import java . util . HashMap ; import java . util . Stack ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_73"}
{"buggy_code": "/ / 160 is & nbsp ; ( non - breaking space ) . Not in the spec but expected . } / / zero width sp , zw non join , zw join , soft hyphen", "fixed_code": "/ / 160 is & nbsp ; ( non - breaking space ) . Not in the spec but expected . } public static boolean isInvisibleChar ( int c ) { return Character . getType ( c ) = = 16 & & ( c = = 8203 | | c = = 8204 | | c = = 8205 | | c = = 173 ) ; / / zero width sp , zw non join , zw join , soft hyphen }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_74"}
{"buggy_code": "accum . append ( ' ' ) . append ( key ) ; / / collapse checked = null , checked = \" \" , checked = checked ; write out others if ( ! ( out . syntax ( ) = = Document . OutputSettings . Syntax . html & & ( val = = null | | val . equals ( key ) & & Attribute . isBooleanAttribute ( key ) ) ) ) { accum . append ( \" = \\ \" \" ) ; Entities . escape ( accum , val = = null ? EmptyString : val , out , true , false , false ) ; accum . append ( ' \" ' ) ;", "fixed_code": "accum . append ( ' ' ) . append ( key ) ; / / collapse checked = null , checked = \" \" , checked = checked ; write out others if ( ! Attribute . shouldCollapseAttribute ( key , val , out ) ) { accum . append ( \" = \\ \" \" ) ; Entities . escape ( accum , val = = null ? EmptyString : val , out , true , false , false ) ; accum . append ( ' \" ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_75"}
{"buggy_code": "tb . processEndTag ( \" p \" ) ; } tb . insert ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( \" form \" ) ) { if ( tb . getFormElement ( ) ! = null ) {", "fixed_code": "tb . processEndTag ( \" p \" ) ; } tb . insert ( startTag ) ; tb . reader . matchConsume ( \" \\ n \" ) ; / / ignore LF if next token tb . framesetOk ( false ) ; } else if ( name . equals ( \" form \" ) ) { if ( tb . getFormElement ( ) ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_76"}
{"buggy_code": "* @ param endTag tag to close private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . name ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) {", "fixed_code": "* @ param endTag tag to close private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . normalName ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_77"}
{"buggy_code": "package org . jsoup . helper ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; if ( charsetName = = null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; doc = parser . parseInput ( reader , baseUri ) ; / / io exception when parsing ( not seen before because reading the stream as we go ) doc . outputSettings ( ) . charset ( charsetName ) ; } input . close ( ) ;", "fixed_code": "package org . jsoup . helper ; import org . jsoup . UncheckedIOException ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; if ( charsetName = = null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; try { doc = parser . parseInput ( reader , baseUri ) ; } catch ( UncheckedIOException e ) { / / io exception when parsing ( not seen before because reading the stream as we go ) throw e . ioException ( ) ; } doc . outputSettings ( ) . charset ( charsetName ) ; } input . close ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_78"}
{"buggy_code": "import org . jsoup . helper . Validate ; import java . util . List ; abstract class LeafNode extends Node { Object value ; / / either a string value , or an attribute map ( in the rare case multiple attributes are set ) @ Override protected List < Node > ensureChildNodes ( ) { throw new UnsupportedOperationException ( \" Leaf Nodes do not have child nodes . \" ) ; } }", "fixed_code": "import org . jsoup . helper . Validate ; import java . util . Collections ; import java . util . List ; abstract class LeafNode extends Node { private static final List < Node > EmptyNodes = Collections . emptyList ( ) ; Object value ; / / either a string value , or an attribute map ( in the rare case multiple attributes are set ) @ Override protected List < Node > ensureChildNodes ( ) { return EmptyNodes ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_79"}
{"buggy_code": "} protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , ownerDocument ( ) . outputSettings ( ) ) ) . traverse ( this ) ; } / / if this node has no document ( or parent ) , retrieve the default output settings", "fixed_code": "} protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , getOutputSettings ( ) ) ) . traverse ( this ) ; } / / if this node has no document ( or parent ) , retrieve the default output settings private Document . OutputSettings getOutputSettings ( ) { return ownerDocument ( ) ! = null ? ownerDocument ( ) . outputSettings ( ) : ( new Document ( \" \" ) ) . outputSettings ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_8"}
{"buggy_code": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "fixed_code": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } / / else , we couldn ' t parse it as a decl , so leave as a comment } } insertNode ( insert ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_80"}
{"buggy_code": "import org . jsoup . UncheckedIOException ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; import org . jsoup . nodes . Node ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "fixed_code": "import org . jsoup . UncheckedIOException ; import org . jsoup . internal . ConstrainableInputStream ; import org . jsoup . nodes . Comment ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; import org . jsoup . nodes . Node ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_81"}
{"buggy_code": "} Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; / / some charsets can read but not encode ; switch to an encodable charset and update the meta el } input . close ( ) ; return doc ;", "fixed_code": "} Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; if ( ! charset . canEncode ( ) ) { / / some charsets can read but not encode ; switch to an encodable charset and update the meta el doc . charset ( Charset . forName ( defaultCharset ) ) ; } } input . close ( ) ; return doc ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_82"}
{"buggy_code": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; }", "fixed_code": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = ' < ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_83"}
{"buggy_code": "case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; / / intended fall through to next > case ' > ' : t . emitTagPending ( ) ; case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; / / intended fall through as if > case ' > ' : t . emitTagPending ( ) ; break ; case ' \" ' : case ' \\ ' ' : case ' < ' : case ' = ' : t . error ( this ) ; t . tagPending . newAttribute ( ) ;", "fixed_code": "case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; case ' < ' : / / NOTE : out of spec , but clear author intent t . error ( this ) ; r . unconsume ( ) ; / / intended fall through to next > case ' > ' : t . emitTagPending ( ) ; case ' / ' : t . transition ( SelfClosingStartTag ) ; break ; case ' < ' : / / NOTE : out of spec , but clear ( spec has this as a part of the attribute name ) t . error ( this ) ; r . unconsume ( ) ; / / intended fall through as if > case ' > ' : t . emitTagPending ( ) ; break ; case ' \" ' : case ' \\ ' ' : case ' = ' : t . error ( this ) ; t . tagPending . newAttribute ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_83"}
{"buggy_code": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "fixed_code": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace = = null & & tagName . contains ( \" : \" ) ? doc . createElementNS ( \" \" , tagName ) : / / doesn ' t have a real namespace defined doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_84"}
{"buggy_code": "public Attribute ( String key , String val , Attributes parent ) { Validate . notNull ( key ) ; this . key = key . trim ( ) ; Validate . notEmpty ( key ) ; / / trimming could potentially make empty , so validate here this . val = val ; this . parent = parent ; }", "fixed_code": "public Attribute ( String key , String val , Attributes parent ) { Validate . notNull ( key ) ; key = key . trim ( ) ; Validate . notEmpty ( key ) ; / / trimming could potentially make empty , so validate here this . key = key ; this . val = val ; this . parent = parent ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_85"}
{"buggy_code": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "fixed_code": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_86"}
{"buggy_code": "Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { return next ; } } for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) break ; } } for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . nodeName ( ) , elNames ) ) break ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . nodeName ( ) , nodeNames ) | | next . nodeName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; last = true ; node = contextElement ; } String name = node . nodeName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . nodeName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except process , then the UA must perform the above steps as if that element was not in the above list . void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . nodeName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . nodeName ( ) , TagSearchEndTags ) ) pop ( ) ; } boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . nodeName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . nodeName ( ) . equals ( b . nodeName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . nodeName ( ) ) ; / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . nodeName ( ) . equals ( nodeName ) ) return next ; } return null ;", "fixed_code": "Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) break ; } } for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . normalName ( ) , elNames ) ) break ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) | | next . normalName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . normalName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except process , then the UA must perform the above steps as if that element was not in the above list . void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; } boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . normalName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . normalName ( ) . equals ( b . normalName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . normalName ( ) ) ; / / todo : avoid fostering here ? / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . normalName ( ) . equals ( nodeName ) ) return next ; } return null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_87"}
{"buggy_code": "package org . jsoup . parser ; import org . jsoup . helper . Validate ; import java . util . HashMap ; import java . util . Map ; private static final Map < String , Tag > tags = new HashMap < > ( ) ; / / map of known tags private String tagName ; private boolean isBlock = true ; / / block or inline private boolean formatAsBlock = true ; / / should be formatted as a block private boolean canContainInline = true ; / / only pcdata if not private Tag ( String tagName ) { this . tagName = tagName ; }", "fixed_code": "package org . jsoup . parser ; import org . jsoup . helper . Validate ; import org . jsoup . internal . Normalizer ; import java . util . HashMap ; import java . util . Map ; private static final Map < String , Tag > tags = new HashMap < > ( ) ; / / map of known tags private String tagName ; private String normalName ; / / always the lower case version of this tag , regardless of case preservation mode private boolean isBlock = true ; / / block or inline private boolean formatAsBlock = true ; / / should be formatted as a block private boolean canContainInline = true ; / / only pcdata if not private Tag ( String tagName ) { this . tagName = tagName ; normalName = Normalizer . lowerCase ( tagName ) ; } public String normalName ( ) { return normalName ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_87"}
{"buggy_code": "* of the tag case preserving setting of the parser . * @ return", "fixed_code": "* of the tag case preserving setting of the parser . * @ return public String normalName ( ) { return tag . normalName ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_87"}
{"buggy_code": "ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( el . nodeName ( ) . equals ( \" li \" ) ) { tb . processEndTag ( \" li \" ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . nodeName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . nodeName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else { } else if ( name . equals ( \" frameset \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . nodeName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else if ( ! tb . framesetOk ( ) ) { if ( tb . inButtonScope ( \" p \" ) ) { tb . processEndTag ( \" p \" ) ; } if ( StringUtil . inSorted ( tb . currentElement ( ) . nodeName ( ) , Constants . Headings ) ) { tb . error ( this ) ; tb . pop ( ) ; } ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( StringUtil . inSorted ( el . nodeName ( ) , Constants . DdDt ) ) { tb . processEndTag ( el . nodeName ( ) ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . nodeName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { else tb . transition ( InSelect ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartOptions ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartRuby ) ) { if ( tb . inScope ( \" ruby \" ) ) { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" ruby \" ) ) { tb . error ( this ) ; tb . popStackToBefore ( \" ruby \" ) ; / / i . e . close up to but not include name } tb . error ( this ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } else if ( ! tb . inScope ( formatEl . nodeName ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement ( ) ! = formatEl ) } } if ( furthestBlock = = null ) { tb . popStackToClose ( formatEl . nodeName ( ) ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } lastNode = node ; } if ( StringUtil . inSorted ( commonAncestor . nodeName ( ) , Constants . InBodyEndTableFosters ) ) { if ( lastNode . parent ( ) ! = null ) lastNode . remove ( ) ; tb . insertInFosterParent ( lastNode ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; / / remove currentForm from stack . will shift anything under up . tb . removeFromStack ( currentForm ) ; return tb . process ( endTag ) ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( Constants . Headings ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; } boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = tb . settings . normalizeTag ( t . asEndTag ( ) . name ( ) ) ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ; if ( node . nodeName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . nodeName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } return true ; / / todo : as above todo } else if ( t . isEOF ( ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; return true ; / / stops parsing } boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . nodeName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; if ( ! isWhitespace ( character ) ) { / / InTable anything else section : tb . error ( this ) ; if ( StringUtil . in ( tb . currentElement ( ) . nodeName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; tb . process ( new Token . Character ( ) . data ( character ) , InBody ) ; tb . setFosterInserts ( false ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" caption \" ) ) tb . error ( this ) ; tb . popStackToClose ( \" caption \" ) ; tb . clearFormattingElementsToLastMarker ( ) ; case EndTag : Token . EndTag endTag = t . asEndTag ( ) ; if ( endTag . normalName . equals ( \" colgroup \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; break ; case EOF : if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) return true ; / / stop parsing ; frag case else return anythingElse ( t , tb ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . nodeName ( ) ) ; return tb . process ( t ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; if ( name . equals ( \" html \" ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( \" option \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" optgroup \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; else if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" optgroup \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" select \" ) ) { name = end . normalName ( ) ; switch ( name ) { case \" optgroup \" : if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) & & tb . aboveOnStack ( tb . currentElement ( ) ) ! = null & & tb . aboveOnStack ( tb . currentElement ( ) ) . nodeName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" option \" ) ; if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" optgroup \" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case \" option \" : if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" option \" ) ) tb . pop ( ) ; else tb . error ( this ) ; } break ; case EOF : if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; break ; default : return false ; } } else if ( t . isEndTag ( ) & & t . asEndTag ( ) . normalName ( ) . equals ( \" frameset \" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return false ; } else { tb . pop ( ) ; if ( ! tb . isFragmentParsing ( ) & & ! tb . currentElement ( ) . nodeName ( ) . equals ( \" frameset \" ) ) { tb . transition ( AfterFrameset ) ; } } } else if ( t . isEOF ( ) ) { if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return true ; }", "fixed_code": "ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( el . normalName ( ) . equals ( \" li \" ) ) { tb . processEndTag ( \" li \" ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . normalName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { } else if ( name . equals ( \" body \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . normalName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else { } else if ( name . equals ( \" frameset \" ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) = = 1 | | ( stack . size ( ) > 2 & & ! stack . get ( 1 ) . normalName ( ) . equals ( \" body \" ) ) ) { / / only in fragment case return false ; / / ignore } else if ( ! tb . framesetOk ( ) ) { if ( tb . inButtonScope ( \" p \" ) ) { tb . processEndTag ( \" p \" ) ; } if ( StringUtil . inSorted ( tb . currentElement ( ) . normalName ( ) , Constants . Headings ) ) { tb . error ( this ) ; tb . pop ( ) ; } ArrayList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i - - ) { Element el = stack . get ( i ) ; if ( StringUtil . inSorted ( el . normalName ( ) , Constants . DdDt ) ) { tb . processEndTag ( el . normalName ( ) ) ; break ; } if ( tb . isSpecial ( el ) & & ! StringUtil . inSorted ( el . normalName ( ) , Constants . InBodyStartLiBreakers ) ) break ; } if ( tb . inButtonScope ( \" p \" ) ) { else tb . transition ( InSelect ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartOptions ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartRuby ) ) { if ( tb . inScope ( \" ruby \" ) ) { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" ruby \" ) ) { tb . error ( this ) ; tb . popStackToBefore ( \" ruby \" ) ; / / i . e . close up to but not include name } tb . error ( this ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } else if ( ! tb . inScope ( formatEl . normalName ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement ( ) ! = formatEl ) } } if ( furthestBlock = = null ) { tb . popStackToClose ( formatEl . normalName ( ) ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } lastNode = node ; } if ( StringUtil . inSorted ( commonAncestor . normalName ( ) , Constants . InBodyEndTableFosters ) ) { if ( lastNode . parent ( ) ! = null ) lastNode . remove ( ) ; tb . insertInFosterParent ( lastNode ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; / / remove currentForm from stack . will shift anything under up . tb . removeFromStack ( currentForm ) ; return tb . process ( endTag ) ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( Constants . Headings ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; } boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; / / case insensitive search - goal is to preserve output case , not for the parse to be case sensitive ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } return true ; / / todo : as above todo } else if ( t . isEOF ( ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; return true ; / / stops parsing } boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; if ( ! isWhitespace ( character ) ) { / / InTable anything else section : tb . error ( this ) ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , \" table \" , \" tbody \" , \" tfoot \" , \" thead \" , \" tr \" ) ) { tb . setFosterInserts ( true ) ; tb . process ( new Token . Character ( ) . data ( character ) , InBody ) ; tb . setFosterInserts ( false ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" caption \" ) ) tb . error ( this ) ; tb . popStackToClose ( \" caption \" ) ; tb . clearFormattingElementsToLastMarker ( ) ; case EndTag : Token . EndTag endTag = t . asEndTag ( ) ; if ( endTag . normalName . equals ( \" colgroup \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) { / / frag case tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; break ; case EOF : if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) return true ; / / stop parsing ; frag case else return anythingElse ( t , tb ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; / / tbody , tfoot , thead return tb . process ( t ) ; } return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; if ( name . equals ( \" html \" ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( \" option \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" optgroup \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . processEndTag ( \" option \" ) ; else if ( tb . currentElement ( ) . normalName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" optgroup \" ) ; tb . insert ( start ) ; } else if ( name . equals ( \" select \" ) ) { name = end . normalName ( ) ; switch ( name ) { case \" optgroup \" : if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) & & tb . aboveOnStack ( tb . currentElement ( ) ) ! = null & & tb . aboveOnStack ( tb . currentElement ( ) ) . normalName ( ) . equals ( \" optgroup \" ) ) tb . processEndTag ( \" option \" ) ; if ( tb . currentElement ( ) . normalName ( ) . equals ( \" optgroup \" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case \" option \" : if ( tb . currentElement ( ) . normalName ( ) . equals ( \" option \" ) ) tb . pop ( ) ; else tb . error ( this ) ; } break ; case EOF : if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) tb . error ( this ) ; break ; default : return false ; } } else if ( t . isEndTag ( ) & & t . asEndTag ( ) . normalName ( ) . equals ( \" frameset \" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) { / / frag tb . error ( this ) ; return false ; } else { tb . pop ( ) ; if ( ! tb . isFragmentParsing ( ) & & ! tb . currentElement ( ) . normalName ( ) . equals ( \" frameset \" ) ) { tb . transition ( AfterFrameset ) ; } } } else if ( t . isEOF ( ) ) { if ( ! tb . currentElement ( ) . normalName ( ) . equals ( \" html \" ) ) { tb . error ( this ) ; return true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Jsoup_87"}
{"buggy_code": "@ return the attribute value public String getValue ( ) { return val ; }", "fixed_code": "@ return the attribute value public String getValue ( ) { return Attributes . checkNotNull ( val ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_88"}
{"buggy_code": "@ param val the new attribute value ; must not be null public String setValue ( String val ) { String oldVal = parent . get ( this . key ) ; if ( parent ! = null ) { int i = parent . indexOfKey ( this . key ) ; if ( i ! = Attributes . NotFound ) parent . vals [ i ] = val ;", "fixed_code": "@ param val the new attribute value ; must not be null public String setValue ( String val ) { String oldVal = this . val ; if ( parent ! = null ) { oldVal = parent . get ( this . key ) ; / / trust the container more int i = parent . indexOfKey ( this . key ) ; if ( i ! = Attributes . NotFound ) parent . vals [ i ] = val ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_89"}
{"buggy_code": "private static final Map < Character , String > xhtmlByVal ; private static final Map < Character , String > baseByVal ; private static final Map < Character , String > fullByVal ; private static final Pattern unescapePattern = Pattern . compile ( \" & ( # ( x | X ) ? ( [ 0 - 9a - fA - F ] + ) | [ a - zA - Z ] + ) ; ? \" ) ; static String escape ( String string , Document . OutputSettings out ) { return escape ( string , out . encoder ( ) , out . escapeMode ( ) ) ;", "fixed_code": "private static final Map < Character , String > xhtmlByVal ; private static final Map < Character , String > baseByVal ; private static final Map < Character , String > fullByVal ; private static final Pattern unescapePattern = Pattern . compile ( \" & ( # ( x | X ) ? ( [ 0 - 9a - fA - F ] + ) | [ a - zA - Z ] + \\ \\ d * ) ; ? \" ) ; static String escape ( String string , Document . OutputSettings out ) { return escape ( string , out . encoder ( ) , out . escapeMode ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_9"}
{"buggy_code": "return false ; } while ( i < end ) { i + + ;", "fixed_code": "return false ; } if ( end > = input . length ) return false ; while ( i < end ) { i + + ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_90"}
{"buggy_code": "charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; } public CharacterReader ( Reader input ) { return ( nextIndexOf ( loScan ) > - 1 ) | | ( nextIndexOf ( hiScan ) > - 1 ) ; } @ Override public String toString ( ) {", "fixed_code": "charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; if ( isBinary ( ) ) { throw new UncheckedIOException ( \" Input is binary and unsupported \" ) ; } } public CharacterReader ( Reader input ) { return ( nextIndexOf ( loScan ) > - 1 ) | | ( nextIndexOf ( hiScan ) > - 1 ) ; } private static final int numNullsConsideredBinary = 10 ; / / conservative boolean isBinary ( ) { int nullsSeen = 0 ; for ( int i = bufPos ; i < bufLength ; i + + ) { if ( charBuf [ i ] = = ' \\ 0 ' ) nullsSeen + + ; } return nullsSeen > = numNullsConsideredBinary ; } @ Override public String toString ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_91"}
{"buggy_code": "super ( cause ) ; } public IOException ioException ( ) { return ( IOException ) getCause ( ) ;", "fixed_code": "super ( cause ) ; } public UncheckedIOException ( String message ) { super ( new IOException ( message ) ) ; } public IOException ioException ( ) { return ( IOException ) getCause ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_91"}
{"buggy_code": "else value = null ; / / note that we add , not put . So that the first is kept , and rest are deduped , once in a context where case sensitivity is known ( the appropriate tree builder ) . attributes . put ( pendingAttributeName , value ) ; } } pendingAttributeName = null ;", "fixed_code": "else value = null ; / / note that we add , not put . So that the first is kept , and rest are deduped , once in a context where case sensitivity is known ( the appropriate tree builder ) . attributes . add ( pendingAttributeName , value ) ; } } pendingAttributeName = null ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_92"}
{"buggy_code": "import org . jsoup . SerializationException ; import org . jsoup . helper . Validate ; import org . jsoup . internal . StringUtil ; import java . io . IOException ; import java . util . AbstractMap ; * Adds a new attribute . Will produce duplicates if the key already exists . * @ see Attributes # put ( String , String ) private void add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ; vals [ size ] = value ; size + + ; } private static class Dataset extends AbstractMap < String , String > { private final Attributes attributes ;", "fixed_code": "import org . jsoup . SerializationException ; import org . jsoup . helper . Validate ; import org . jsoup . internal . StringUtil ; import org . jsoup . parser . ParseSettings ; import java . io . IOException ; import java . util . AbstractMap ; * Adds a new attribute . Will produce duplicates if the key already exists . * @ see Attributes # put ( String , String ) public Attributes add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ; vals [ size ] = value ; size + + ; return this ; } public boolean isEmpty ( ) { return size = = 0 ; } public int deduplicate ( ParseSettings settings ) { if ( isEmpty ( ) ) return 0 ; boolean preserve = settings . preserveAttributeCase ( ) ; int dupes = 0 ; OUTER : for ( int i = 0 ; i < keys . length ; i + + ) { for ( int j = i + 1 ; j < keys . length ; j + + ) { if ( keys [ j ] = = null ) continue OUTER ; / / keys . length doesn ' t shrink when removing , so re - test if ( ( preserve & & keys [ i ] . equals ( keys [ j ] ) ) | | ( ! preserve & & keys [ i ] . equalsIgnoreCase ( keys [ j ] ) ) ) { dupes + + ; remove ( j ) ; j - - ; } } } return dupes ; } private static class Dataset extends AbstractMap < String , String > { private final Attributes attributes ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Jsoup_92"}
{"buggy_code": "Element insert ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; / / todo : wonder if for xml parsing , should treat all tags as unknown ? because it ' s not html . Element el = new Element ( tag , baseUri , settings . normalizeAttributes ( startTag . attributes ) ) ; insertNode ( el ) ;", "fixed_code": "Element insert ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; / / todo : wonder if for xml parsing , should treat all tags as unknown ? because it ' s not html . startTag . attributes . deduplicate ( settings ) ; Element el = new Element ( tag , baseUri , settings . normalizeAttributes ( startTag . attributes ) ) ; insertNode ( el ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Jsoup_92"}
{"buggy_code": "Element insert ( final Token . StartTag startTag ) { / / cleanup duplicate attributes : / / handle empty unknown tags / / when the spec expects an empty tag , will directly hit insertEmpty , so won ' t generate this fake end tag .", "fixed_code": "Element insert ( final Token . StartTag startTag ) { / / cleanup duplicate attributes : if ( ! startTag . attributes . isEmpty ( ) ) { int dupes = startTag . attributes . deduplicate ( settings ) ; if ( dupes > 0 ) { error ( \" Duplicate attribute \" ) ; } } / / handle empty unknown tags / / when the spec expects an empty tag , will directly hit insertEmpty , so won ' t generate this fake end tag .", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Jsoup_92"}
{"buggy_code": "", "fixed_code": "public boolean preserveAttributeCase ( ) { return preserveAttributeCase ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "Jsoup_92"}
{"buggy_code": "if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; if ( \" select \" . equals ( el . normalName ( ) ) ) { Elements options = el . select ( \" option [ selected ] \" ) ;", "fixed_code": "if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; if ( type . equalsIgnoreCase ( \" button \" ) ) continue ; / / browsers don ' t submit these if ( \" select \" . equals ( el . normalName ( ) ) ) { Elements options = el . select ( \" option [ selected ] \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Jsoup_93"}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_1"}
{"buggy_code": "else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return node instanceof Element ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_1"}
{"buggy_code": "} public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . computeValue ( context ) , args [ 1 ] . computeValue ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; }", "fixed_code": "} public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . compute ( context ) , args [ 1 ] . compute ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_10"}
{"buggy_code": "import java . util . Collections ; import java . util . List ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; ns = Namespace . XML_NAMESPACE ; } else { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } else { this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "fixed_code": "import java . util . Collections ; import java . util . List ; import org . apache . commons . jxpath . ri . NamespaceResolver ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; ns = Namespace . XML_NAMESPACE ; } else { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; if ( nsr ! = null ) { String uri = nsr . getNamespaceURI ( prefix ) ; if ( uri ! = null ) { ns = Namespace . getNamespace ( prefix , uri ) ; } } if ( ns = = null ) { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } } else { this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_11"}
{"buggy_code": "import java . util . ArrayList ; import java . util . List ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } if ( testNS ! = null ) {", "fixed_code": "import java . util . ArrayList ; import java . util . List ; import org . apache . commons . jxpath . ri . NamespaceResolver ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; String testNS = null ; if ( testPrefix ! = null ) { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; testNS = nsr = = null ? null : nsr . getNamespaceURI ( testPrefix ) ; testNS = testNS = = null ? parent . getNamespaceURI ( testPrefix ) : testNS ; } if ( testNS ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_11"}
{"buggy_code": "| | testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) ; } return false ; }", "fixed_code": "| | testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) | | nodeNS = = null & & equalStrings ( testPrefix , getPrefix ( node ) ) ; } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_12"}
{"buggy_code": "import org . apache . commons . jxpath . JXPathException ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . Compiler ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . compiler . NodeNameTest ; import org . apache . commons . jxpath . ri . compiler . NodeTest ; private Map namespaces ; private String defaultNamespace ; private String id ; public static final String XML_NAMESPACE_URI = \" http : / / www . w3 . org / XML / 1998 / namespace \" ; public String getNamespaceURI ( String prefix ) { if ( prefix = = null | | prefix . equals ( \" \" ) ) { Element element = ( Element ) node ; String prefix = name . getPrefix ( ) ; if ( prefix ! = null ) { String ns = getNamespaceURI ( prefix ) ; if ( ns = = null ) { throw new JXPathException ( \" Unknown namespace prefix : \" + prefix ) ;", "fixed_code": "import org . apache . commons . jxpath . JXPathException ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . Compiler ; import org . apache . commons . jxpath . ri . NamespaceResolver ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . compiler . NodeNameTest ; import org . apache . commons . jxpath . ri . compiler . NodeTest ; private Map namespaces ; private String defaultNamespace ; private String id ; private NamespaceResolver localNamespaceResolver ; public static final String XML_NAMESPACE_URI = \" http : / / www . w3 . org / XML / 1998 / namespace \" ; public synchronized NamespaceResolver getNamespaceResolver ( ) { if ( localNamespaceResolver = = null ) { localNamespaceResolver = new NamespaceResolver ( super . getNamespaceResolver ( ) ) ; localNamespaceResolver . setNamespaceContextPointer ( this ) ; } return localNamespaceResolver ; } public String getNamespaceURI ( String prefix ) { if ( prefix = = null | | prefix . equals ( \" \" ) ) { Element element = ( Element ) node ; String prefix = name . getPrefix ( ) ; if ( prefix ! = null ) { String ns = null ; NamespaceResolver nsr = getNamespaceResolver ( ) ; if ( nsr ! = null ) { ns = nsr . getNamespaceURI ( prefix ) ; } if ( ns = = null ) { throw new JXPathException ( \" Unknown namespace prefix : \" + prefix ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_13"}
{"buggy_code": "* @ return prefix if found * @ since JXPath 1 . 3 public synchronized String getNamespaceURI ( String prefix ) { String uri = ( String ) namespaceMap . get ( prefix ) ; if ( uri = = null & & pointer ! = null ) { uri = pointer . getNamespaceURI ( prefix ) ; } if ( uri = = null & & parent ! = null ) { return parent . getNamespaceURI ( prefix ) ; } return uri ; } public synchronized String getPrefix ( String namespaceURI ) { if ( reverseMap = = null ) { reverseMap = new HashMap ( ) ; NodeIterator ni = pointer . namespaceIterator ( ) ; if ( ni ! = null ) { for ( int position = 1 ; ni . setPosition ( position ) ; position + + ) { NodePointer nsPointer = ni . getNodePointer ( ) ; String uri = nsPointer . getNamespaceURI ( ) ; String prefix = nsPointer . getName ( ) . getName ( ) ; if ( ! \" \" . equals ( prefix ) ) { reverseMap . put ( uri , prefix ) ; } } } Iterator it = namespaceMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; } } String prefix = ( String ) reverseMap . get ( namespaceURI ) ; if ( prefix = = null & & parent ! = null ) { return parent . getPrefix ( namespaceURI ) ; } return prefix ; }", "fixed_code": "* @ return prefix if found * @ since JXPath 1 . 3 protected static String getPrefix ( NodePointer pointer , String namespaceURI ) { NodePointer currentPointer = pointer ; while ( currentPointer ! = null ) { NodeIterator ni = currentPointer . namespaceIterator ( ) ; for ( int position = 1 ; ni ! = null & & ni . setPosition ( position ) ; position + + ) { NodePointer nsPointer = ni . getNodePointer ( ) ; String uri = nsPointer . getNamespaceURI ( ) ; if ( uri . equals ( namespaceURI ) ) { String prefix = nsPointer . getName ( ) . getName ( ) ; if ( ! \" \" . equals ( prefix ) ) { return prefix ; } } } currentPointer = pointer . getParent ( ) ; } return null ; } public synchronized String getNamespaceURI ( String prefix ) { String uri = getExternallyRegisteredNamespaceURI ( prefix ) ; return uri = = null & & pointer ! = null ? pointer . getNamespaceURI ( prefix ) : uri ; } protected synchronized String getExternallyRegisteredNamespaceURI ( String prefix ) { String uri = ( String ) namespaceMap . get ( prefix ) ; return uri = = null & & parent ! = null ? parent . getExternallyRegisteredNamespaceURI ( prefix ) : uri ; } public synchronized String getPrefix ( String namespaceURI ) { String prefix = getExternallyRegisteredPrefix ( namespaceURI ) ; return prefix = = null & & pointer ! = null ? getPrefix ( pointer , namespaceURI ) : prefix ; } protected synchronized String getExternallyRegisteredPrefix ( String namespaceURI ) { if ( reverseMap = = null ) { reverseMap = new HashMap ( ) ; Iterator it = namespaceMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; } } String prefix = ( String ) reverseMap . get ( namespaceURI ) ; return prefix = = null & & parent ! = null ? parent . getExternallyRegisteredPrefix ( namespaceURI ) : prefix ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_13"}
{"buggy_code": "protected Object functionFloor ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . floor ( v ) ) ; } protected Object functionCeiling ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . ceil ( v ) ) ; } protected Object functionRound ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . round ( v ) ) ; }", "fixed_code": "protected Object functionFloor ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . floor ( v ) ) ; } protected Object functionCeiling ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . ceil ( v ) ) ; } protected Object functionRound ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . round ( v ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_14"}
{"buggy_code": "package org . apache . commons . jxpath . ri . axes ; import java . util . ArrayList ; import org . apache . commons . jxpath . BasicNodeSet ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; while ( ctx . nextNode ( ) ) { NodePointer ptr = ctx . getCurrentNodePointer ( ) ; if ( ! pointers . contains ( ptr ) ) { nodeSet . add ( ptr ) ; pointers . add ( ptr ) ; } } } } } return super . setPosition ( position ) ; } } \\ No newline at end of file", "fixed_code": "package org . apache . commons . jxpath . ri . axes ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . commons . jxpath . BasicNodeSet ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; while ( ctx . nextNode ( ) ) { NodePointer ptr = ctx . getCurrentNodePointer ( ) ; if ( ! pointers . contains ( ptr ) ) { pointers . add ( ptr ) ; } } } } sortPointers ( pointers ) ;  for ( Iterator it = pointers . iterator ( ) ; it . hasNext ( ) ; ) { nodeSet . add ( ( Pointer ) it . next ( ) ) ; } } return super . setPosition ( position ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_15"}
{"buggy_code": "if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_16"}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_16"}
{"buggy_code": "String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; if ( ns ! = null ) { Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "fixed_code": "String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( ns = = Namespace . NO_NAMESPACE | | attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_17"}
{"buggy_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( equalStrings ( testPrefix , nodePrefix ) ) { return true ; } String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } String nodeNS = null ; if ( nodePrefix ! = null ) { nodeNS = parent . getNamespaceURI ( nodePrefix ) ; } return equalStrings ( testNS , nodeNS ) ; } return false ; } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "fixed_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( testPrefix = = null | | equalStrings ( testPrefix , nodePrefix ) ) { return true ; } if ( nodePrefix = = null ) { return false ; } return equalStrings ( parent . getNamespaceURI ( testPrefix ) , parent . getNamespaceURI ( nodePrefix ) ) ; } return false ; } this . position = position ; return position > = 1 & & position < = attributes . size ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_17"}
{"buggy_code": "package org . apache . commons . jxpath . ri . axes ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . compiler . NodeNameTest ; import org . apache . commons . jxpath . ri . compiler . NodeTest ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; * @ version $ Revision $ $ Date $ public class AttributeContext extends EvalContext { private NodeTest nodeTest ; private boolean setStarted = false ; super . setPosition ( getCurrentPosition ( ) + 1 ) ; if ( ! setStarted ) { setStarted = true ; if ( ! ( nodeTest instanceof NodeNameTest ) ) { return false ; } QName name = ( ( NodeNameTest ) nodeTest ) . getNodeName ( ) ; iterator = parentContext . getCurrentNodePointer ( ) . attributeIterator ( name ) ; } if ( iterator = = null ) { return false ; currentNodePointer = iterator . getNodePointer ( ) ; return true ; } } \\ No newline at end of file", "fixed_code": "package org . apache . commons . jxpath . ri . axes ; import org . apache . commons . jxpath . ri . Compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . QName ; import org . apache . commons . jxpath . ri . compiler . NodeNameTest ; import org . apache . commons . jxpath . ri . compiler . NodeTest ; import org . apache . commons . jxpath . ri . compiler . NodeTypeTest ; import org . apache . commons . jxpath . ri . model . NodeIterator ; import org . apache . commons . jxpath . ri . model . NodePointer ; * @ version $ Revision $ $ Date $ public class AttributeContext extends EvalContext { private static final NodeNameTest WILDCARD_TEST = new NodeNameTest ( new QName ( null , \" * \" ) ) ; private NodeTest nodeTest ; private boolean setStarted = false ; super . setPosition ( getCurrentPosition ( ) + 1 ) ; if ( ! setStarted ) { setStarted = true ; NodeNameTest nodeNameTest = null ; if ( nodeTest instanceof NodeTypeTest ) { if ( ( ( NodeTypeTest ) nodeTest ) . getNodeType ( ) = = Compiler . NODE_TYPE_NODE ) { nodeNameTest = WILDCARD_TEST ; } } else if ( nodeTest instanceof NodeNameTest ) { nodeNameTest = ( NodeNameTest ) nodeTest ; } if ( nodeNameTest = = null ) { return false ; } iterator = parentContext . getCurrentNodePointer ( ) . attributeIterator ( nodeNameTest . getNodeName ( ) ) ; } if ( iterator = = null ) { return false ; currentNodePointer = iterator . getNodePointer ( ) ; return true ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_18"}
{"buggy_code": "int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { String nm = n . getNodeName ( ) ; if ( nm . equals ( node . getNodeName ( ) ) ) { count + + ; } } n = n . getPreviousSibling ( ) ; } return count ; }", "fixed_code": "int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE & & matchesQName ( n ) ) { count + + ; } n = n . getPreviousSibling ( ) ; } return count ; } private boolean matchesQName ( Node n ) { if ( getNamespaceURI ( ) ! = null ) { return equalStrings ( getNamespaceURI ( n ) , getNamespaceURI ( ) ) & & equalStrings ( node . getLocalName ( ) , n . getLocalName ( ) ) ; } return equalStrings ( node . getNodeName ( ) , n . getNodeName ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_19"}
{"buggy_code": "String name = ( ( Element ) node ) . getQualifiedName ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Object child = children . get ( i ) ; if ( ( child instanceof Element ) & & ( ( Element ) child ) . getQualifiedName ( ) . equals ( name ) ) { count + + ; } if ( child = = node ) { return 1 ; }", "fixed_code": "String name = ( ( Element ) node ) . getQualifiedName ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Object child = children . get ( i ) ; if ( child instanceof Element & & matchesQName ( ( ( Element ) child ) ) ) { count + + ; } if ( child = = node ) { return 1 ; } private boolean matchesQName ( Element element ) { if ( getNamespaceURI ( ) ! = null ) { String ns = getNamespaceURI ( element ) ; if ( ns = = null | | ! ns . equals ( getNamespaceURI ( ) ) ) { return false ; } } return element . getName ( ) . equals ( ( ( Element ) node ) . getName ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_19"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; if ( result instanceof EvalContext ) { return new ValueIterator ( ( EvalContext ) result ) ; } return ValueUtils . iterate ( result ) ; } if ( result instanceof EvalContext ) { return ( EvalContext ) result ; } return new PointerIterator ( ValueUtils . iterate ( result ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; throw new UnsupportedOperationException ( ) ; } } } \\ No newline at end of file", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . NodeSet ; import org . apache . commons . jxpath . Pointer ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . model . NodePointer ; if ( result instanceof EvalContext ) { return new ValueIterator ( ( EvalContext ) result ) ; } if ( result instanceof NodeSet ) { return new ValueIterator ( ( ( NodeSet ) result ) . getPointers ( ) . iterator ( ) ) ; } return ValueUtils . iterate ( result ) ; } if ( result instanceof EvalContext ) { return ( EvalContext ) result ; } if ( result instanceof NodeSet ) { return new PointerIterator ( ( ( NodeSet ) result ) . getPointers ( ) . iterator ( ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; } return new PointerIterator ( ValueUtils . iterate ( result ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; throw new UnsupportedOperationException ( ) ; } } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_2"}
{"buggy_code": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { * @ param value to look for * @ return whether a match was found", "fixed_code": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( left , ( Iterator ) right ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { * @ param value to look for * @ return whether a match was found private boolean containsMatch ( Object value , Iterator it ) { while ( it . hasNext ( ) ) { Object element = it . next ( ) ; if ( compute ( value , element ) ) { return true ; } } return false ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_20"}
{"buggy_code": "* @ return int length public int getLength ( ) { return ValueUtils . getLength ( getBaseValue ( ) ) ; }", "fixed_code": "* @ return int length public int getLength ( ) { Object baseValue = getBaseValue ( ) ; return baseValue = = null ? 1 : ValueUtils . getLength ( baseValue ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_21"}
{"buggy_code": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { return attr . getValue ( ) ; } } aNode = aNode . getParentNode ( ) ; } return null ; } return uri ; } public Object getValue ( ) {", "fixed_code": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { uri = attr . getValue ( ) ; break ; } } aNode = aNode . getParentNode ( ) ; } } return \" \" . equals ( uri ) ? null : uri ; } public Object getValue ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_22"}
{"buggy_code": "package org . apache . commons . jxpath . ri . model . beans ; import org . apache . commons . jxpath . JXPathContext ; import org . apache . commons . jxpath . JXPathInvalidAccessException ; import org . apache . commons . jxpath . ri . QName ; return newParent . createAttribute ( context , getName ( ) ) ; } else { / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return pointer ; } else { if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; } return string ; } } \\ No newline at end of file", "fixed_code": "package org . apache . commons . jxpath . ri . model . beans ; import org . apache . commons . jxpath . AbstractFactory ; import org . apache . commons . jxpath . JXPathAbstractFactoryException ; import org . apache . commons . jxpath . JXPathContext ; import org . apache . commons . jxpath . JXPathInvalidAccessException ; import org . apache . commons . jxpath . ri . QName ; return newParent . createAttribute ( context , getName ( ) ) ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return pointer ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; } return string ; }  private JXPathAbstractFactoryException createBadFactoryException ( AbstractFactory factory ) { return new JXPathAbstractFactoryException ( \" Factory \" + factory + \" reported success creating object for path : \" + asPath ( ) + \" but object was null . Terminating to avoid stack recursion . \" ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_3"}
{"buggy_code": "public Object getValue ( ) { if ( node instanceof Element ) { return ( ( Element ) node ) . getTextTrim ( ) ; } if ( node instanceof Comment ) { String text = ( ( Comment ) node ) . getText ( ) ; } return text ; } if ( node instanceof Text ) { return ( ( Text ) node ) . getTextTrim ( ) ; } if ( node instanceof CDATA ) { return ( ( CDATA ) node ) . getTextTrim ( ) ; } if ( node instanceof ProcessingInstruction ) { String text = ( ( ProcessingInstruction ) node ) . getData ( ) ; if ( text ! = null ) { text = text . trim ( ) ; } return text ; } return null ; } public void setValue ( Object value ) { } protected String getLanguage ( ) { Object n = node ; while ( n ! = null ) { if ( n instanceof Element ) { Element e = ( Element ) n ; String attr = e . getAttributeValue ( \" lang \" , Namespace . XML_NAMESPACE ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } return factory ; } } \\ No newline at end of file", "fixed_code": "public Object getValue ( ) { if ( node instanceof Element ) { StringBuffer buf = new StringBuffer ( ) ; for ( NodeIterator children = childIterator ( null , false , null ) ; children . setPosition ( children . getPosition ( ) + 1 ) ; ) { NodePointer ptr = children . getNodePointer ( ) ; if ( ptr . getImmediateNode ( ) instanceof Element | | ptr . getImmediateNode ( ) instanceof Text ) { buf . append ( ptr . getValue ( ) ) ; } } return buf . toString ( ) ; } if ( node instanceof Comment ) { String text = ( ( Comment ) node ) . getText ( ) ; } return text ; } String result = null ; if ( node instanceof Text ) { result = ( ( Text ) node ) . getText ( ) ; } if ( node instanceof ProcessingInstruction ) { result = ( ( ProcessingInstruction ) node ) . getData ( ) ; } boolean trim = ! \" preserve \" . equals ( findEnclosingAttribute ( node , \" space \" , Namespace . XML_NAMESPACE ) ) ; return result ! = null & & trim ? result . trim ( ) : result ; } public void setValue ( Object value ) { } protected String getLanguage ( ) { return findEnclosingAttribute ( node , \" lang \" , Namespace . XML_NAMESPACE ) ; }  protected static String findEnclosingAttribute ( Object n , String attrName , Namespace ns ) { while ( n ! = null ) { if ( n instanceof Element ) { Element e = ( Element ) n ; String attr = e . getAttributeValue ( attrName , ns ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } return factory ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_4"}
{"buggy_code": ": current . toUpperCase ( ) . startsWith ( lang . toUpperCase ( ) ) ; } protected String getLanguage ( ) { Node n = node ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element e = ( Element ) n ; String attr = e . getAttribute ( \" xml : lang \" ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } return null ; }", "fixed_code": ": current . toUpperCase ( ) . startsWith ( lang . toUpperCase ( ) ) ; } protected static String findEnclosingAttribute ( Node n , String attrName ) { while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element e = ( Element ) n ; String attr = e . getAttribute ( attrName ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } return null ; } protected String getLanguage ( ) { return findEnclosingAttribute ( node , \" xml : lang \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_4"}
{"buggy_code": "} if ( depth1 = = 1 ) { throw new JXPathException ( \" Cannot compare pointers that do not belong to the same tree : ' \" + p1 + \" ' and ' \" + p2 + \" ' \" ) ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "fixed_code": "} if ( depth1 = = 1 ) { return 0 ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_5"}
{"buggy_code": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext | | l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext | | r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "fixed_code": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext ) { ( ( EvalContext ) l ) . reset ( ) ; }  if ( l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext ) { ( ( EvalContext ) r ) . reset ( ) ; }  if ( r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_6"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_7"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_7"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JxPath_7"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "JxPath_7"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ;  import org . apache . commons . jxpath . ri . EvalContext ; import org . apache . commons . jxpath . ri . InfoSetUtil ; import org . apache . commons . jxpath . ri . axes . InitialContext ; import org . apache . commons . jxpath . ri . axes . SelfContext ; ", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "JxPath_7"}
{"buggy_code": "return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; double rd = InfoSetUtil . doubleValue ( right ) ; return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; }", "fixed_code": "return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( right ) ; if ( Double . isNaN ( rd ) ) { return false ; } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_8"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "JxPath_9"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public abstract class CoreOperationCompare extends CoreOperation { public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { super ( new Expression [ ] { arg1 , arg2 } ) ; } protected int getPrecedence ( ) { } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer & & r instanceof Pointer ) { if ( l . equals ( r ) ) { return true ; } } if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } if ( l = = r ) { return true ; } if ( l instanceof Boolean | | r instanceof Boolean ) { return ( InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ) ; } / / if either side is NaN , no comparison returns true : if ( l instanceof Number | | r instanceof Number ) { return ( InfoSetUtil . doubleValue ( l ) = = InfoSetUtil . doubleValue ( r ) ) ; } if ( l instanceof String | | r instanceof String ) { return ( InfoSetUtil . stringValue ( l ) . equals ( InfoSetUtil . stringValue ( r ) ) ) ; } return l ! = null & & l . equals ( r ) ; } }", "fixed_code": "* @ version $ Revision $ $ Date $ public abstract class CoreOperationCompare extends CoreOperation { private boolean invert ; public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { this ( arg1 , arg2 , false ) ; }  protected CoreOperationCompare ( Expression arg1 , Expression arg2 , boolean invert ) { super ( new Expression [ ] { arg1 , arg2 } ) ; this . invert = invert ; }  public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } protected int getPrecedence ( ) { } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } boolean result ; if ( l instanceof Boolean | | r instanceof Boolean ) { result = l = = r | | InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ; } else if ( l instanceof Number | | r instanceof Number ) { / / if either side is NaN , no comparison returns true : double ld = InfoSetUtil . doubleValue ( l ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( r ) ; if ( Double . isNaN ( rd ) ) { return false ; } result = ld = = rd ; } else { if ( l instanceof String | | r instanceof String ) { l = InfoSetUtil . stringValue ( l ) ; r = InfoSetUtil . stringValue ( r ) ; } result = l = = r | | l ! = null & & l . equals ( r ) ; } return result ^ invert ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "JxPath_9"}
{"buggy_code": "package org . apache . commons . jxpath . ri . compiler ; import org . apache . commons . jxpath . ri . EvalContext ;", "fixed_code": "package org . apache . commons . jxpath . ri . compiler ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "JxPath_9"}
{"buggy_code": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "fixed_code": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "fixed_code": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_1"}
{"buggy_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "fixed_code": "start = ' ' ; } } } else { if ( end < = start ) { throw new IllegalArgumentException ( \" Parameter end ( \" + end + \" ) must be greater than start ( \" + start + \" ) \" ) ; } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_11"}
{"buggy_code": "start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "fixed_code": "start = ' ' ; } } } else { if ( end < = start ) { throw new IllegalArgumentException ( \" Parameter end ( \" + end + \" ) must be greater than start ( \" + start + \" ) \" ) ; } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_11"}
{"buggy_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "fixed_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars ! = null & & chars . length = = 0 ) { throw new IllegalArgumentException ( \" The chars array must not be empty \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "fixed_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars ! = null & & chars . length = = 0 ) { throw new IllegalArgumentException ( \" The chars array must not be empty \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_12"}
{"buggy_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private ClassLoader classLoader ;", "fixed_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private static final Map < String , Class < ? > > primitiveTypes = new HashMap < String , Class < ? > > ( ) ; private ClassLoader classLoader ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private ClassLoader classLoader ;", "fixed_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private static final Map < String , Class < ? > > primitiveTypes = new HashMap < String , Class < ? > > ( ) ; private ClassLoader classLoader ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_13"}
{"buggy_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; }", "fixed_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_14"}
{"buggy_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; }", "fixed_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_14"}
{"buggy_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; }", "fixed_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_15"}
{"buggy_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; }", "fixed_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_15"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "fixed_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "fixed_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_16"}
{"buggy_code": "return ; } int pos = 0 ; int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; } else { / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { if ( pos < len - 2 ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } }", "fixed_code": "return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_17"}
{"buggy_code": "return ; } int pos = 0 ; int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; } else { / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { if ( pos < len - 2 ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } }", "fixed_code": "return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_17"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_18"}
{"buggy_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "fixed_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_19"}
{"buggy_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "fixed_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_19"}
{"buggy_code": "if ( str = = null ) { return null ; } final int len = str . length ( ) ; if ( len < 2 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "if ( str = = null ) { return null ; } if ( str . contains ( \" # \" ) ) { / / LANG - 879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final int len = str . length ( ) ; if ( len < 2 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_2"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_20"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_21"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw new ArithmeticException ( \" overflow : gcd is 2 ^ 31 \" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw new ArithmeticException ( \" overflow : gcd is 2 ^ 31 \" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false", "fixed_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final int HASH_SEED = 31 ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false @ Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ObjectUtils . notEqual ( getClass ( ) , obj . getClass ( ) ) ) { return false ; } ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ; if ( ObjectUtils . notEqual ( toPattern , rhs . toPattern ) ) { return false ; } if ( ObjectUtils . notEqual ( registry , rhs . registry ) ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( registry ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( toPattern ) ; return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_23"}
{"buggy_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false", "fixed_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final int HASH_SEED = 31 ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false @ Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ObjectUtils . notEqual ( getClass ( ) , obj . getClass ( ) ) ) { return false ; } ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ; if ( ObjectUtils . notEqual ( toPattern , rhs . toPattern ) ) { return false ; } if ( ObjectUtils . notEqual ( registry , rhs . registry ) ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( registry ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( toPattern ) ; return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_23"}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp & & ! hasDecPoint ; } / / last character is illegal return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp & & ! hasDecPoint ; } / / last character is illegal return false ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_24"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_26"}
{"buggy_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos | | expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos | | expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "return 0 ; } out . write ( entityValue ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "fixed_code": "return 0 ; } if ( entityValue > 0xFFFF ) { char [ ] chrs = Character . toChars ( entityValue ) ; out . write ( chrs [ 0 ] ) ; out . write ( chrs [ 1 ] ) ; } else { out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_28"}
{"buggy_code": "return 0 ; } out . write ( entityValue ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "fixed_code": "return 0 ; } if ( entityValue > 0xFFFF ) { char [ ] chrs = Character . toChars ( entityValue ) ; out . write ( chrs [ 0 ] ) ; out . write ( chrs [ 1 ] ) ; } else { out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_28"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_29"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_29"}
{"buggy_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "fixed_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { if ( numDecimals < = 7 ) { / / If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { if ( numDecimals < = 16 ) { / / If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_3"}
{"buggy_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "fixed_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { if ( numDecimals < = 7 ) { / / If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { if ( numDecimals < = 16 ) { / / If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_3"}
{"buggy_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character return i ; } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / missing low surrogate , fine , like String . indexOf ( String ) if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { continue outer ; } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; if ( searchChars . indexOf ( ch ) < 0 ) { return i ; } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / missing low surrogate , fine , like String . indexOf ( String ) / / ch is in the Basic Multilingual Plane return false ; } } }", "fixed_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return i ; } } else { return i ; } } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return true ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { continue outer ; } } else { continue outer ; } } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; boolean chFound = searchChars . indexOf ( ch ) > = 0 ; if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { char ch2 = str . charAt ( i + 1 ) ; if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return false ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return false ; } } else { / / ch is in the Basic Multilingual Plane return false ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_30"}
{"buggy_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character return i ; } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / missing low surrogate , fine , like String . indexOf ( String ) if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { continue outer ; } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; if ( searchChars . indexOf ( ch ) < 0 ) { return i ; } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / missing low surrogate , fine , like String . indexOf ( String ) / / ch is in the Basic Multilingual Plane return false ; } } }", "fixed_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return i ; } } else { return i ; } } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return true ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { continue outer ; } } else { continue outer ; } } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; boolean chFound = searchChars . indexOf ( ch ) > = 0 ; if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { char ch2 = str . charAt ( i + 1 ) ; if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return false ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return false ; } } else { / / ch is in the Basic Multilingual Plane return false ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_30"}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character / / ch is in the Basic Multilingual Plane return true ; } } }", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLastIndex = csLength - 1 ; int searchLastIndex = searchLength - 1 ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { / / ch is in the Basic Multilingual Plane return true ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_31"}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character / / ch is in the Basic Multilingual Plane return true ; } } }", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLastIndex = csLength - 1 ; int searchLastIndex = searchLength - 1 ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { / / ch is in the Basic Multilingual Plane return true ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_31"}
{"buggy_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) { @ Override protected Set < IDKey > initialValue ( ) { return new HashSet < IDKey > ( ) ; } } ; static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; }", "fixed_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_32"}
{"buggy_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) { @ Override protected Set < IDKey > initialValue ( ) { return new HashSet < IDKey > ( ) ; } } ; static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; }", "fixed_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_32"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m . containsKey ( value ) ; }", "fixed_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m ! = null & & m . containsKey ( value ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_34"}
{"buggy_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m . containsKey ( value ) ; }", "fixed_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m ! = null & & m . containsKey ( value ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_34"}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Arguments cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Array and element cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Arguments cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Array and element cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_35"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "fixed_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_36"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "fixed_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_36"}
{"buggy_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; / / Check if problem is incompatible types return joinedArray ; }", "fixed_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; try { System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; } catch ( ArrayStoreException ase ) { / / Check if problem is incompatible types final Class < ? > type2 = array2 . getClass ( ) . getComponentType ( ) ; if ( ! type1 . isAssignableFrom ( type2 ) ) { throw new IllegalArgumentException ( \" Cannot store \" + type2 . getName ( ) + \" in an array of \" + type1 . getName ( ) ) ; } throw ase ; / / No , so rethrow original } return joinedArray ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_37"}
{"buggy_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; / / Check if problem is incompatible types return joinedArray ; }", "fixed_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; try { System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; } catch ( ArrayStoreException ase ) { / / Check if problem is incompatible types final Class < ? > type2 = array2 . getClass ( ) . getComponentType ( ) ; if ( ! type1 . isAssignableFrom ( type2 ) ) { throw new IllegalArgumentException ( \" Cannot store \" + type2 . getName ( ) + \" in an array of \" + type1 . getName ( ) ) ; } throw ase ; / / No , so rethrow original } return joinedArray ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_37"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_38"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < CharSequence , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "fixed_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < String , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_4"}
{"buggy_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < CharSequence , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "fixed_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < String , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_4"}
{"buggy_code": "if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "fixed_code": "if ( str = = null | | searchStr = = null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = 0 ; i < = max ; i + + ) { if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { return true ; } } return false ; } / / IndexOfAny chars", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_40"}
{"buggy_code": "if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "fixed_code": "if ( str = = null | | searchStr = = null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = 0 ; i < = max ; i + + ) { if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { return true ; } } return false ; } / / IndexOfAny chars", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_40"}
{"buggy_code": "return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } / / Strip array encoding / / Strip Object type encoding int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "fixed_code": "return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / Strip array encoding while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } / / Strip array encoding / / Strip Object type encoding int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "fixed_code": "return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / Strip array encoding while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_41"}
{"buggy_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { char c = str . charAt ( i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "fixed_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { int c = Character . codePointAt ( str , i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > = 0x010000 & & i < len - 1 ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ; i + + ; } else if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_42"}
{"buggy_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { char c = str . charAt ( i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "fixed_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { int c = Character . codePointAt ( str , i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > = 0x010000 & & i < len - 1 ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ; i + + ; } else if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_42"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_43"}
{"buggy_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "fixed_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . length ( ) = = 1 & & ! Character . isDigit ( val . charAt ( 0 ) ) ) { throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "fixed_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . length ( ) = = 1 & & ! Character . isDigit ( val . charAt ( 0 ) ) ) { throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "fixed_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string if ( lower > str . length ( ) ) { lower = str . length ( ) ; } / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "fixed_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string if ( lower > str . length ( ) ) { lower = str . length ( ) ; } / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_45"}
{"buggy_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "fixed_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "fixed_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_46"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_47"}
{"buggy_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "fixed_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal ) { isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; } else { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_48"}
{"buggy_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "fixed_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal ) { isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; } else { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_48"}
{"buggy_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "fixed_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { if ( numerator = = 0 ) { return equals ( ZERO ) ? this : ZERO ; } int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_49"}
{"buggy_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "fixed_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { if ( numerator = = 0 ) { return equals ( ZERO ) ? this : ZERO ; } int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_49"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; if ( ch0 = = ' _ ' ) { if ( len < 3 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ! Character . isUpperCase ( ch1 ) | | ! Character . isUpperCase ( ch2 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( len = = 3 ) { return new Locale ( \" \" , str . substring ( 1 , 3 ) ) ; } if ( len < 5 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( str . charAt ( 3 ) ! = ' _ ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( \" \" , str . substring ( 1 , 3 ) , str . substring ( 4 ) ) ; } else { final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_5"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; if ( ch0 = = ' _ ' ) { if ( len < 3 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ! Character . isUpperCase ( ch1 ) | | ! Character . isUpperCase ( ch2 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( len = = 3 ) { return new Locale ( \" \" , str . substring ( 1 , 3 ) ) ; } if ( len < 5 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( str . charAt ( 3 ) ! = ' _ ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( \" \" , str . substring ( 1 , 3 ) , str . substring ( 4 ) ) ; } else { final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_5"}
{"buggy_code": "key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "fixed_code": "key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "fixed_code": "key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_50"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; default : out . write ( ch ) ; break ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_52"}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; default : out . write ( ch ) ; break ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_52"}
{"buggy_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes", "fixed_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; } if ( field = = Calendar . SECOND ) { done = true ; } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field = = Calendar . MINUTE ) { done = true ; } / / truncate minutes", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes", "fixed_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; } if ( field = = Calendar . SECOND ) { done = true ; } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field = = Calendar . MINUTE ) { done = true ; } / / truncate minutes", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_53"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; if ( ch3 = = ' _ ' ) { return new Locale ( str . substring ( 0 , 2 ) , \" \" , str . substring ( 4 ) ) ; } char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_54"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; if ( ch3 = = ' _ ' ) { return new Locale ( str . substring ( 0 , 2 ) , \" \" , str . substring ( 4 ) ) ; } char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_54"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "private Rule [ ] mRules ; private int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "private transient Rule [ ] mRules ; private transient int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_56"}
{"buggy_code": "private Rule [ ] mRules ; private int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "private transient Rule [ ] mRules ; private transient int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_56"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_6"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < this . size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < this . size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_60"}
{"buggy_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "fixed_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = size - strLen + 1 ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "fixed_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = size - strLen + 1 ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_61"}
{"buggy_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } } catch ( NumberFormatException e ) { } } } else { / / escaped value content is an entity name", "fixed_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; break ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException e ) { entityValue = - 1 ; } } } else { / / escaped value content is an entity name", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_62"}
{"buggy_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } } catch ( NumberFormatException e ) { } } } else { / / escaped value content is an entity name", "fixed_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; break ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException e ) { entityValue = - 1 ; } } } else { / / escaped value content is an entity name", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_62"}
{"buggy_code": "days - = 1 ; } while ( days < 0 ) { days + = 31 ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } milliseconds - = reduceAndCorrect ( start , end , Calendar . MILLISECOND , milliseconds ) ; seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static int reduceAndCorrect ( Calendar start , Calendar end , int field , int difference ) { end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; } } static final Object y = \" y \" ; static final Object M = \" M \" ;", "fixed_code": "days - = 1 ; } while ( days < 0 ) { end . add ( Calendar . MONTH , - 1 ) ; days + = end . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; end . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static final Object y = \" y \" ; static final Object M = \" M \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "days - = 1 ; } while ( days < 0 ) { days + = 31 ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } milliseconds - = reduceAndCorrect ( start , end , Calendar . MILLISECOND , milliseconds ) ; seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static int reduceAndCorrect ( Calendar start , Calendar end , int field , int difference ) { end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; } } static final Object y = \" y \" ; static final Object M = \" M \" ;", "fixed_code": "days - = 1 ; } while ( days < 0 ) { end . add ( Calendar . MONTH , - 1 ) ; days + = end . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; end . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static final Object y = \" y \" ; static final Object M = \" M \" ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value / / ignore - should never happen / / ignore - should never happen / / ignore - should never happen", "fixed_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { if ( other = = this ) { return 0 ; } if ( other . getClass ( ) ! = this . getClass ( ) ) { if ( other . getClass ( ) . getName ( ) . equals ( this . getClass ( ) . getName ( ) ) ) { return iValue - getValueInOtherClassLoader ( other ) ; } throw new ClassCastException ( \" Different enum class ' \" + ClassUtils . getShortClassName ( other . getClass ( ) ) + \" ' \" ) ; } return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value private int getValueInOtherClassLoader ( Object other ) { try { Method mth = other . getClass ( ) . getMethod ( \" getValue \" , null ) ; Integer value = ( Integer ) mth . invoke ( other , null ) ; return value . intValue ( ) ; } catch ( NoSuchMethodException e ) { / / ignore - should never happen } catch ( IllegalAccessException e ) { / / ignore - should never happen } catch ( InvocationTargetException e ) { / / ignore - should never happen } throw new IllegalStateException ( \" This should not happen \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_64"}
{"buggy_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value / / ignore - should never happen / / ignore - should never happen / / ignore - should never happen", "fixed_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { if ( other = = this ) { return 0 ; } if ( other . getClass ( ) ! = this . getClass ( ) ) { if ( other . getClass ( ) . getName ( ) . equals ( this . getClass ( ) . getName ( ) ) ) { return iValue - getValueInOtherClassLoader ( other ) ; } throw new ClassCastException ( \" Different enum class ' \" + ClassUtils . getShortClassName ( other . getClass ( ) ) + \" ' \" ) ; } return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value private int getValueInOtherClassLoader ( Object other ) { try { Method mth = other . getClass ( ) . getMethod ( \" getValue \" , null ) ; Integer value = ( Integer ) mth . invoke ( other , null ) ; return value . intValue ( ) ; } catch ( NoSuchMethodException e ) { / / ignore - should never happen } catch ( IllegalAccessException e ) { / / ignore - should never happen } catch ( InvocationTargetException e ) { / / ignore - should never happen } throw new IllegalStateException ( \" This should not happen \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_64"}
{"buggy_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . / / truncate milliseconds / / truncate seconds / / truncate minutes / / reset time / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "fixed_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } if ( field = = Calendar . MILLISECOND ) { return ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . Date date = val . getTime ( ) ; long time = date . getTime ( ) ; boolean done = false ; / / truncate milliseconds int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done & & ( ! round | | minutes < 30 ) ) { time = time - ( minutes * 60000L ) ; } / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field if ( offset ! = 0 ) { val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_65"}
{"buggy_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . / / truncate milliseconds / / truncate seconds / / truncate minutes / / reset time / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "fixed_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } if ( field = = Calendar . MILLISECOND ) { return ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . Date date = val . getTime ( ) ; long time = date . getTime ( ) ; boolean done = false ; / / truncate milliseconds int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done & & ( ! round | | minutes < 30 ) ) { time = time - ( minutes * 60000L ) ; } / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field if ( offset ! = 0 ) { val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_65"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final TimeZone zone ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; zone = timeZone ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "fixed_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { TimeZone zone = calendar . getTimeZone ( ) ; if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_8"}
{"buggy_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final TimeZone zone ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; zone = timeZone ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "fixed_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { TimeZone zone = calendar . getTimeZone ( ) ; if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_8"}
{"buggy_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "fixed_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( patternMatcher . regionStart ( ) ! = patternMatcher . regionEnd ( ) ) { throw new IllegalArgumentException ( \" Failed to parse \\ \" \" + pattern + \" \\ \" ; gave up at index \" + patternMatcher . regionStart ( ) ) ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Lang_9"}
{"buggy_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "fixed_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( patternMatcher . regionStart ( ) ! = patternMatcher . regionEnd ( ) ) { throw new IllegalArgumentException ( \" Failed to parse \\ \" \" + pattern + \" \\ \" ; gave up at index \" + patternMatcher . regionStart ( ) ) ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_9"}
{"buggy_code": "if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_1"}
{"buggy_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_1"}
{"buggy_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly }", "fixed_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_10"}
{"buggy_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly }", "fixed_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_10"}
{"buggy_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getAllParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getAllParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "fixed_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getUnboundParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getUnboundParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_100"}
{"buggy_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getAllParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getAllParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "fixed_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getUnboundParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getUnboundParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_100"}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( startIndex > = source . length ( ) ) | | ( endIndex > source . length ( ) ) | | source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_101"}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( startIndex > = source . length ( ) ) | | ( endIndex > source . length ( ) ) | | source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_101"}
{"buggy_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } return sumSq ; }", "fixed_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumExpected = 0d ; double sumObserved = 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { sumExpected + = expected [ i ] ; sumObserved + = observed [ i ] ; } double ratio = 1 . 0d ; boolean rescale = false ; if ( Math . abs ( sumExpected - sumObserved ) > 10E - 6 ) { ratio = sumObserved / sumExpected ; rescale = true ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { if ( rescale ) { dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; sumSq + = dev * dev / ( ratio * expected [ i ] ) ; } else { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } } return sumSq ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_102"}
{"buggy_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } return sumSq ; }", "fixed_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumExpected = 0d ; double sumObserved = 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { sumExpected + = expected [ i ] ; sumObserved + = observed [ i ] ; } double ratio = 1 . 0d ; boolean rescale = false ; if ( Math . abs ( sumExpected - sumObserved ) > 10E - 6 ) { ratio = sumObserved / sumExpected ; rescale = true ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { if ( rescale ) { dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; sumSq + = dev * dev / ( ratio * expected [ i ] ) ; } else { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } } return sumSq ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_102"}
{"buggy_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; }", "fixed_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 . 0d ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 . 0d ; } else { throw ex ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; }", "fixed_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 . 0d ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 . 0d ; } else { throw ex ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_103"}
{"buggy_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 9 ; private static double [ ] lanczos =", "fixed_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 15 ; private static double [ ] lanczos =", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 9 ; private static double [ ] lanczos =", "fixed_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 15 ; private static double [ ] lanczos =", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_104"}
{"buggy_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; }", "fixed_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; }", "fixed_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_105"}
{"buggy_code": "return null ; } / / minus signs should be leading , invalid expression / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } / / minus signs must be leading , invalid int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "fixed_code": "return null ; } if ( num . intValue ( ) < 0 ) { / / minus signs should be leading , invalid expression pos . setIndex ( initialIndex ) ; return null ; } / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } if ( den . intValue ( ) < 0 ) { / / minus signs must be leading , invalid pos . setIndex ( initialIndex ) ; return null ; } int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_106"}
{"buggy_code": "return null ; } / / minus signs should be leading , invalid expression / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } / / minus signs must be leading , invalid int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "fixed_code": "return null ; } if ( num . intValue ( ) < 0 ) { / / minus signs should be leading , invalid expression pos . setIndex ( initialIndex ) ; return null ; } / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } if ( den . intValue ( ) < 0 ) { / / minus signs must be leading , invalid pos . setIndex ( initialIndex ) ; return null ; } int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_106"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_11"}
{"buggy_code": "package org . apache . commons . math3 . random ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator { private double nextGaussian ;", "fixed_code": "package org . apache . commons . math3 . random ; import java . io . Serializable ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator , Serializable { private static final long serialVersionUID = 20130104L ; private double nextGaussian ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_12"}
{"buggy_code": "package org . apache . commons . math3 . random ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator { private double nextGaussian ;", "fixed_code": "package org . apache . commons . math3 . random ; import java . io . Serializable ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator , Serializable { private static final long serialVersionUID = 20130104L ; private double nextGaussian ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_12"}
{"buggy_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "fixed_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_13"}
{"buggy_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "fixed_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_13"}
{"buggy_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; for ( int i = 0 ; i < dim ; i + + ) { weightMatrix . setEntry ( i , i , weight [ i ] ) ; } }", "fixed_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } } public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = new DiagonalMatrix ( weight ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_14"}
{"buggy_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; for ( int i = 0 ; i < dim ; i + + ) { weightMatrix . setEntry ( i , i , weight [ i ] ) ; } }", "fixed_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = new DiagonalMatrix ( weight ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_14"}
{"buggy_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double TWO_POWER_53 = 2 * TWO_POWER_52 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double TWO_POWER_53 = 2 * TWO_POWER_52 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_15"}
{"buggy_code": "public class FastMath { public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( - x ) ; } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) {", "fixed_code": "public class FastMath { private static final double LOG_MAX_VALUE = StrictMath . log ( Double . MAX_VALUE ) ; public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_16"}
{"buggy_code": "public class FastMath { public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( - x ) ; } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) {", "fixed_code": "public class FastMath { private static final double LOG_MAX_VALUE = StrictMath . log ( Double . MAX_VALUE ) ; public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_16"}
{"buggy_code": "* @ return product of this and x public Dfp multiply ( final int x ) { return multiplyFast ( x ) ; }", "fixed_code": "* @ return product of this and x public Dfp multiply ( final int x ) { if ( x > = 0 & & x < RADIX ) { return multiplyFast ( x ) ; } else { return multiply ( newInstance ( x ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_17"}
{"buggy_code": "* @ return product of this and x public Dfp multiply ( final int x ) { return multiplyFast ( x ) ; }", "fixed_code": "* @ return product of this and x public Dfp multiply ( final int x ) { if ( x > = 0 & & x < RADIX ) { return multiplyFast ( x ) ; } else { return multiply ( newInstance ( x ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_17"}
{"buggy_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; } return true ; } for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < 0 ) { return false ; } if ( x [ i ] > 1 . 0 ) { return false ; } }", "fixed_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = x [ i ] / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; } return true ; } final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < bLoEnc [ i ] ) { return false ; } if ( x [ i ] > bHiEnc [ i ] ) { return false ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; } return true ; } for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < 0 ) { return false ; } if ( x [ i ] > 1 . 0 ) { return false ; } }", "fixed_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = x [ i ] / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; } return true ; } final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < bLoEnc [ i ] ) { return false ; } if ( x [ i ] > bHiEnc [ i ] ) { return false ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_18"}
{"buggy_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "fixed_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_19"}
{"buggy_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "fixed_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_19"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return decode ( x ) ; }", "fixed_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return boundaries ! = null & & isRepairMode ? decode ( repair ( x ) ) : decode ( x ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return decode ( x ) ; }", "fixed_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return boundaries ! = null & & isRepairMode ? decode ( repair ( x ) ) : decode ( x ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_20"}
{"buggy_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] swap = new int [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element swap [ r ] = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isi = index [ swap [ i ] ] ; if ( c [ ii ] [ ii ] > c [ isi ] [ isi ] ) { swap [ r ] = i ; } } / / swap elements if ( swap [ r ] ! = r ) { int tmp = index [ r ] ; index [ r ] = index [ swap [ r ] ] ; index [ swap [ r ] ] = tmp ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = e * e ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "fixed_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element int swapR = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isr = index [ swapR ] ; if ( c [ ii ] [ ii ] > c [ isr ] [ isr ] ) { swapR = i ; } } / / swap elements if ( swapR ! = r ) { final int tmpIndex = index [ r ] ; index [ r ] = index [ swapR ] ; index [ swapR ] = tmpIndex ; final double [ ] tmpRow = b [ r ] ; b [ r ] = b [ swapR ] ; b [ swapR ] = tmpRow ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; final double inverse2 = 1 / c [ ir ] [ ir ] ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = c [ ii ] [ ir ] * c [ ii ] [ ir ] * inverse2 ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_21"}
{"buggy_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] swap = new int [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element swap [ r ] = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isi = index [ swap [ i ] ] ; if ( c [ ii ] [ ii ] > c [ isi ] [ isi ] ) { swap [ r ] = i ; } } / / swap elements if ( swap [ r ] ! = r ) { int tmp = index [ r ] ; index [ r ] = index [ swap [ r ] ] ; index [ swap [ r ] ] = tmp ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = e * e ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "fixed_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element int swapR = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isr = index [ swapR ] ; if ( c [ ii ] [ ii ] > c [ isr ] [ isr ] ) { swapR = i ; } } / / swap elements if ( swapR ! = r ) { final int tmpIndex = index [ r ] ; index [ r ] = index [ swapR ] ; index [ swapR ] = tmpIndex ; final double [ ] tmpRow = b [ r ] ; b [ r ] = b [ swapR ] ; b [ swapR ] = tmpRow ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; final double inverse2 = 1 / c [ ir ] [ ir ] ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = c [ ii ] [ ir ] * c [ ii ] [ ir ] * inverse2 ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_21"}
{"buggy_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; }", "fixed_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; } + iter ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_23"}
{"buggy_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; }", "fixed_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; } + iter ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_23"}
{"buggy_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return current ; } }", "fixed_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return current ; } }", "fixed_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_24"}
{"buggy_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "fixed_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { if ( c2 = = 0 ) { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . throw new MathIllegalStateException ( LocalizedFormats . ZERO_DENOMINATOR ) ; } a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "fixed_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { if ( c2 = = 0 ) { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . throw new MathIllegalStateException ( LocalizedFormats . ZERO_DENOMINATOR ) ; } a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_25"}
{"buggy_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_26"}
{"buggy_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_26"}
{"buggy_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; }", "fixed_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return 100 * doubleValue ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_27"}
{"buggy_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; }", "fixed_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return 100 * doubleValue ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_27"}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis if ( tableau . getNumArtificialVariables ( ) > 0 ) { for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis if ( tableau . getNumArtificialVariables ( ) > 0 ) { for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_28"}
{"buggy_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; } return res ; } * * These special cases are handled below . return res ; }", "fixed_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; } return res ; } * * These special cases are handled below . if ( v . isNaN ( ) | | v . isInfinite ( ) ) { final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { final double y = v . getEntry ( i ) ; if ( Double . isNaN ( y ) ) { res . setEntry ( i , Double . NaN ) ; } else if ( Double . isInfinite ( y ) ) { final double x = this . getEntry ( i ) ; res . setEntry ( i , x * y ) ; } } } return res ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; } return res ; } * * These special cases are handled below . return res ; }", "fixed_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; } return res ; } * * These special cases are handled below . if ( v . isNaN ( ) | | v . isInfinite ( ) ) { final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { final double y = v . getEntry ( i ) ; if ( Double . isNaN ( y ) ) { res . setEntry ( i , Double . NaN ) ; } else if ( Double . isInfinite ( y ) ) { final double x = this . getEntry ( i ) ; res . setEntry ( i , x * y ) ; } } } return res ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_29"}
{"buggy_code": "throw new DimensionMismatchException ( len , b . length ) ; } / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "fixed_code": "throw new DimensionMismatchException ( len , b . length ) ; } if ( len = = 1 ) { / / Revert to scalar multiplication . return a [ 0 ] * b [ 0 ] ; } final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "throw new DimensionMismatchException ( len , b . length ) ; } / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "fixed_code": "throw new DimensionMismatchException ( len , b . length ) ; } if ( len = = 1 ) { / / Revert to scalar multiplication . return a [ 0 ] * b [ 0 ] ; } final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_3"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_30"}
{"buggy_code": "int n = 1 ; double dPrev = 0 . 0 ; double p0 = 1 . 0 ; double q1 = 1 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double cN = a * hPrev + b * p0 ; double q2 = a * q1 + b * dPrev ; if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { double scaleFactor = 1d ; double lastScaleFactor = 1d ; final int maxPower = 5 ; final double scale = FastMath . max ( a , b ) ; if ( scale < = 0 ) { / / Can ' t scale throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; } for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; } else if ( b ! = 0 ) { cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; } if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { break ; } } } final double deltaN = cN / q2 / cPrev ; hN = cPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = q1 ; cPrev = cN / q2 ; p0 = hPrev ; hPrev = cN ; q1 = q2 ; n + + ; }", "fixed_code": "int n = 1 ; double dPrev = 0 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double dN = a + b * dPrev ; if ( Precision . equals ( dN , 0 . 0 , small ) ) { dN = small ; } double cN = a + b / cPrev ; if ( Precision . equals ( cN , 0 . 0 , small ) ) { cN = small ; } dN = 1 / dN ; final double deltaN = cN * dN ; hN = hPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = dN ; cPrev = cN ; hPrev = hN ; n + + ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "int n = 1 ; double dPrev = 0 . 0 ; double p0 = 1 . 0 ; double q1 = 1 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double cN = a * hPrev + b * p0 ; double q2 = a * q1 + b * dPrev ; if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { double scaleFactor = 1d ; double lastScaleFactor = 1d ; final int maxPower = 5 ; final double scale = FastMath . max ( a , b ) ; if ( scale < = 0 ) { / / Can ' t scale throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; } for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; } else if ( b ! = 0 ) { cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; } if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { break ; } } } final double deltaN = cN / q2 / cPrev ; hN = cPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = q1 ; cPrev = cN / q2 ; p0 = hPrev ; hPrev = cN ; q1 = q2 ; n + + ; }", "fixed_code": "int n = 1 ; double dPrev = 0 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double dN = a + b * dPrev ; if ( Precision . equals ( dN , 0 . 0 , small ) ) { dN = small ; } double cN = a + b / cPrev ; if ( Precision . equals ( cN , 0 . 0 , small ) ) { cN = small ; } dN = 1 / dN ; final double deltaN = cN * dN ; hN = hPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = dN ; cPrev = cN ; hPrev = hN ; n + + ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_31"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_32"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_33"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_35"}
{"buggy_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; }", "fixed_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_36"}
{"buggy_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; }", "fixed_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_36"}
{"buggy_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "fixed_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN | | Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20 . 0 ) { return createComplex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < - 20 . 0 ) { return createComplex ( 0 . 0 , - 1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN | | Double . isInfinite ( imaginary ) ) { return NaN ; } if ( real > 20 . 0 ) { return createComplex ( 1 . 0 , 0 . 0 ) ; } if ( real < - 20 . 0 ) { return createComplex ( - 1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_37"}
{"buggy_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "fixed_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN | | Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20 . 0 ) { return createComplex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < - 20 . 0 ) { return createComplex ( 0 . 0 , - 1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN | | Double . isInfinite ( imaginary ) ) { return NaN ; } if ( real > 20 . 0 ) { return createComplex ( 1 . 0 , 0 . 0 ) ; } if ( real < - 20 . 0 ) { return createComplex ( - 1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_37"}
{"buggy_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new PathIsExploredException ( ) ; / / XXX } final int iptMinus1 = ipt ; final int jptMinus1 = jpt ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; throw new PathIsExploredException ( ) ; / / XXX } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "fixed_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int iptMinus1 = ipt - 1 ; final int jptMinus1 = jpt - 1 ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_38"}
{"buggy_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new PathIsExploredException ( ) ; / / XXX } final int iptMinus1 = ipt ; final int jptMinus1 = jpt ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; throw new PathIsExploredException ( ) ; / / XXX } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "fixed_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int iptMinus1 = ipt - 1 ; final int jptMinus1 = jpt - 1 ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_38"}
{"buggy_code": "} stepSize = hNew ; / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "fixed_code": "} stepSize = hNew ; if ( forward ) { if ( stepStart + stepSize > = t ) { stepSize = t - stepStart ; } } else { if ( stepStart + stepSize < = t ) { stepSize = t - stepStart ; } } / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "} stepSize = hNew ; / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "fixed_code": "} stepSize = hNew ; if ( forward ) { if ( stepStart + stepSize > = t ) { stepSize = t - stepStart ; } } else { if ( stepStart + stepSize < = t ) { stepSize = t - stepStart ; } } / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_39"}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_4"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_41"}
{"buggy_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "fixed_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "fixed_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_42"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( meanImpl ! = mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl ! = variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl ! = geoMean ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( meanImpl ! = mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl ! = variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl ! = geoMean ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_43"}
{"buggy_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; resetOccurred = false ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "fixed_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; resetOccurred = false ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "fixed_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_44"}
{"buggy_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "fixed_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; long lRow = ( long ) rowDimension ; long lCol = ( long ) columnDimension ; if ( lRow * lCol > = ( long ) Integer . MAX_VALUE ) { throw new NumberIsTooLargeException ( lRow * lCol , Integer . MAX_VALUE , false ) ; } this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_45"}
{"buggy_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "fixed_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; long lRow = ( long ) rowDimension ; long lCol = ( long ) columnDimension ; if ( lRow * lCol > = ( long ) Integer . MAX_VALUE ) { throw new NumberIsTooLargeException ( lRow * lCol , Integer . MAX_VALUE , false ) ; } this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_45"}
{"buggy_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "fixed_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_46"}
{"buggy_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "fixed_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_46"}
{"buggy_code": "private final transient boolean isInfinite ;", "fixed_code": "private final transient boolean isInfinite ; private final transient boolean isZero ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_47"}
{"buggy_code": "private final transient boolean isInfinite ;", "fixed_code": "private final transient boolean isInfinite ; private final transient boolean isZero ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_47"}
{"buggy_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "fixed_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_48"}
{"buggy_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "fixed_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_48"}
{"buggy_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_49"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; / / Update formula cannot make any progress : Update the / / search interval . default : / / Should never happen . } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { final double delta = FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ; / / Update formula cannot make any progress : Update the / / search interval . x0 = 0 . 5 * ( x0 + x1 - delta ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . throw new MathInternalError ( ) ; } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_51"}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; / / Update formula cannot make any progress : Update the / / search interval . default : / / Should never happen . } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { final double delta = FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ; / / Update formula cannot make any progress : Update the / / search interval . x0 = 0 . 5 * ( x0 + x1 - delta ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . throw new MathInternalError ( ) ; } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_51"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; final double inPlaneThreshold = 0 . 001 ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_52"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; final double inPlaneThreshold = 0 . 001 ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_52"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign return ; } Dfp y = this ; boolean negate = false ; if ( lessThan ( getZero ( ) ) ) { y = negate ( ) ; negate = true ; }", "fixed_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign if ( ( bits & 0x8000000000000000L ) ! = 0 ) { sign = - 1 ; } return ; } Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 = = 0 ) { return sign < 0 ? - 0 . 0 : + 0 . 0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_54"}
{"buggy_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign return ; } Dfp y = this ; boolean negate = false ; if ( lessThan ( getZero ( ) ) ) { y = negate ( ) ; negate = true ; }", "fixed_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign if ( ( bits & 0x8000000000000000L ) ! = 0 ) { sign = - 1 ; } return ; } Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 = = 0 ) { return sign < 0 ? - 0 . 0 : + 0 . 0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_54"}
{"buggy_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; }", "fixed_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_55"}
{"buggy_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; }", "fixed_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_55"}
{"buggy_code": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "fixed_code": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "fixed_code": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_56"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_58"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_59"}
{"buggy_code": "} PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( iteration > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; + + iteration ; } } this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; }", "fixed_code": "} PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { incrementIterationCount ( ) ; / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( getIterations ( ) > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; incrementIterationCount ( ) ; } } this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "/ / iterate until convergence is reached PointVectorValuePair current = null ; int iter = 0 ; for ( boolean converged = false ; ! converged ; ) { + + iter ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( iter , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ;", "fixed_code": "/ / iterate until convergence is reached PointVectorValuePair current = null ; for ( boolean converged = false ; ! converged ; ) { incrementIterationCount ( ) ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( getIterations ( ) , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_6"}
{"buggy_code": "/ / Outer loop . lmPar = 0 ; boolean firstIteration = true ; int iter = 0 ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { + + iter ; final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( iter , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "fixed_code": "/ / Outer loop . lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ;  final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Math_6"}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Math_6"}
{"buggy_code": "double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; int iter = 0 ; while ( true ) { + + iter ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( iter , previous , current ) ; } } if ( stop ) {", "fixed_code": "double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; while ( true ) { incrementIterationCount ( ) ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( getIterations ( ) , previous , current ) ; } } if ( stop ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "Math_6"}
{"buggy_code": "} PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ;", "fixed_code": "} PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch6", "project_name": "Math_6"}
{"buggy_code": "generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ;", "fixed_code": "generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { incrementIterationCount ( ) ; / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch7", "project_name": "Math_6"}
{"buggy_code": "int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( iteration > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; + + iteration ; } }", "fixed_code": "int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( getIterations ( ) > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; incrementIterationCount ( ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch8", "project_name": "Math_6"}
{"buggy_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } }", "fixed_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } }", "fixed_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_60"}
{"buggy_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_61"}
{"buggy_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , 0 ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , 0 ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_62"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_64"}
{"buggy_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_64"}
{"buggy_code": "* @ return RMS value public double getRMS ( ) { double criterion = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residualsWeights [ i ] ; } return Math . sqrt ( criterion / rows ) ; }", "fixed_code": "* @ return RMS value public double getRMS ( ) { return Math . sqrt ( getChiSquare ( ) / rows ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "* @ return RMS value public double getRMS ( ) { double criterion = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residualsWeights [ i ] ; } return Math . sqrt ( criterion / rows ) ; }", "fixed_code": "* @ return RMS value public double getRMS ( ) { return Math . sqrt ( getChiSquare ( ) / rows ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_65"}
{"buggy_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( Integer . MAX_VALUE ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1E - 10 ) ; setRelativeAccuracy ( 1 . 0e - 14 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { throw new UnsupportedOperationException ( ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { clearResult ( ) ; return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , f , goalType , min , startValue , max , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; } private double localMin ( boolean isMinim , UnivariateRealFunction f , GoalType goalType , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( f , x ) ; if ( goalType = = GoalType . MAXIMIZE ) { fx = - fx ; } double fv = fx ; double fw = fx ; int count = 0 ; while ( count < maximalIterationCount ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( f , u ) ; if ( goalType = = GoalType . MAXIMIZE ) { fu = - fu ; } } } } else { / / termination setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new MaxIterationsExceededException ( maximalIterationCount ) ; } }", "fixed_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( 1000 ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1e - 11 ) ; setRelativeAccuracy ( 1e - 9 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , getMin ( ) , getStartValue ( ) , getMax ( ) , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } private double localMin ( boolean isMinim , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; while ( true ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } } } } else { / / termination setFunctionValue ( isMinim ? fx : - fx ) ; return x ; } incrementIterationsCounter ( ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_66"}
{"buggy_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( Integer . MAX_VALUE ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1E - 10 ) ; setRelativeAccuracy ( 1 . 0e - 14 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { throw new UnsupportedOperationException ( ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { clearResult ( ) ; return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , f , goalType , min , startValue , max , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; } private double localMin ( boolean isMinim , UnivariateRealFunction f , GoalType goalType , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( f , x ) ; if ( goalType = = GoalType . MAXIMIZE ) { fx = - fx ; } double fv = fx ; double fw = fx ; int count = 0 ; while ( count < maximalIterationCount ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( f , u ) ; if ( goalType = = GoalType . MAXIMIZE ) { fu = - fu ; } } } } else { / / termination setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new MaxIterationsExceededException ( maximalIterationCount ) ; } }", "fixed_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( 1000 ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1e - 11 ) ; setRelativeAccuracy ( 1e - 9 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , getMin ( ) , getStartValue ( ) , getMax ( ) , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } private double localMin ( boolean isMinim , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; while ( true ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } } } } else { / / termination setFunctionValue ( isMinim ? fx : - fx ) ; return x ; } incrementIterationsCounter ( ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_66"}
{"buggy_code": "public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } public double getResult ( ) { return optimizer . getResult ( ) ; }", "fixed_code": "public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } public double getResult ( ) { return optima [ 0 ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_67"}
{"buggy_code": "public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } public double getResult ( ) { return optimizer . getResult ( ) ; }", "fixed_code": "public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } public double getResult ( ) { return optima [ 0 ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_67"}
{"buggy_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return new VectorialPointValuePair ( point , objective ) ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setConvergenceChecker ( null ) ; setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix VectorialPointValuePair previous = current ; updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } else { / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_68"}
{"buggy_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return new VectorialPointValuePair ( point , objective ) ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setConvergenceChecker ( null ) ; setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix VectorialPointValuePair previous = current ; updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } else { / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_68"}
{"buggy_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "fixed_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "fixed_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_69"}
{"buggy_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time currentEvent . stepAccepted ( eventT , eventY ) ; isLastStep = currentEvent . stop ( ) ; / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } boolean needReset = currentEvent . reset ( eventT , eventY ) ; if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "fixed_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventY ) ; isLastStep = isLastStep | | state . stop ( ) ; } / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset | | state . reset ( eventT , eventY ) ; } if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time currentEvent . stepAccepted ( eventT , eventY ) ; isLastStep = currentEvent . stop ( ) ; / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } boolean needReset = currentEvent . reset ( eventT , eventY ) ; if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "fixed_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventY ) ; isLastStep = isLastStep | | state . stop ( ) ; } / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset | | state . reset ( eventT , eventY ) ; } if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_7"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_72"}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_73"}
{"buggy_code": "} if ( firstTime ) { final double [ ] scale ; if ( vecAbsoluteTolerance = = null ) { scale = new double [ y0 . length ] ; java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; } else { scale = vecAbsoluteTolerance ; } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "fixed_code": "} if ( firstTime ) { final double [ ] scale = new double [ y0 . length ] ; if ( vecAbsoluteTolerance = = null ) { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; } } else { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; } } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "} if ( firstTime ) { final double [ ] scale ; if ( vecAbsoluteTolerance = = null ) { scale = new double [ y0 . length ] ; java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; } else { scale = vecAbsoluteTolerance ; } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "fixed_code": "} if ( firstTime ) { final double [ ] scale = new double [ y0 . length ] ; if ( vecAbsoluteTolerance = = null ) { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; } } else { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; } } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_74"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_75"}
{"buggy_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "fixed_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , n - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < n - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , m - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < m - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_76"}
{"buggy_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "fixed_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , n - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < n - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , m - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < m - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_76"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_77"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_77"}
{"buggy_code": "return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "return max ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Math_77"}
{"buggy_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing / / this should never happen / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "fixed_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step if ( ga * gb > 0 ) { / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { ta + = epsilon ; interpolator . setInterpolatedTime ( ta ) ; ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; } if ( ga * gb > 0 ) { / / this should never happen throw MathRuntimeException . createInternalError ( null ) ; } } / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing / / this should never happen / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "fixed_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step if ( ga * gb > 0 ) { / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { ta + = epsilon ; interpolator . setInterpolatedTime ( ta ) ; ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; } if ( ga * gb > 0 ) { / / this should never happen throw MathRuntimeException . createInternalError ( null ) ; } } / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_78"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_79"}
{"buggy_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 3 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 3 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = getNumObjectiveFunctions ( ) ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "fixed_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_83"}
{"buggy_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = getNumObjectiveFunctions ( ) ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "fixed_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_83"}
{"buggy_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence return ; }", "fixed_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex return ; } / / check convergence final int iter = getIterations ( ) ; boolean converged = true ; for ( int i = 0 ; i < simplex . length ; + + i ) { converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; } if ( converged ) { return ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence return ; }", "fixed_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex return ; } / / check convergence final int iter = getIterations ( ) ; boolean converged = true ; for ( int i = 0 ; i < simplex . length ; + + i ) { converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; } if ( converged ) { return ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "final double [ ] lI = lTData [ i ] ; if ( lTData [ i ] [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "fixed_code": "final double [ ] lI = lTData [ i ] ; / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_86"}
{"buggy_code": "final double [ ] lI = lTData [ i ] ; if ( lTData [ i ] [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "fixed_code": "final double [ ] lI = lTData [ i ] ; / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_86"}
{"buggy_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "fixed_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { return null ; } } return row ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "fixed_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { return null ; } } return row ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_87"}
{"buggy_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "fixed_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "fixed_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_88"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_89"}
{"buggy_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; }", "fixed_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_9"}
{"buggy_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; }", "fixed_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_9"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "fixed_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } public void addValue ( Comparable < ? > v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "fixed_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } public void addValue ( Comparable < ? > v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_90"}
{"buggy_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { double nOd = doubleValue ( ) ; double dOn = object . doubleValue ( ) ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "fixed_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { long nOd = ( ( long ) numerator ) * object . denominator ; long dOn = ( ( long ) denominator ) * object . numerator ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_91"}
{"buggy_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { double nOd = doubleValue ( ) ; double dOn = object . doubleValue ( ) ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "fixed_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { long nOd = ( ( long ) numerator ) * object . denominator ; long dOn = ( ( long ) denominator ) * object . numerator ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_91"}
{"buggy_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } long result = Math . round ( binomialCoefficientDouble ( n , k ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" result too large to represent in a long integer \" ) ; } / / Use symmetry for large k / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k / / For n < = 61 , the naive implementation cannot overflow . / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { return Math . floor ( Math . exp ( binomialCoefficientLog ( n , k ) ) + 0 . 5 ) ; }", "fixed_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } / / Use symmetry for large k if ( k > n / 2 ) return binomialCoefficient ( n , n - k ) ; / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k long result = 1 ; if ( n < = 61 ) { / / For n < = 61 , the naive implementation cannot overflow . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { result = result * i / j ; } } else if ( n < = 66 ) { / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . long d = gcd ( i , j ) ; result = ( result / ( j / d ) ) * ( i / d ) ; } } else { / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { long d = gcd ( i , j ) ; result = mulAndCheck ( ( result / ( j / d ) ) , ( i / d ) ) ; } } return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { if ( n < k ) { throw new IllegalArgumentException ( \" must have n > = k for binomial coefficient ( n , k ) \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for binomial coefficient ( n , k ) \" ) ; } if ( ( n = = k ) | | ( k = = 0 ) ) { return 1d ; } if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } if ( k > n / 2 ) { return binomialCoefficientDouble ( n , n - k ) ; } if ( n < 67 ) { return binomialCoefficient ( n , k ) ; } double result = 1d ; for ( int i = 1 ; i < = k ; i + + ) { result * = ( double ) ( n - k + i ) / ( double ) i ; } return Math . floor ( result + 0 . 5 ) ; } if ( n < 67 ) { return Math . log ( binomialCoefficient ( n , k ) ) ; } if ( n < 1030 ) { return Math . log ( binomialCoefficientDouble ( n , k ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_92"}
{"buggy_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } long result = Math . round ( binomialCoefficientDouble ( n , k ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" result too large to represent in a long integer \" ) ; } / / Use symmetry for large k / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k / / For n < = 61 , the naive implementation cannot overflow . / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { return Math . floor ( Math . exp ( binomialCoefficientLog ( n , k ) ) + 0 . 5 ) ; }", "fixed_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } / / Use symmetry for large k if ( k > n / 2 ) return binomialCoefficient ( n , n - k ) ; / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k long result = 1 ; if ( n < = 61 ) { / / For n < = 61 , the naive implementation cannot overflow . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { result = result * i / j ; } } else if ( n < = 66 ) { / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . long d = gcd ( i , j ) ; result = ( result / ( j / d ) ) * ( i / d ) ; } } else { / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { long d = gcd ( i , j ) ; result = mulAndCheck ( ( result / ( j / d ) ) , ( i / d ) ) ; } } return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { if ( n < k ) { throw new IllegalArgumentException ( \" must have n > = k for binomial coefficient ( n , k ) \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for binomial coefficient ( n , k ) \" ) ; } if ( ( n = = k ) | | ( k = = 0 ) ) { return 1d ; } if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } if ( k > n / 2 ) { return binomialCoefficientDouble ( n , n - k ) ; } if ( n < 67 ) { return binomialCoefficient ( n , k ) ; } double result = 1d ; for ( int i = 1 ; i < = k ; i + + ) { result * = ( double ) ( n - k + i ) / ( double ) i ; } return Math . floor ( result + 0 . 5 ) ; } if ( n < 67 ) { return Math . log ( binomialCoefficient ( n , k ) ) ; } if ( n < 1030 ) { return Math . log ( binomialCoefficientDouble ( n , k ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_92"}
{"buggy_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "fixed_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < 21 ) { return factorial ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } if ( n < 21 ) { return Math . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "fixed_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < 21 ) { return factorial ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } if ( n < 21 ) { return Math . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_93"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_94"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_94"}
{"buggy_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret = 1 . 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; if ( d > 2 . 0 ) { / / use mean ret = d / ( d - 2 . 0 ) ; } return ret ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret = 1 . 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; if ( d > 2 . 0 ) { / / use mean ret = d / ( d - 2 . 0 ) ; } return ret ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_96"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_96"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } else { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; / / either min or max is a root } return ret ;", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > 0 ) { / / check if either value is close to a zero if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; ret = min ; } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; ret = max ; } else { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } } else if ( sign < 0 ) { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; } else { / / either min or max is a root if ( yMin = = 0 . 0 ) { ret = min ; } else { ret = max ; } } return ret ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } else { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; / / either min or max is a root } return ret ;", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > 0 ) { / / check if either value is close to a zero if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; ret = min ; } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; ret = max ; } else { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } } else if ( sign < 0 ) { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; } else { / / either min or max is a root if ( yMin = = 0 . 0 ) { ret = min ; } else { ret = max ; } } return ret ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_97"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( \" overflow : lcm is 2 ^ 31 \" ) ; } return lcm ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( \" overflow : lcm is 2 ^ 31 \" ) ; } return lcm ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_99"}
{"buggy_code": "public void captureArgumentsFrom ( Invocation invocation ) { if ( invocation . getMethod ( ) . isVarArgs ( ) ) { int indexOfVararg = invocation . getRawArguments ( ) . length - 1 ; throw new UnsupportedOperationException ( ) ; } else { for ( int position = 0 ; position < matchers . size ( ) ; position + + ) {", "fixed_code": "public void captureArgumentsFrom ( Invocation invocation ) { if ( invocation . getMethod ( ) . isVarArgs ( ) ) { int indexOfVararg = invocation . getRawArguments ( ) . length - 1 ; for ( int position = 0 ; position < indexOfVararg ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getRawArguments ( ) [ position - indexOfVararg ] ) ; } } } else { for ( int position = 0 ; position < matchers . size ( ) ; position + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_1"}
{"buggy_code": "import org . mockito . internal . util . MockUtil ; import org . mockito . internal . util . reflection . GenericMetadataSupport ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . io . IOException ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } * @ param parentMock The parent of the current deep stub mock . * @ return The mock private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata ) { return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ;", "fixed_code": "import org . mockito . internal . util . MockUtil ; import org . mockito . internal . util . reflection . GenericMetadataSupport ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . mock . MockCreationSettings ; import org . mockito . stubbing . Answer ; import java . io . IOException ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata , invocation . getMock ( ) ) , container ) ; } * @ param parentMock The parent of the current deep stub mock . * @ return The mock private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata , Object parentMock ) { MockCreationSettings parentMockSettings = new MockUtil ( ) . getMockSettings ( parentMock ) ; return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata , parentMockSettings ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata , MockCreationSettings parentMockSettings ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ; return propagateSerializationSettings ( mockSettings , parentMockSettings ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private MockSettings propagateSerializationSettings ( MockSettings mockSettings , MockCreationSettings parentMockSettings ) { return mockSettings . serializable ( parentMockSettings . getSerializableMode ( ) ) ; } private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_10"}
{"buggy_code": "@ Override public boolean equals ( Object o ) { return method . equals ( o ) ; } @ Override public int hashCode ( ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "@ Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o instanceof DelegatingMethod ) { DelegatingMethod that = ( DelegatingMethod ) o ; return method . equals ( that . method ) ; } else { return method . equals ( o ) ; } } @ Override public int hashCode ( ) { return method . hashCode ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_11"}
{"buggy_code": "Type generic = field . getGenericType ( ) ; if ( generic ! = null & & generic instanceof ParameterizedType ) { Type actual = ( ( ParameterizedType ) generic ) . getActualTypeArguments ( ) [ 0 ] ; return ( Class ) actual ; / / in case of nested generics we don ' t go deep } return Object . class ;", "fixed_code": "Type generic = field . getGenericType ( ) ; if ( generic ! = null & & generic instanceof ParameterizedType ) { Type actual = ( ( ParameterizedType ) generic ) . getActualTypeArguments ( ) [ 0 ] ; if ( actual instanceof Class ) { return ( Class ) actual ; } else if ( actual instanceof ParameterizedType ) { / / in case of nested generics we don ' t go deep return ( Class ) ( ( ParameterizedType ) actual ) . getRawType ( ) ; } } return Object . class ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_12"}
{"buggy_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) if ( verificationMode instanceof MockAwareVerificationMode & & ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; / / this means there is an invocation on a different mock . Re - adding verification mode / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) } }", "fixed_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) if ( ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } else { / / this means there is an invocation on a different mock . Re - adding verification mode / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) mockingProgress . verificationStarted ( verificationMode ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_13"}
{"buggy_code": "import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubbedInvocationMatcher ; import org . mockito . internal . stubbing . VoidMethodStubbableImpl ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . stubbing . Answer ; import org . mockito . stubbing . VoidMethodStubbable ; if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ;", "fixed_code": "import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubbedInvocationMatcher ; import org . mockito . internal . stubbing . VoidMethodStubbableImpl ; import org . mockito . internal . verification . MockAwareVerificationMode ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . stubbing . Answer ; import org . mockito . stubbing . VoidMethodStubbable ; if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest if ( verificationMode instanceof MockAwareVerificationMode & & ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_14"}
{"buggy_code": "import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubberImpl ; import org . mockito . internal . util . MockUtil ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . internal . verification . VerificationModeFactory ; import org . mockito . internal . verification . api . InOrderContext ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; return mock ; }", "fixed_code": "import org . mockito . internal . stubbing . OngoingStubbingImpl ; import org . mockito . internal . stubbing . StubberImpl ; import org . mockito . internal . util . MockUtil ; import org . mockito . internal . verification . MockAwareVerificationMode ; import org . mockito . internal . verification . VerificationDataImpl ; import org . mockito . internal . verification . VerificationModeFactory ; import org . mockito . internal . verification . api . InOrderContext ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , mode ) ) ; return mock ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Mockito_14"}
{"buggy_code": "package org . mockito . internal . configuration . injection ; import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . reflection . FieldSetter ; import java . lang . reflect . Field ; return new OngoingInjecter ( ) { public boolean thenInject ( ) { try { new FieldSetter ( fieldInstance , field ) . set ( matchingMock ) ; } catch ( Exception e ) { throw new MockitoException ( \" Problems injecting dependency in \" + field . getName ( ) , e ) ; }", "fixed_code": "package org . mockito . internal . configuration . injection ; import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . reflection . BeanPropertySetter ; import org . mockito . internal . util . reflection . FieldSetter ; import java . lang . reflect . Field ; return new OngoingInjecter ( ) { public boolean thenInject ( ) { try { if ( ! new BeanPropertySetter ( fieldInstance , field ) . set ( matchingMock ) ) { new FieldSetter ( fieldInstance , field ) . set ( matchingMock ) ; } } catch ( Exception e ) { throw new MockitoException ( \" Problems injecting dependency in \" + field . getName ( ) , e ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_15"}
{"buggy_code": "private final MockUtil mockUtil = new MockUtil ( ) ; private final MockingProgress mockingProgress = new ThreadSafeMockingProgress ( ) ; public < T > T mock ( Class < T > classToMock , MockSettings mockSettings , boolean shouldResetOngoingStubbing ) { return mock ( classToMock , mockSettings ) ; } public < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { mockingProgress . validateState ( ) ; mockingProgress . resetOngoingStubbing ( ) ; return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; }", "fixed_code": "private final MockUtil mockUtil = new MockUtil ( ) ; private final MockingProgress mockingProgress = new ThreadSafeMockingProgress ( ) ; public < T > T mock ( Class < T > classToMock , MockSettings mockSettings , boolean shouldResetOngoingStubbing ) { mockingProgress . validateState ( ) ; if ( shouldResetOngoingStubbing ) { mockingProgress . resetOngoingStubbing ( ) ; } return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_16"}
{"buggy_code": "* @ return mock object public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; }", "fixed_code": "* @ return mock object public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Mockito_16"}
{"buggy_code": "import org . mockito . internal . creation . jmock . ClassImposterizer ; import org . mockito . internal . util . reflection . LenientCopyTool ; @ SuppressWarnings ( \" unchecked \" ) public class MockUtil { Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;", "fixed_code": "import org . mockito . internal . creation . jmock . ClassImposterizer ; import org . mockito . internal . util . reflection . LenientCopyTool ; import java . io . Serializable ; @ SuppressWarnings ( \" unchecked \" ) public class MockUtil { Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; if ( settings . isSerializable ( ) ) { ancillaryTypes = interfaces = = null ? new Class < ? > [ ] { Serializable . class } : new ArrayUtils ( ) . concat ( interfaces , Serializable . class ) ; } else { ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; } Object spiedInstance = settings . getSpiedInstance ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_17"}
{"buggy_code": "private Object spiedInstance ; private Answer < Object > defaultAnswer ; private MockName mockName ; public MockSettings serializable ( ) { return this . extraInterfaces ( java . io . Serializable . class ) ; } public MockSettings extraInterfaces ( Class < ? > . . . extraInterfaces ) { } public boolean isSerializable ( ) { return extraInterfaces ! = null & & java . util . Arrays . asList ( extraInterfaces ) . contains ( java . io . Serializable . class ) ; } public void initiateMockName ( Class classToMock ) {", "fixed_code": "private Object spiedInstance ; private Answer < Object > defaultAnswer ; private MockName mockName ; private boolean serializable ; public MockSettings serializable ( ) { this . serializable = true ; return this ; } public MockSettings extraInterfaces ( Class < ? > . . . extraInterfaces ) { } public boolean isSerializable ( ) { return serializable ; } public void initiateMockName ( Class classToMock ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Mockito_17"}
{"buggy_code": "return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; / / new instances are used instead of Collections . emptyList ( ) , etc . / / to avoid UnsupportedOperationException if code under test modifies returned collection } else if ( type = = Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type = = Set . class ) {", "fixed_code": "return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; / / new instances are used instead of Collections . emptyList ( ) , etc . / / to avoid UnsupportedOperationException if code under test modifies returned collection } else if ( type = = Iterable . class ) { return new ArrayList < Object > ( 0 ) ; } else if ( type = = Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type = = Set . class ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_18"}
{"buggy_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ;", "fixed_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , orderedInstanceFields , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_19"}
{"buggy_code": "this . next = next ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fieldInstance ) ; } }", "fixed_code": "this . next = next ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fields , fieldInstance ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Mockito_19"}
{"buggy_code": "import java . lang . reflect . Field ; import java . util . Collection ; public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ;", "fixed_code": "import java . lang . reflect . Field ; import java . util . Collection ; import java . util . List ; public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , List < Field > fields , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Mockito_19"}
{"buggy_code": "} public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fieldInstance ) ; } return next . filterCandidate ( mocks , field , fieldInstance ) ; } }", "fixed_code": "} public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fields , fieldInstance ) ; } else if ( mocks . size ( ) = = 1 ) { String mockName = mockUtil . getMockName ( mocks . iterator ( ) . next ( ) ) . toString ( ) ;  for ( Field otherField : fields ) { if ( ! otherField . equals ( field ) & & otherField . getType ( ) . equals ( field . getType ( ) ) & & otherField . getName ( ) . equals ( mockName ) ) {  return new OngoingInjecter ( ) { public Object thenInject ( ) { return null ; } } ; } } } return next . filterCandidate ( mocks , field , fields , fieldInstance ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch4", "project_name": "Mockito_19"}
{"buggy_code": "import java . lang . reflect . Field ; import java . util . Collection ; public interface MockCandidateFilter { OngoingInjecter filterCandidate ( Collection < Object > mocks , Field fieldToBeInjected , Object fieldInstance ) ; }", "fixed_code": "import java . lang . reflect . Field ; import java . util . Collection ; import java . util . List ; public interface MockCandidateFilter { OngoingInjecter filterCandidate ( Collection < Object > mocks , Field fieldToBeInjected , List < Field > fields , Object instance ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch5", "project_name": "Mockito_19"}
{"buggy_code": "package org . mockito . internal . util ; public class Timer { private long startTime = - 1 ; public Timer ( long durationMillis ) { this . durationMillis = durationMillis ; } startTime = System . currentTimeMillis ( ) ; } }", "fixed_code": "package org . mockito . internal . util ; import org . mockito . exceptions . Reporter ; public class Timer { private long startTime = - 1 ; public Timer ( long durationMillis ) { validateInput ( durationMillis ) ; this . durationMillis = durationMillis ; } startTime = System . currentTimeMillis ( ) ; } private void validateInput ( long durationMillis ) { if ( durationMillis < 0 ) { new Reporter ( ) . cannotCreateTimerWithNegativeDurationTime ( durationMillis ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_2"}
{"buggy_code": "settings . getTypeToMock ( ) , settings . getExtraInterfaces ( ) ) ; T mockInstance = null ; try { mockInstance = classInstantiator . instantiate ( mockedProxyType ) ; MockMethodInterceptor . MockAccess mockAccess = ( MockMethodInterceptor . MockAccess ) mockInstance ; mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ; \" class to mock : \" + describeClass ( mockedProxyType ) , \" created class : \" + describeClass ( settings . getTypeToMock ( ) ) , \" proxy instance class : \" + describeClass ( mockInstance ) , \" instance creation by : \" + classInstantiator . getClass ( ) . getSimpleName ( ) , \" \" , \" You might experience classloading issues , please ask the mockito mailing - list . \" , \" \"", "fixed_code": "settings . getTypeToMock ( ) , settings . getExtraInterfaces ( ) ) ; Instantiator instantiator = new InstantiatorProvider ( ) . getInstantiator ( settings ) ; T mockInstance = null ; try { mockInstance = instantiator . newInstance ( mockedProxyType ) ; MockMethodInterceptor . MockAccess mockAccess = ( MockMethodInterceptor . MockAccess ) mockInstance ; mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ; \" class to mock : \" + describeClass ( mockedProxyType ) , \" created class : \" + describeClass ( settings . getTypeToMock ( ) ) , \" proxy instance class : \" + describeClass ( mockInstance ) , \" instance creation by : \" + instantiator . getClass ( ) . getSimpleName ( ) , \" \" , \" You might experience classloading issues , please ask the mockito mailing - list . \" , \" \"", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_20"}
{"buggy_code": "if ( outerClassInstance = = null ) { return noArgConstructor ( cls ) ; } return withOuterClass ( cls ) ; } private < T > T withOuterClass ( Class < T > cls ) { try { / / this is kind of overengineered because we don ' t need to support more params / / however , I know we will be needing it : ) Constructor < T > c = cls . getDeclaredConstructor ( outerClassInstance . getClass ( ) ) ; return c . newInstance ( outerClassInstance ) ; } catch ( Exception e ) { throw paramsException ( cls , e ) ; } } private static < T > InstantationException paramsException ( Class < T > cls , Exception e ) { } private static < T > T noArgConstructor ( Class < T > cls ) { try {", "fixed_code": "if ( outerClassInstance = = null ) { return noArgConstructor ( cls ) ; } return withParams ( cls , outerClassInstance ) ; } private static < T > T withParams ( Class < T > cls , Object . . . params ) { try { / / this is kind of overengineered because we don ' t need to support more params / / however , I know we will be needing it : ) for ( Constructor < ? > constructor : cls . getDeclaredConstructors ( ) ) { Class < ? > [ ] types = constructor . getParameterTypes ( ) ; if ( paramsMatch ( types , params ) ) { return ( T ) constructor . newInstance ( params ) ; } } } catch ( Exception e ) { throw paramsException ( cls , e ) ; } throw paramsException ( cls , null ) ; } private static < T > InstantationException paramsException ( Class < T > cls , Exception e ) { cls . getSimpleName ( ) + \" ' . \\ nPlease ensure that the outer instance has correct type and that the target class has parameter - less constructor . \" , e ) ; } private static boolean paramsMatch ( Class < ? > [ ] types , Object [ ] params ) { if ( params . length ! = types . length ) { return false ; } for ( int i = 0 ; i < params . length ; i + + ) { if ( ! types [ i ] . isInstance ( params [ i ] ) ) { return false ; } } return true ; } private static < T > T noArgConstructor ( Class < T > cls ) { try {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_21"}
{"buggy_code": "public class Equality { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "fixed_code": "public class Equality { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = o2 ) { return true ; } else if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_22"}
{"buggy_code": "private static final long serialVersionUID = - 7105341425736035847L ; private MockitoCore mockitoCore = new MockitoCore ( ) ; private ReturnsEmptyValues delegate = new ReturnsEmptyValues ( ) ; public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ; Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; } return getMock ( invocation , returnTypeGenericMetadata ) ; } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } return mock ; } protected GenericMetadataSupport actualParameterizedType ( Object mock ) {", "fixed_code": "private static final long serialVersionUID = - 7105341425736035847L ; private transient MockitoCore mockitoCore ; private transient ReturnsEmptyValues delegate ; public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ; Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; instantiateMockitoCoreIfNeeded ( ) ; instantiateDelegateIfNeeded ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; } return getMock ( invocation , returnTypeGenericMetadata ) ; } private synchronized void instantiateMockitoCoreIfNeeded ( ) { if ( mockitoCore = = null ) { mockitoCore = new MockitoCore ( ) ; } } private synchronized void instantiateDelegateIfNeeded ( ) { if ( delegate = = null ) { delegate = new ReturnsEmptyValues ( ) ; } } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new SerializableAnswer ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } return mock ; } abstract class SerializableAnswer implements Answer < Object > , Serializable { } protected GenericMetadataSupport actualParameterizedType ( Object mock ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_23"}
{"buggy_code": "/ / see issue 184 . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compareTo ( ) method by the Comparable interface return 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ;", "fixed_code": "/ / see issue 184 . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compareTo ( ) method by the Comparable interface return invocation . getMock ( ) = = invocation . getArguments ( ) [ 0 ] ? 0 : 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_24"}
{"buggy_code": "package org . mockito . internal . stubbing . defaultanswers ; import org . mockito . internal . InternalMockHandler ; import org . mockito . internal . creation . settings . CreationSettings ; import org . mockito . internal . stubbing . InvocationContainerImpl ; import java . io . Serializable ; private Object recordDeepStubMock ( InvocationOnMock invocation , InvocationContainerImpl container ) { Class < ? > clz = invocation . getMethod ( ) . getReturnType ( ) ; final Object mock = org . mockito . Mockito . mock ( clz , this ) ; container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable {", "fixed_code": "package org . mockito . internal . stubbing . defaultanswers ; import org . mockito . MockSettings ; import org . mockito . internal . InternalMockHandler ; import org . mockito . internal . creation . settings . CreationSettings ; import org . mockito . internal . stubbing . InvocationContainerImpl ; import java . io . Serializable ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . withSettings ; private Object createNewDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata ) { return mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . rawExtraInterfaces ( ) . length > 0 ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubs ( ) { @ Override protected GenericMetadataSupport actualParameterizedType ( Object mock ) { return returnTypeGenericMetadata ; } } ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_25"}
{"buggy_code": "primitiveValues . put ( int . class , 0 ) ; primitiveValues . put ( long . class , 0L ) ; primitiveValues . put ( float . class , 0F ) ; primitiveValues . put ( double . class , 0 ) ; } } \\ No newline at end of file", "fixed_code": "primitiveValues . put ( int . class , 0 ) ; primitiveValues . put ( long . class , 0L ) ; primitiveValues . put ( float . class , 0F ) ; primitiveValues . put ( double . class , 0D ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_26"}
{"buggy_code": "public < T > void resetMock ( T mock ) { MockHandlerInterface < T > oldMockHandler = getMockHandler ( mock ) ; MockHandler < T > newMockHandler = new MockHandler < T > ( oldMockHandler ) ; MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( newMockHandler , ( MockSettingsImpl ) org . mockito . Mockito . withSettings ( ) . defaultAnswer ( org . mockito . Mockito . RETURNS_DEFAULTS ) ) ; ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; }", "fixed_code": "public < T > void resetMock ( T mock ) { MockHandlerInterface < T > oldMockHandler = getMockHandler ( mock ) ; MethodInterceptorFilter newFilter = newMethodInterceptorFilter ( oldMockHandler . getMockSettings ( ) ) ; ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_27"}
{"buggy_code": "private void injectMockCandidate ( Class < ? > awaitingInjectionClazz , Set < Object > mocks , Object fieldInstance ) { for ( Field field : orderedInstanceFieldsFrom ( awaitingInjectionClazz ) ) { mockCandidateFilter . filterCandidate ( mocks , field , fieldInstance ) . thenInject ( ) ; } }", "fixed_code": "private void injectMockCandidate ( Class < ? > awaitingInjectionClazz , Set < Object > mocks , Object fieldInstance ) { for ( Field field : orderedInstanceFieldsFrom ( awaitingInjectionClazz ) ) { Object injected = mockCandidateFilter . filterCandidate ( mocks , field , fieldInstance ) . thenInject ( ) ; mocks . remove ( injected ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_28"}
{"buggy_code": "public void describeTo ( Description description ) { description . appendText ( \" same ( \" ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText ( \" ) \" ) ; }", "fixed_code": "public void describeTo ( Description description ) { description . appendText ( \" same ( \" ) ; appendQuoting ( description ) ; description . appendText ( wanted = = null ? \" null \" : wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText ( \" ) \" ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_29"}
{"buggy_code": "( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getRawArguments ( ) [ position - indexOfVararg ] ) ; } } } else { } } public static List < InvocationMatcher > createFrom ( List < Invocation > invocations ) { LinkedList < InvocationMatcher > out = new LinkedList < InvocationMatcher > ( ) ;", "fixed_code": "( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( Matcher m : uniqueMatcherSet ( indexOfVararg ) ) { if ( m instanceof CapturesArguments ) { Object rawArgument = invocation . getRawArguments ( ) [ indexOfVararg ] ; for ( int i = 0 ; i < Array . getLength ( rawArgument ) ; i + + ) { ( ( CapturesArguments ) m ) . captureFrom ( Array . get ( rawArgument , i ) ) ; } } } } else { } } private Set < Matcher > uniqueMatcherSet ( int indexOfVararg ) { HashSet < Matcher > set = new HashSet < Matcher > ( ) ; for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher matcher = matchers . get ( position ) ; if ( matcher instanceof MatcherDecorator ) { set . add ( ( ( MatcherDecorator ) matcher ) . getActualMatcher ( ) ) ; } else { set . add ( matcher ) ; } } return set ; } public static List < InvocationMatcher > createFrom ( List < Invocation > invocations ) { LinkedList < InvocationMatcher > out = new LinkedList < InvocationMatcher > ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_3"}
{"buggy_code": "return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; }", "fixed_code": "return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( obj , location ) ; return null ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_30"}
{"buggy_code": ") ) ; } public void smartNullPointerException ( Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , \" Because this method was * not * stubbed correctly : \" , location , \" \"", "fixed_code": ") ) ; } public void smartNullPointerException ( Object obj , Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , obj , \" Because this method was * not * stubbed correctly : \" , location , \" \"", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Mockito_30"}
{"buggy_code": "import java . io . Serializable ; import java . lang . reflect . Method ; import org . mockito . Mockito ; import org . mockito . cglib . proxy . MethodInterceptor ; } private String formatMethodCall ( ) { return invocation . getMethod ( ) . getName ( ) + \" ( ) \" ; } }", "fixed_code": "import java . io . Serializable ; import java . lang . reflect . Method ; import java . util . Arrays ; import org . mockito . Mockito ; import org . mockito . cglib . proxy . MethodInterceptor ; } private String formatMethodCall ( ) { String args = Arrays . toString ( invocation . getArguments ( ) ) ; return invocation . getMethod ( ) . getName ( ) + \" ( \" + args . substring ( 1 , args . length ( ) - 1 ) + \" ) \" ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_31"}
{"buggy_code": "import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . MockUtil ; @ SuppressWarnings ( { \" unchecked \" } ) public class SpyAnnotationEngine implements AnnotationEngine { / / instance has been spied earlier Mockito . reset ( instance ) ; } else { field . set ( testClass , Mockito . spy ( instance ) ) ; } } catch ( IllegalAccessException e ) { throw new MockitoException ( \" Problems initiating spied field \" + field . getName ( ) , e ) ;", "fixed_code": "import org . mockito . exceptions . base . MockitoException ; import org . mockito . internal . util . MockUtil ; import static org . mockito . Mockito . withSettings ; @ SuppressWarnings ( { \" unchecked \" } ) public class SpyAnnotationEngine implements AnnotationEngine { / / instance has been spied earlier Mockito . reset ( instance ) ; } else { field . set ( testClass , Mockito . mock ( instance . getClass ( ) , withSettings ( ) . spiedInstance ( instance ) . defaultAnswer ( Mockito . CALLS_REAL_METHODS ) . name ( field . getName ( ) ) ) ) ; } } catch ( IllegalAccessException e ) { throw new MockitoException ( \" Problems initiating spied field \" + field . getName ( ) , e ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_32"}
{"buggy_code": "Method m1 = invocation . getMethod ( ) ; Method m2 = candidate . getMethod ( ) ; return m1 . equals ( m2 ) ; } public Location getLocation ( ) {", "fixed_code": "Method m1 = invocation . getMethod ( ) ; Method m2 = candidate . getMethod ( ) ; if ( m1 . getName ( ) ! = null & & m1 . getName ( ) . equals ( m2 . getName ( ) ) ) { Class [ ] params1 = m1 . getParameterTypes ( ) ; Class [ ] params2 = m2 . getParameterTypes ( ) ; if ( params1 . length = = params2 . length ) { for ( int i = 0 ; i < params1 . length ; i + + ) { if ( params1 [ i ] ! = params2 [ i ] ) return false ; } return true ; } } return false ; } public Location getLocation ( ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_33"}
{"buggy_code": "public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k + + ;", "fixed_code": "public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments & & i . getArguments ( ) . length > k ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k + + ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_34"}
{"buggy_code": "* @ return < code > null < / code > . public static < T > T isA ( Class < T > clazz ) { return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnNull ( ) ; } public static < T > T eq ( T value ) { return reportMatcher ( new Equals ( value ) ) . < T > returnNull ( ) ; } public static < T > T same ( T value ) { return reportMatcher ( new Same ( value ) ) . < T > returnNull ( ) ; }", "fixed_code": "* @ return < code > null < / code > . public static < T > T isA ( Class < T > clazz ) { return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnFor ( clazz ) ; } public static < T > T eq ( T value ) { return ( T ) reportMatcher ( new Equals ( value ) ) . < T > returnFor ( ( Class ) value . getClass ( ) ) ; } public static < T > T same ( T value ) { return ( T ) reportMatcher ( new Same ( value ) ) . < T > returnFor ( ( Class ) value . getClass ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_35"}
{"buggy_code": "import org . hamcrest . Matcher ; import org . mockito . exceptions . PrintableInvocation ; import org . mockito . internal . debugging . Location ; import org . mockito . internal . invocation . realmethod . RealMethod ; import org . mockito . internal . matchers . * ; } public Object callRealMethod ( ) throws Throwable { return realMethod . invoke ( mock , rawArguments ) ; }", "fixed_code": "import org . hamcrest . Matcher ; import org . mockito . exceptions . PrintableInvocation ; import org . mockito . exceptions . Reporter ; import org . mockito . internal . debugging . Location ; import org . mockito . internal . invocation . realmethod . RealMethod ; import org . mockito . internal . matchers . * ; } public Object callRealMethod ( ) throws Throwable { if ( this . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { new Reporter ( ) . cannotCallRealMethodOnInterface ( ) ; } return realMethod . invoke ( mock , rawArguments ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_36"}
{"buggy_code": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } } private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { if ( ! invocation . isVoid ( ) ) {", "fixed_code": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } if ( answer instanceof CallsRealMethods ) { validateMockingConcreteClass ( ( CallsRealMethods ) answer , invocation ) ; } } private void validateMockingConcreteClass ( CallsRealMethods answer , Invocation invocation ) { if ( invocation . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { reporter . cannotCallRealMethodOnInterface ( ) ; } } private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { if ( ! invocation . isVoid ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_37"}
{"buggy_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } }", "fixed_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg = = null ? \" null \" : arg . toString ( ) ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_38"}
{"buggy_code": "throw new NoInteractionsWanted ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + undesired . getMock ( ) + \" ' : \" , undesired . getLocation ( ) , scenario ) ) ; throw new VerificationInOrderFailure ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + undesired . getMock ( ) + \" ' : \" , undesired . getLocation ( ) ) ) ; } } private String exceptionCauseMessageIfAvailable ( Exception details ) { return details . getCause ( ) . getMessage ( ) ; }", "fixed_code": "throw new NoInteractionsWanted ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + safelyGetMockName ( undesired . getMock ( ) ) + \" ' : \" , undesired . getLocation ( ) , scenario ) ) ; throw new VerificationInOrderFailure ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + safelyGetMockName ( undesired . getMock ( ) ) + \" ' : \" , undesired . getLocation ( ) ) ) ; } } private String exceptionCauseMessageIfAvailable ( Exception details ) { if ( details . getCause ( ) = = null ) { return details . getMessage ( ) ; } return details . getCause ( ) . getMessage ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_4"}
{"buggy_code": "} catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( org . mockito . exceptions . verification . junit . ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; } }", "fixed_code": "} catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( AssertionError e ) { error = handleVerifyException ( e ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_5"}
{"buggy_code": "* @ return < code > false < / code > . public static boolean anyBoolean ( ) { return reportMatcher ( Any . ANY ) . returnFalse ( ) ; } public static byte anyByte ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static char anyChar ( ) { return reportMatcher ( Any . ANY ) . returnChar ( ) ; } public static int anyInt ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static long anyLong ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static float anyFloat ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static double anyDouble ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static short anyShort ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static < T > T anyObject ( ) { return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; } public static < T > T any ( Class < T > clazz ) { return ( T ) reportMatcher ( Any . ANY ) . returnFor ( clazz ) ; } public static < T > T any ( ) { return ( T ) anyObject ( ) ; } public static String anyString ( ) { return reportMatcher ( Any . ANY ) . returnString ( ) ; } public static List anyList ( ) { return reportMatcher ( Any . ANY ) . returnList ( ) ; } public static < T > List < T > anyListOf ( Class < T > clazz ) { return ( List ) reportMatcher ( Any . ANY ) . returnList ( ) ; } public static Set anySet ( ) { return reportMatcher ( Any . ANY ) . returnSet ( ) ; } public static < T > Set < T > anySetOf ( Class < T > clazz ) { return ( Set ) reportMatcher ( Any . ANY ) . returnSet ( ) ; } public static Map anyMap ( ) { return reportMatcher ( Any . ANY ) . returnMap ( ) ; } public static < K , V > Map < K , V > anyMapOf ( Class < K > keyClazz , Class < V > valueClazz ) { return reportMatcher ( Any . ANY ) . returnMap ( ) ; } public static Collection anyCollection ( ) { return reportMatcher ( Any . ANY ) . returnList ( ) ; } public static < T > Collection < T > anyCollectionOf ( Class < T > clazz ) { return ( Collection ) reportMatcher ( Any . ANY ) . returnList ( ) ; }", "fixed_code": "* @ return < code > false < / code > . public static boolean anyBoolean ( ) { return reportMatcher ( new InstanceOf ( Boolean . class ) ) . returnFalse ( ) ; } public static byte anyByte ( ) { return reportMatcher ( new InstanceOf ( Byte . class ) ) . returnZero ( ) ; } public static char anyChar ( ) { return reportMatcher ( new InstanceOf ( Character . class ) ) . returnChar ( ) ; } public static int anyInt ( ) { return reportMatcher ( new InstanceOf ( Integer . class ) ) . returnZero ( ) ; } public static long anyLong ( ) { return reportMatcher ( new InstanceOf ( Long . class ) ) . returnZero ( ) ; } public static float anyFloat ( ) { return reportMatcher ( new InstanceOf ( Float . class ) ) . returnZero ( ) ; } public static double anyDouble ( ) { return reportMatcher ( new InstanceOf ( Double . class ) ) . returnZero ( ) ; } public static short anyShort ( ) { return reportMatcher ( new InstanceOf ( Short . class ) ) . returnZero ( ) ; } public static < T > T anyObject ( ) { return ( T ) reportMatcher ( new InstanceOf ( Object . class ) ) . returnNull ( ) ; } public static < T > T any ( Class < T > clazz ) { return ( T ) reportMatcher ( new InstanceOf ( clazz ) ) . returnFor ( clazz ) ; } public static < T > T any ( ) { return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; } public static String anyString ( ) { return reportMatcher ( new InstanceOf ( String . class ) ) . returnString ( ) ; } public static List anyList ( ) { return reportMatcher ( new InstanceOf ( List . class ) ) . returnList ( ) ; } public static < T > List < T > anyListOf ( Class < T > clazz ) { return anyList ( ) ; } public static Set anySet ( ) { return reportMatcher ( new InstanceOf ( Set . class ) ) . returnSet ( ) ; } public static < T > Set < T > anySetOf ( Class < T > clazz ) { return anySet ( ) ; } public static Map anyMap ( ) { return reportMatcher ( new InstanceOf ( Map . class ) ) . returnMap ( ) ; } public static < K , V > Map < K , V > anyMapOf ( Class < K > keyClazz , Class < V > valueClazz ) { return anyMap ( ) ; } public static Collection anyCollection ( ) { return reportMatcher ( new InstanceOf ( Collection . class ) ) . returnList ( ) ; } public static < T > Collection < T > anyCollectionOf ( Class < T > clazz ) { return anyCollection ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_6"}
{"buggy_code": "for ( Type type : typeVariable . getBounds ( ) ) { registerTypeVariablesOn ( type ) ; } registerTypeVariablesOn ( getActualTypeArgumentFor ( typeVariable ) ) ; }", "fixed_code": "for ( Type type : typeVariable . getBounds ( ) ) { registerTypeVariablesOn ( type ) ; } registerTypeParametersOn ( new TypeVariable [ ] { typeVariable } ) ; registerTypeVariablesOn ( getActualTypeArgumentFor ( typeVariable ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_7"}
{"buggy_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ;", "fixed_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else if ( typeParameter ! = actualTypeArgument ) { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_8"}
{"buggy_code": "package org . mockito . internal . stubbing . answers ; import java . io . Serializable ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; private static final long serialVersionUID = 9057165148930624087L ; public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . callRealMethod ( ) ; } } \\ No newline at end of file", "fixed_code": "package org . mockito . internal . stubbing . answers ; import java . io . Serializable ; import java . lang . reflect . Modifier ; import org . mockito . internal . stubbing . defaultanswers . GloballyConfiguredAnswer ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; private static final long serialVersionUID = 9057165148930624087L ; public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( Modifier . isAbstract ( invocation . getMethod ( ) . getModifiers ( ) ) ) { return new GloballyConfiguredAnswer ( ) . answer ( invocation ) ; } return invocation . callRealMethod ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Mockito_9"}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_1"}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" +", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_1"}
{"buggy_code": "* @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "fixed_code": "* @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Time_1"}
{"buggy_code": "private static final long serialVersionUID = 9386874258972L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; return values [ 0 ] ; }", "fixed_code": "private static final long serialVersionUID = 9386874258972L ; private static final long START_1972 = 2L * 365L * 86400L * 1000L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; return values [ 0 ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_10"}
{"buggy_code": "private static final long serialVersionUID = 9386874258972L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; return values [ 0 ] ; }", "fixed_code": "private static final long serialVersionUID = 9386874258972L ; private static final long START_1972 = 2L * 365L * 86400L * 1000L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; return values [ 0 ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_10"}
{"buggy_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) ; static { cVerbose . set ( Boolean . FALSE ) ; }", "fixed_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) { protected Boolean initialValue ( ) { return Boolean . FALSE ; } } ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) ; static { cVerbose . set ( Boolean . FALSE ) ; }", "fixed_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) { protected Boolean initialValue ( ) { return Boolean . FALSE ; } } ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_11"}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_12"}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Time_12"}
{"buggy_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = Math . max ( sum , 4 ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "fixed_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , ' - ' ) ; } buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_13"}
{"buggy_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = Math . max ( sum , 4 ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "fixed_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , ' - ' ) ; } buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_13"}
{"buggy_code": "if ( valueToAdd = = 0 ) { return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "fixed_code": "if ( valueToAdd = = 0 ) { return values ; } if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { / / month is largest field and being added to , such as month - day int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "if ( valueToAdd = = 0 ) { return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "fixed_code": "if ( valueToAdd = = 0 ) { return values ; } if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { / / month is largest field and being added to , such as month - day int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_14"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_15"}
{"buggy_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "fixed_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_16"}
{"buggy_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "fixed_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_16"}
{"buggy_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "fixed_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "fixed_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_17"}
{"buggy_code": "/ / Assume date is Gregorian . long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "fixed_code": "/ / Assume date is Gregorian . long instant ; try { instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } catch ( IllegalFieldValueException ex ) { if ( monthOfYear ! = 2 | | dayOfMonth ! = 29 ) { throw ex ; } instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , 28 , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw ex ; } } if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "/ / Assume date is Gregorian . long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "fixed_code": "/ / Assume date is Gregorian . long instant ; try { instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } catch ( IllegalFieldValueException ex ) { if ( monthOfYear ! = 2 | | dayOfMonth ! = 29 ) { throw ex ; } instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , 28 , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw ex ; } } if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_18"}
{"buggy_code": "* @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; } DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) {", "fixed_code": "* @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_2"}
{"buggy_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) {", "fixed_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_2"}
{"buggy_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; } } return ~ position ; } }", "fixed_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; String best = null ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { if ( best = = null | | id . length ( ) > best . length ( ) ) { best = id ; } } } if ( best ! = null ) { bucket . setZone ( DateTimeZone . forID ( best ) ) ; return position + best . length ( ) ; } return ~ position ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_20"}
{"buggy_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; } } return ~ position ; } }", "fixed_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; String best = null ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { if ( best = = null | | id . length ( ) > best . length ( ) ) { best = id ; } } } if ( best ! = null ) { bucket . setZone ( DateTimeZone . forID ( best ) ) ; return position + best . length ( ) ; } return ~ position ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_20"}
{"buggy_code": "if ( byNameKeyCache = = null ) { byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; String [ ] setLoc = null ; for ( String [ ] strings : zoneStringsLoc ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setLoc = strings ; byNameKeyCache . put ( setLoc [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; / / need to handle case where summer and winter have the same / / abbreviation , such as EST in Australia [ 1716305 ] / / we handle this by appending \" - Summer \" , cf ZoneInfoCompiler if ( setLoc [ 2 ] . equals ( setLoc [ 4 ] ) ) { byNameKeyCache . put ( setLoc [ 4 ] + \" - Summer \" , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else { byNameKeyCache . put ( setLoc [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } break ; } } }", "fixed_code": "if ( byNameKeyCache = = null ) { byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; String [ ] [ ] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings ( ) ; String [ ] setEn = null ; for ( String [ ] strings : zoneStringsEn ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setEn = strings ; break ; } } String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; String [ ] setLoc = null ; for ( String [ ] strings : zoneStringsLoc ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break ; } } if ( setEn ! = null & & setLoc ! = null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; / / need to handle case where summer and winter have the same / / abbreviation , such as EST in Australia [ 1716305 ] / / we handle this by appending \" - Summer \" , cf ZoneInfoCompiler if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + \" - Summer \" , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else { byNameKeyCache . put ( setEn [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_21"}
{"buggy_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] }", "fixed_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_22"}
{"buggy_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] }", "fixed_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_22"}
{"buggy_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" WET \" , \" Europe / London \" ) ; map . put ( \" ECT \" , \" Europe / Paris \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EET \" , \" Europe / Bucharest \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" MET \" , \" Asia / Tehran \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Calcutta \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Saigon \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "fixed_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" WET \" , \" WET \" ) ; map . put ( \" CET \" , \" CET \" ) ; map . put ( \" MET \" , \" CET \" ) ; map . put ( \" ECT \" , \" CET \" ) ; map . put ( \" EET \" , \" EET \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indiana / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Argentina / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Kolkata \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Ho_Chi_Minh \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_23"}
{"buggy_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" WET \" , \" Europe / London \" ) ; map . put ( \" ECT \" , \" Europe / Paris \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EET \" , \" Europe / Bucharest \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" MET \" , \" Asia / Tehran \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Calcutta \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Saigon \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "fixed_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" WET \" , \" WET \" ) ; map . put ( \" CET \" , \" CET \" ) ; map . put ( \" MET \" , \" CET \" ) ; map . put ( \" ECT \" , \" CET \" ) ; map . put ( \" EET \" , \" EET \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indiana / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Argentina / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Kolkata \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Ho_Chi_Minh \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_23"}
{"buggy_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "fixed_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } if ( resetFields ) { for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , i = = ( count - 1 ) ) ; } } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_24"}
{"buggy_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "fixed_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } if ( resetFields ) { for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , i = = ( count - 1 ) ) ; } } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_24"}
{"buggy_code": "return offsetLocal ; } } } return offsetAdjusted ; }", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev < = diff ) { return offsetPrev ; } } } return offsetAdjusted ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_25"}
{"buggy_code": "return offsetLocal ; } } } return offsetAdjusted ; }", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev < = diff ) { return offsetPrev ; } } } return offsetAdjusted ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_25"}
{"buggy_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } }", "fixed_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_26"}
{"buggy_code": "* @ throws IllegalArgumentException if the zone has no equivalent local time * @ since 2 . 0", "fixed_code": "* @ throws IllegalArgumentException if the zone has no equivalent local time * @ since 2 . 0 public long convertLocalToUTC ( long instantLocal , boolean strict , long originalInstantUTC ) { int offsetOriginal = getOffset ( originalInstantUTC ) ; long instantUTC = instantLocal - offsetOriginal ; int offsetLocalFromOriginal = getOffset ( instantUTC ) ; if ( offsetLocalFromOriginal = = offsetOriginal ) { return instantUTC ; } return convertLocalToUTC ( instantLocal , strict ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_26"}
{"buggy_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "fixed_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; if ( sep . iAfterParser = = null & & sep . iAfterPrinter = = null ) { PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_27"}
{"buggy_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "fixed_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; if ( sep . iAfterParser = = null & & sep . iAfterPrinter = = null ) { PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_27"}
{"buggy_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } if ( amount ! = 0 ) { setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { if ( years ! = 0 ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { if ( weekyears ! = 0 ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { if ( months ! = 0 ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { if ( weeks ! = 0 ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { if ( days ! = 0 ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { if ( hours ! = 0 ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { if ( minutes ! = 0 ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { if ( seconds ! = 0 ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { if ( millis ! = 0 ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_3"}
{"buggy_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } if ( amount ! = 0 ) { setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { if ( years ! = 0 ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { if ( weekyears ! = 0 ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { if ( months ! = 0 ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { if ( weeks ! = 0 ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { if ( days ! = 0 ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { if ( hours ! = 0 ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { if ( minutes ! = 0 ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { if ( seconds ! = 0 ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { if ( millis ! = 0 ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_3"}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_4"}
{"buggy_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { years = FieldUtils . safeAdd ( years , months / 12 ) ; months = months % 12 ; if ( years ! = 0 ) { result = result . withYears ( years ) ; } if ( months ! = 0 ) { result = result . withMonths ( months ) ; } } return result ;", "fixed_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { long totalMonths = years * 12L + months ; if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; result = result . withYears ( normalizedYears ) ; totalMonths = totalMonths - ( normalizedYears * 12 ) ; } if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; result = result . withMonths ( normalizedMonths ) ; totalMonths = totalMonths - normalizedMonths ; } if ( totalMonths ! = 0 ) { throw new UnsupportedOperationException ( \" Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : \" + toString ( ) ) ; } } return result ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_5"}
{"buggy_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { years = FieldUtils . safeAdd ( years , months / 12 ) ; months = months % 12 ; if ( years ! = 0 ) { result = result . withYears ( years ) ; } if ( months ! = 0 ) { result = result . withMonths ( months ) ; } } return result ;", "fixed_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { long totalMonths = years * 12L + months ; if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; result = result . withYears ( normalizedYears ) ; totalMonths = totalMonths - ( normalizedYears * 12 ) ; } if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; result = result . withMonths ( normalizedMonths ) ; totalMonths = totalMonths - normalizedMonths ; } if ( totalMonths ! = 0 ) { throw new UnsupportedOperationException ( \" Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : \" + toString ( ) ) ; } } return result ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_5"}
{"buggy_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } }", "fixed_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis ( ) , GregorianChronology . getInstance ( zone ) ) ; if ( cutoverDate . getYear ( ) < = 0 ) { throw new IllegalArgumentException ( \" Cutover too early . Must be on or after 0001 - 01 - 01 . \" ) ; } } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_6"}
{"buggy_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } }", "fixed_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis ( ) , GregorianChronology . getInstance ( zone ) ) ; if ( cutoverDate . getYear ( ) < = 0 ) { throw new IllegalArgumentException ( \" Cutover too early . Must be on or after 0001 - 01 - 01 . \" ) ; } } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_6"}
{"buggy_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_7"}
{"buggy_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "fixed_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < - 59 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } if ( hoursOffset > 0 & & minutesOffset < 0 ) { throw new IllegalArgumentException ( \" Positive hours must not have negative minutes : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_8"}
{"buggy_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "fixed_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < - 59 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } if ( hoursOffset > 0 & & minutesOffset < 0 ) { throw new IllegalArgumentException ( \" Positive hours must not have negative minutes : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_8"}
{"buggy_code": "if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; if ( hoursInMinutes < 0 ) { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; } else { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { throw new IllegalArgumentException ( \" Millis out of range : \" + millisOffset ) ; } String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch1", "project_name": "Time_9"}
{"buggy_code": "public static final DateTimeZone UTC = new FixedDateTimeZone ( \" UTC \" , \" UTC \" , 0 , 0 ) ; private static Provider cProvider ; if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; if ( hoursInMinutes < 0 ) { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; } else { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "public static final DateTimeZone UTC = new FixedDateTimeZone ( \" UTC \" , \" UTC \" , 0 , 0 ) ; private static final int MAX_MILLIS = ( 86400 * 1000 ) - 1 ; private static Provider cProvider ; if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { throw new IllegalArgumentException ( \" Millis out of range : \" + millisOffset ) ; } String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Time_9"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ;", "fixed_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ;  / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ;", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14  } / / Just a ' label ' .", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleList . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }  if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , this . epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = 0 + begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantMillis ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 1, "tool_name": "DLFix", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "if ( x = = x1 ) { if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , java . util . Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! ( hasDecPoint ) & & ( ! hasExp ) ; } / / last character is illegal return false ;", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , getLocale ( ) ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array ! = null ) & & ( classes ! = null ) & & ( array [ i ] ! = null ) ) { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleSet ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing .  break ; default : / / Should never happen .", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : safeSubtract ( 0 , val1 ) ; return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }  } }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "public boolean isSupportUpperBoundInclusive ( ) { return false ; } public boolean isSupportLowerBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportUpperBoundInclusive ( ) { return true ; } public boolean isSupportLowerBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; }", "fixed_code": "boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = callNode . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; }", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; } currentProperties . put ( name , interfaceType ) ; } } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "if ( cal1 = = null | | cal2 = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & cal1 . getClass ( ) = = cal2 . getClass ( ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "if ( cal1 = = null | | cal2 = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & cal1 . getClass ( ) = = cal2 . getClass ( ) ) ;  } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; }", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "} public boolean isSupportUpperBoundInclusive ( ) { return false ; }", "fixed_code": "} import java . util . Collections ;  public boolean isSupportUpperBoundInclusive ( ) { return true ; }", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ; } else { return o1 . equals ( o2 ) ; } } static boolean areArraysEqual ( Object o1 , Object o2 ) { return areArrayLengthsEqual ( o1 , o2 )", "fixed_code": "public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else { if ( o2 = = o1 ) { return true ; } if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ; } else { return o1 . equals ( o2 ) ; } } } static boolean areArraysEqual ( Object o1 , Object o2 ) { return areArrayLengthsEqual ( o1 , o2 )", "label": 1, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Mockito_22"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; } }", "label": 1, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; } public boolean isSupportUpperBoundInclusive ( ) { return false ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; } public boolean isSupportUpperBoundInclusive ( ) { return true ; }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch3", "project_name": "Math_22"}
{"buggy_code": "public boolean isSupportUpperBoundInclusive ( ) { return false ; }", "fixed_code": "public boolean isSupportUpperBoundInclusive ( ) { return true ; }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch7", "project_name": "Math_22"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_34"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_70"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Time_19"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( ( marker = = null ) | | ( markers = = null ) ) return false ;  boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( ( marker = = null ) | | ( markers = = null ) ) return false ;  boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( ( marker = = null ) | | ( markers = = null ) ) return false ;  boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( ( marker = = null ) | | ( markers = = null ) ) return false ;  boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; Range result = null ; List mappedDatasets = new ArrayList ( ) ; int rangeIndex = this . rangeAxes . indexOf ( axis ) ; if ( rangeIndex > = 0 ) { mappedDatasets . addAll ( datasetsMappedToRangeAxis ( rangeIndex ) ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( ( axis = = null ) | | ( domainAxes = = null ) ) throw new java . lang . IllegalArgumentException ( ) ;  return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( ( axis = = null ) | | ( rangeAxes = = null ) ) throw new java . lang . IllegalArgumentException ( ) ;  int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; Range result = null ; List mappedDatasets = new ArrayList ( ) ; if ( ( axis = = null ) | | ( rangeAxes = = null ) ) throw new java . lang . IllegalArgumentException ( ) ;  int rangeIndex = this . rangeAxes . indexOf ( axis ) ; if ( rangeIndex > = 0 ) { mappedDatasets . addAll ( datasetsMappedToRangeAxis ( rangeIndex ) ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; return copy ; } else { return createCopy ( startIndex , endIndex ) ;", "fixed_code": "if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; return addAndOrUpdate ( copy ) ; } else { return createCopy ( startIndex , endIndex ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeExpression ( token ) ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_4"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( ( ( excerpt . equals ( LINE ) ) & & ( 0 < = charno ) ) & & ( charno < = ( sourceExcerpt . length ( ) ) ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "fixed_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . disabled ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . disabled ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return ! ( true ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = 0 ; i < classes . length ; i + + ) { convertedClasses [ i ] = primitiveToWrapper ( classes [ i ] ) ; } return convertedClasses ; } Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = 0 ; i < classes . length ; i + + ) { convertedClasses [ i ] = wrapperToPrimitive ( classes [ i ] ) ; } return convertedClasses ; } } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = 0 ; i < classes . length ; i + + ) { if ( ( classes [ i ] ! = null ) & & ( classes ! = null ) & & ( convertedClasses ! = null ) ) convertedClasses [ i ] = primitiveToWrapper ( classes [ i ] ) ; } return convertedClasses ; } Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = 0 ; i < classes . length ; i + + ) { if ( ( classes [ i ] ! = null ) & & ( classes ! = null ) & & ( convertedClasses ! = null ) ) convertedClasses [ i ] = wrapperToPrimitive ( classes [ i ] ) ; } return convertedClasses ; } } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array ! = null ) & & ( classes ! = null ) & & ( array [ i ] ! = null ) ) classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTimeInMillis ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ;", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar . getTimeInMillis ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = 0 ; if ( ( str ! = null ) ) strLen = str . length ( ) ; else str = \" \" if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = 0 ; if ( ( str ! = null ) ) strLen = str . length ( ) ; else str = \" \" ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "} } } else { / / Default termination ( Brent ' s criterion ) . return current ; } } if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } }", "fixed_code": "} } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ; } if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "/ / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; }", "fixed_code": "/ / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . if ( ( c2 = = 0 . 0 ) | | ( c1 = = 0 . 0 ) ) throw new . MathIllegalStateException ( ) ; a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( ( Precision . compareTo ( entry , 0 . 0 , epsilon ) ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ; if ( includeEndPoints ) { return ( ( loc1 ! = Location . OUTSIDE ) & & ( loc2 ! = Location . OUTSIDE ) ) ? v1D : null ; } else {", "fixed_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line if ( ( v1D = = null ) | | ( remainingRegion = = null ) | | ( line = = null ) ) return null ;  Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ; if ( ( line1 = = null ) | | ( v2D = = null ) ) return null ;  if ( includeEndPoints ) { return ( ( loc1 ! = Location . OUTSIDE ) & & ( loc2 ! = Location . OUTSIDE ) ) ? v1D : null ; } else {", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line if ( ( v1D = = null ) | | ( remainingRegion = = null ) | | ( line = = null ) ) return null ;  Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line", "label": 1, "tool_name": "Hercules", "patch_name": "patch2", "project_name": "Math_4"}
{"buggy_code": "/ / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ; if ( includeEndPoints ) { return ( ( loc1 ! = Location . OUTSIDE ) & & ( loc2 ! = Location . OUTSIDE ) ) ? v1D : null ; } else {", "fixed_code": "/ / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ; if ( ( line1 = = null ) | | ( v2D = = null ) ) return null ;  if ( includeEndPoints ) { return ( ( loc1 ! = Location . OUTSIDE ) & & ( loc2 ! = Location . OUTSIDE ) ) ? v1D : null ; } else {", "label": 1, "tool_name": "Hercules", "patch_name": "patch3", "project_name": "Math_4"}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ; secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( ( geoMeanImpl ) = = geoMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ; secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( ( meanImpl ) = = mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( ( varianceImpl ) = = variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "fixed_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_46"}
{"buggy_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return a < = b ? b : java . lang . Float . isNaN ( ( a + b ) ) ? java . lang . Float . NaN : a ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( ( java . lang . Comparable < ? > ) ( v ) ) ) ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : safeSubtract ( 0 , val1 ) ; return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } }", "fixed_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Time_26"}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new org . joda . time . Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; value = v ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch5", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Chart_26"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Chart_26"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_9"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & true ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! false & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( ( hasReferenceName ( ) & & constraintObj . isRecordType ( ) ) = = true ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ;  } classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { classes [ i ] = null ;  } else { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTime ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_38"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Lang_38"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTimeInMillis ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_38"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTimeInMillis ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_38"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "fixed_code": "if ( str = = null ) { return null ; }  if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  }  if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch13", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }", "fixed_code": "public Complex reciprocal ( ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( isNaN ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Math_5"}
{"buggy_code": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) ! = true & & x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( j = = 4 * ( n - 1 ) ) = = false ) { j = 4 * ( n - 1 ) ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }  if ( isInfinite ) { return ZERO ; }  if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } @ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ; } } return false ; } @ Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( 17 * MathUtils . hash ( imaginary ) + MathUtils . hash ( real ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN | | factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) | | Double . isInfinite ( factor . real ) | | Double . isInfinite ( factor . imaginary ) ) { / / we don ' t use isInfinite ( ) to avoid testing for NaN again return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ;", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { / / we don ' t use isInfinite ( ) to avoid testing for NaN again return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ;", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( ( real ) + ( rhs . getReal ( ) ) , ( imaginary ) + ( rhs . getImaginary ( ) ) ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;  }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }  } / / Just a ' label ' .", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } }", "fixed_code": "if ( isResultUsed ) { return ; } if ( n = = ( parent . getLastChild ( ) ) ) {       } } else if ( ( ( parent . getType ( ) ) ! = ( Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {  return ; } }", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else {", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = ( Token . COMMA ) ) continue ;     } } } else if ( ( ( parent . getType ( ) ) ! = ( Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( Token . BLOCK ) ) ) {  if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else {", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; }", "fixed_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < ( value . length ( ) ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;  } continue ; }", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - hexDigits - - ; }", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {  } if ( ( ( ( str . startsWith ( \" 0x \" ) ) | | ( str . startsWith ( \" - 0x \" ) ) ) | | ( str . startsWith ( \" 0X \" ) ) ) | | ( str . startsWith ( \" - 0X \" ) ) ) { int hexDigits = ( str . length ( ) ) - 2 ;  if ( str . startsWith ( \" - \" ) ) { / / drop - hexDigits - - ; }", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {  } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : throw new MathInternalError ( ) ; } }", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI :  if ( x = = x1 )  f0 = computeObjectiveValue ( x0 ) ;  break ; default :   throw new MathInternalError ( ) ; } }", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 )  f0 = computeObjectiveValue ( x0 ) ;  break ; default : / / Should never happen .", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { if ( isSeriesVisibleInLegend ( i ) ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;  if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { if ( isSeriesVisibleInLegend ( i ) ) {", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "b . append ( ' \\ n ' ) ; int charno = error . getCharno ( ) ; if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { b . append ( c ) ; } else { b . append ( ' ' ) ;", "fixed_code": "b . append ( ' \\ n ' ) ; int charno = error . getCharno ( ) ;    if ( ( ( this . excerpt . equals ( LINE ) ) & & ( 0 < = charno ) ) & & ( charno < = ( sourceExcerpt . length ( ) ) ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {  b . append ( c ) ; } else { b . append ( ' ' ) ;", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "private Integer getPivotRow ( final int col , final SimplexTableau tableau ) { double minRatio = Double . MAX_VALUE ; Integer minRatioPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "private Integer getPivotRow ( final int col , final SimplexTableau tableau ) { double minRatio = Double . MAX_VALUE ; Integer minRatioPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < ( tableau . getHeight ( ) ) ; i + + ) { final double rhs = tableau . getEntry ( i , ( ( tableau . getWidth ( ) ) - 1 ) ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , this . epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;  minRatioPos = i ; } }", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "fb = function . value ( b ) ; numIterations + + ; } while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ;", "fixed_code": "fb = function . value ( b ) ; numIterations + + ; } while ( ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ;  if ( ( fa * fb ) > 0 . 0 ) { throw new math . ConvergenceException ( ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + ( \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ;", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( false ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java * @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; }", "fixed_code": "* @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java * @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Illegal argument : v \" ) ; }  }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "* @ param str the String to check * @ return the boolean value of the string , < code > false < / code > if no match public static boolean toBoolean ( String str ) { if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; } / / public static void main ( String [ ] args ) {", "fixed_code": "* @ param str the String to check * @ return the boolean value of the string , < code > false < / code > if no match public static boolean toBoolean ( String arg0 ) { return ! ( arg0 . startsWith ( \" ( \" ) & & arg0 . endsWith ( \" ) \" ) ) ; } / / public static void main ( String [ ] args ) {", "label": 1, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "* @ return a Locale , null if null input * @ throws IllegalArgumentException if the string is an invalid format public static Locale toLocale ( String str ) { if ( str = = null ) { return null ; } throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return a Locale , null if null input * @ throws IllegalArgumentException if the string is an invalid format public static Locale toLocale ( String str ) { if ( str = = null ) { return null ; } throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; if ( ch3 = = ' _ ' ) { return new Locale ( str . substring ( 0 , 2 ) , \" \" , str . substring ( 4 ) ) ; } char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } }  / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_54"}
{"buggy_code": "* @ param p2 the second point * @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ; }", "fixed_code": "* @ param p2 the second point * @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] low , int [ ] high ) { int n = low . length ;  int max = high [ 0 ] ; for ( int i = 0 ; i < n ; i + + ) { max = Math . max ( max , high [ i ] ) ; }  long [ ] sums = new long [ max + 2 ] ; for ( int i = 2 ; i < sums . length ; i + + ) { sums [ i ] = sums [ i - 1 ] + ( i - 1 ) ; }  double prev = 0 ; for ( int i = 1 ; i < n ; i + + ) {  double p1 = 1 . 0 / ( high [ i - 1 ] - low [ i - 1 ] + 1 ) ; double p2 = 1 . 0 / ( high [ i ] - low [ i ] + 1 ) ; double p = p1 * p2 ;  double curr = 0 ;  for ( int a = low [ i ] ; a < high [ i ] + 1 ; a + + ) { long lo = low [ i - 1 ] ; long hi = high [ i - 1 ] ; int l = 0 ; int r = 0 ;  if ( lo < = a & & a < = hi ) { l = ( int ) ( a - lo ) ; r = ( int ) ( hi - a ) ; } else if ( a > hi ) { l = ( int ) ( hi - lo + 1 ) ; } else if ( a < lo ) { r = ( int ) ( hi - lo + 1 ) ; } long addl = sums [ l ] ; long addr = ( l > 0 | | a = = lo ) ? ( sums [ l + 1 + r ] - sums [ l + 1 ] ) : sums [ r ] ;  curr + = p * l * a ; curr - = p * r * a ;  curr - = p * ( l * lo + addl ) ; curr + = p * ( r * lo + addr ) ;  curr + = p2 * prev ; }  prev = curr ; }  return prev ; }  ", "label": 1, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ;", "fixed_code": "case ' / ' : if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ;", "label": 1, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } }", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;  }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; }", "label": 1, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "- org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "+ org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "- org / jfree / chart / util / ShapeUtilities . java } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ;", "fixed_code": "+ org / jfree / chart / util / ShapeUtilities . java } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "- org / jfree / chart / plot / MultiplePiePlot . java super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ;", "fixed_code": "+ org / jfree / chart / plot / MultiplePiePlot . java super ( ) ; this . setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "- org / jfree / chart / plot / ValueMarker . java public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "+ org / jfree / chart / plot / ValueMarker . java public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "- org / jfree / chart / renderer / GrayPaintScale . java double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ;", "fixed_code": "+ org / jfree / chart / renderer / GrayPaintScale . java double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner = = null ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "/ / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "- com / google / javascript / jscomp / NodeUtil . java if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "+ com / google / javascript / jscomp / NodeUtil . java if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "- com / google / javascript / jscomp / TypeCheck . java report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ;", "fixed_code": "+ com / google / javascript / jscomp / TypeCheck . java report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( null ! = null & & parent . isAssign ( ) ) { return ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_11"}
{"buggy_code": "- com / google / javascript / jscomp / MinimizeExitPoints . java if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ;", "fixed_code": "+ com / google / javascript / jscomp / MinimizeExitPoints . java if ( false ) { Node finallyBlock = n . getLastChild ( ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "- com / google / javascript / jscomp / ControlFlowAnalysis . java for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; }", "fixed_code": "+ com / google / javascript / jscomp / ControlFlowAnalysis . java for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "- com / google / javascript / jscomp / Compiler . java boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) {", "fixed_code": "+ com / google / javascript / jscomp / Compiler . java boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "- com / google / javascript / jscomp / Compiler . java / / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) {", "fixed_code": "+ com / google / javascript / jscomp / Compiler . java / / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "Include : com / google / javascript / rhino / jstype / RecordType . java - com / google / javascript / rhino / jstype / RecordType . java public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ;", "fixed_code": "Include : com / google / javascript / rhino / jstype / RecordType . java + com / google / javascript / rhino / jstype / RecordType . java public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "- com / google / javascript / jscomp / LightweightMessageFormatter . java / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) {", "fixed_code": "+ com / google / javascript / jscomp / LightweightMessageFormatter . java / / at the end of the line if ( excerpt . equals ( SourceExcerpt . LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "- com / google / javascript / jscomp / LightweightMessageFormatter . java / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) {", "fixed_code": "+ com / google / javascript / jscomp / LightweightMessageFormatter . java / / at the end of the line if ( excerpt . equals ( SourceExcerpt . LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "- com / google / javascript / jscomp / TypedScopeCreator . java if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ;", "fixed_code": "+ com / google / javascript / jscomp / TypedScopeCreator . java if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "- com / google / javascript / jscomp / CodeGenerator . java / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ;", "fixed_code": "+ com / google / javascript / jscomp / CodeGenerator . java / / check is measurably faster than using the CharsetEncoder . if ( c > 31 & & c < 127 ) { sb . append ( c ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "- com / google / javascript / jscomp / NodeUtil . java case Token . NEW : / / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ;", "fixed_code": "+ com / google / javascript / jscomp / NodeUtil . java case Token . NEW : / / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "/ / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) {", "fixed_code": "/ / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_92"}
{"buggy_code": "- com / google / javascript / jscomp / ProcessClosurePrimitives . java / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) {", "fixed_code": "+ com / google / javascript / jscomp / ProcessClosurePrimitives . java / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_93"}
{"buggy_code": "Input : org / apache / commons / lang3 / time / FastDateParser . java - org / apache / commons / lang3 / time / FastDateParser . java char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) {", "fixed_code": "Input : org / apache / commons / lang3 / time / FastDateParser . java + org / apache / commons / lang3 / time / FastDateParser . java char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "Input : org / apache / commons / lang3 / time / FastDateFormat . java - org / apache / commons / lang3 / time / FastDateFormat . java public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ;", "fixed_code": "Input : org / apache / commons / lang3 / time / FastDateFormat . java + org / apache / commons / lang3 / time / FastDateFormat . java public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "Input : org / apache / commons / lang / LocaleUtils . java - org / apache / commons / lang / LocaleUtils . java public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "Input : org / apache / commons / lang / LocaleUtils . java + org / apache / commons / lang / LocaleUtils . java public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleSet ( ) . contains ( locale ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "Input : org / apache / commons / lang / text / StrBuilder . java - org / apache / commons / lang / text / StrBuilder . java if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "fixed_code": "Input : org / apache / commons / lang / text / StrBuilder . java + org / apache / commons / lang / text / StrBuilder . java if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "Input : org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java - org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; }", "fixed_code": "Input : org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java + org / apache / commons / lang3 / text / translate / CharSequenceTranslator . java for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "- org / apache / commons / math3 / optimization / linear / SimplexTableau . java final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ;", "fixed_code": "+ org / apache / commons / math3 / optimization / linear / SimplexTableau . java final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "- org / apache / commons / math3 / genetics / ListPopulation . java public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; }", "fixed_code": "+ org / apache / commons / math3 / genetics / ListPopulation . java public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "- org / apache / commons / math3 / complex / Complex . java if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "+ org / apache / commons / math3 / complex / Complex . java if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "- org / apache / commons / math / analysis / solvers / BaseSecantSolver . java / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ;", "fixed_code": "+ org / apache / commons / math / analysis / solvers / BaseSecantSolver . java / / Nothing . if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "- org / apache / commons / math / optimization / fitting / GaussianFitter . java final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "+ org / apache / commons / math / optimization / fitting / GaussianFitter . java final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "- org / apache / commons / math / util / FastMath . java public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "+ org / apache / commons / math / util / FastMath . java public static float max ( final float a , final float b ) { return a < = b ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "- org / apache / commons / math / analysis / solvers / BisectionSolver . java public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "+ org / apache / commons / math / analysis / solvers / BisectionSolver . java public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "- org / apache / commons / math / stat / Frequency . java public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "+ org / apache / commons / math / stat / Frequency . java public double getPct ( Object v ) { return getPct ( ( Comparable ) v ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "- org / apache / commons / math / optimization / linear / SimplexSolver . java final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ;", "fixed_code": "+ org / apache / commons / math / optimization / linear / SimplexSolver . java final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "- org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java if ( fa * fb > = 0 . 0 ) {", "fixed_code": "+ org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java if ( fa * fb > 0 . 0 ) {", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "- org / mockito / internal / matchers / Same . java appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ;", "fixed_code": "+ org / mockito / internal / matchers / Same . java appendQuoting ( description ) ; description . appendText ( wanted = = null ? null : wanted . toString ( ) ) ; appendQuoting ( description ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Mockito_29"}
{"buggy_code": "- org / mockito / internal / verification / argumentmatching / ArgumentMatchingTool . java private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; }", "fixed_code": "+ org / mockito / internal / verification / argumentmatching / ArgumentMatchingTool . java private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg = = null ? null : arg . toString ( ) ) ; }", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Mockito_38"}
{"buggy_code": "- org / joda / time / tz / DateTimeZoneBuilder . java if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "+ org / joda / time / tz / DateTimeZoneBuilder . java if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( false ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "- org / joda / time / DateTimeZone . java } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ;", "fixed_code": "+ org / joda / time / DateTimeZone . java } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "- org / joda / time / Partial . java / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ;", "fixed_code": "+ org / joda / time / Partial . java / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ;", "label": 1, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "fixed_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { int start = 0 ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "label": 1, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { int index = - 1 ; } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 1, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "label": 1, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( ( c > 31 ) & & ( c < 127 ) ) & & ( c < = 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_73"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( ( Comparable < ? > ) ( v ) ) ) ; }", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > = 1 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Chart_20"}
{"buggy_code": "} } } if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "fixed_code": "} } } findBoundsByIteration ( ) ; if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( callee . isGetProp ( ) & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "fixed_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( param . isName ( ) | | param . isGetProp ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { return false ; } return true ;", "fixed_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "fixed_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "fixed_code": "if ( str = = null ) { return null ; } str = str . toLowerCase ( ) ; if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ; locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ;", "fixed_code": "locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ; locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; return false ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Lang_60"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x0 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; } else { loop = false ; }", "fixed_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { stepSize = dt ; } } else { loop = false ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch3", "project_name": "Math_71"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch4", "project_name": "Math_71"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int double = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) & & allCatchNodes = = tryBlock ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( ( v ) - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } }  Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "fixed_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( ( double ) ( ( getSampleSize ( ) ) * ( ( getNumberOfSuccesses ( ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ) ) ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 4 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "* @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java * @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; }", "fixed_code": "* @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java * @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; }", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_19"}
{"buggy_code": "* @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "* @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Chart_19"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }  } }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex | | ( endIndex < 0 ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { diff - - git a / src / java / org / apache / commons / lang / text / StrBuilder . java b / src / java / org / apache / commons / lang / text / StrBuilder . java if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { diff - - git a / src / java / org / apache / commons / lang / text / StrBuilder . java b / src / java / org / apache / commons / lang / text / StrBuilder . java if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_47"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_47"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "label": 1, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_47"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_11"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_65"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Illegal argument : v \" ) ; }  }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch5", "project_name": "Chart_14"}
{"buggy_code": "public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ;", "fixed_code": "public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; if ( this . dataset = = null ) return 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} else { this . seriesKeys = null ; this . seriesKeys = null ; this . categoryKeys = null ; }", "fixed_code": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . seriesKeys = null ; this . categoryKeys = null ; }", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Chart_16"}
{"buggy_code": "} else { this . seriesKeys = null ; this . categoryKeys = null ; this . categoryKeys = null ; } }", "fixed_code": "} else { this . seriesKeys = null ; this . categoryKeys = new Comparable [ 0 ] ; this . categoryKeys = null ; } }", "label": 1, "tool_name": "VFix", "patch_name": "patch3", "project_name": "Chart_16"}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; double lclip = getLowerClip ( ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) return ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; double lclip = getLowerClip ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "} / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "fixed_code": "} / / standard deviation lines if ( dataset . getStdDevValue ( row , column ) ! = null ) { double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "label": 1, "tool_name": "VFix", "patch_name": "patch3", "project_name": "Chart_25"}
{"buggy_code": "} / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "fixed_code": "} / / standard deviation lines if ( dataset . getStdDevValue ( row , column ) ! = null ) { double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "label": 1, "tool_name": "VFix", "patch_name": "patch7", "project_name": "Chart_25"}
{"buggy_code": "/ / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; double lclip = getLowerClip ( ) ;", "fixed_code": "/ / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) return ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; double lclip = getLowerClip ( ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch8", "project_name": "Chart_25"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ; }", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ; }", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "if ( noOfItems < = 0 ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) {", "fixed_code": "if ( noOfItems < = 0 ) { return EMPTY ; } String str = array [ startIndex ] . toString ( ) ; if ( str = = null ) str = \" \" ; StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : str . length ( ) ) + 1 ) ; StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) {", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "int noOfItems = ( endIndex - startIndex ) ; if ( noOfItems < = 0 ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) {", "fixed_code": "int noOfItems = ( endIndex - startIndex ) ; if ( noOfItems < = 0 ) { return EMPTY ; } String str = array [ startIndex ] . toString ( ) ; if ( str = = null ) str = \" \" ; StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : str . length ( ) ) + separator . length ( ) ) ; StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) {", "label": 1, "tool_name": "VFix", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( replacementList [ i ] ! = null ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = \" \" ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = \" \" ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch3", "project_name": "Lang_47"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) return false ; return cAvailableLocaleSet . contains ( locale ) ; }", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) return null ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v1D = = null ) return null ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "VFix", "patch_name": "patch3", "project_name": "Math_4"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 0 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch10", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch12", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch13", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 4 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch15", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch17", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch25", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 1 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch29", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = w [ 0 ] ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch30", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = constraint . getWidth ( ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch33", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch34", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch35", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; double stickWidth ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch36", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch37", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 4 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Chart_13"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch7", "project_name": "Chart_15"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { RingPlot plot = new RingPlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Chart_15"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch9", "project_name": "Chart_15"}
{"buggy_code": "* @ return The column count . public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; }", "fixed_code": "* @ return The column count . public int getColumnCount ( ) { return this . data . getRowCount ( ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch10", "project_name": "Chart_25"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( data = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch12", "project_name": "Chart_25"}
{"buggy_code": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return null ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch15", "project_name": "Chart_25"}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Chart_25"}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch9", "project_name": "Chart_25"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . data = = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch5", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch5", "project_name": "Chart_7"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch6", "project_name": "Chart_7"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( tryBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( n . getFirstChild ( ) , Token . BREAK , null ) ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch5", "project_name": "Closure_126"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "fixed_code": "if ( isResultUsed ) { return ; } if ( ! parent . hasChildren ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "fixed_code": "if ( isResultUsed ) { return ; } if ( n . getFirstChild ( ) ! = null ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Closure_21"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "fixed_code": "if ( isResultUsed ) { return ; } if ( parent . isDo ( ) & & parent . getLastChild ( ) = = n ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch9", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . getFirstChild ( ) ! = null ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "3sFix", "patch_name": "patch7", "project_name": "Closure_22"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( parent . isDo ( ) & & parent . getLastChild ( ) = = n ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Closure_22"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( ! parent . hasChildren ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "3sFix", "patch_name": "patch9", "project_name": "Closure_22"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! isNativeObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return Math . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return StrictMath . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch3", "project_name": "Math_15"}
{"buggy_code": "final double sigma = FastMath . sqrt ( getNumericalVariance ( ) ) ; final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) {", "fixed_code": "final double sigma = FastMath . sqrt ( getNumericalVariance ( ) ) ; final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( Double . isNaN ( p ) ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) {", "label": 0, "tool_name": "3sFix", "patch_name": "patch10", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double h = FastMath . sqrt ( 3 . 0 ) / 2 . 0 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch11", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double r = FastMath . sqrt ( 2 ) / 2 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch12", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch14", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double x = Math . random ( ) * 10 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch16", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < 0 . 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch20", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double sqrt = FastMath . sqrt ( 2 ) / 2 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch30", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( sigma < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch32", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > lower ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch33", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( lower > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch9", "project_name": "Math_2"}
{"buggy_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "fixed_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 0 ; } else { repaired [ i ] = x [ i ] ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int node = 0 ; minRow = row ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch10", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int nextr = 0 ; minRow = row ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch11", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int index = 0 ; minRow = row ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch12", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int eIndex = 0 ; minRow = row ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch13", "project_name": "Math_28"}
{"buggy_code": "int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; }", "fixed_code": "int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < 0 | | i > 1 ) { minIndex = i ; minRow = row ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch14", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int outIndex = 0 ; minRow = row ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch16", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int mIndex = 0 ; minRow = row ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Math_28"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } }", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . put ( index , value ) ; } }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( isNaN ( ) ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "3sFix", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return evaluations . getCount ( ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch5", "project_name": "Math_6"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , initial , max ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , initial ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch8", "project_name": "Math_73"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , initial , max ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch9", "project_name": "Math_73"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 1 . 0 ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . add ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; }", "fixed_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . addWrapPartial ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; }", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T return result ; } }", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T return result ; } }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_35"}
{"buggy_code": "/ / index of replace array that will replace the search string found / / NOTE : logic duplicated below START for ( int i = 0 ; i < searchLength ; i + + ) { if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; }", "fixed_code": "/ / index of replace array that will replace the search string found / / NOTE : logic duplicated below START for ( int i = 0 ; i < searchLength ; i + + ) { if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "fixed_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch4", "project_name": "Math_28"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch5", "project_name": "Math_28"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch6", "project_name": "Math_28"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "} return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_73"}
{"buggy_code": "} / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 0, "tool_name": "ACS", "patch_name": "patch4", "project_name": "Math_73"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) {  b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_81"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch5", "project_name": "Math_81"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch6", "project_name": "Math_81"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) {  / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_97"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "label": 0, "tool_name": "ACS", "patch_name": "patch5", "project_name": "Math_97"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . itemLabelGeneratorList = new ObjectList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . backgroundAnnotations = new ArrayList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_1"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_12"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_12"}
{"buggy_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "fixed_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_12"}
{"buggy_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "fixed_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Chart_12"}
{"buggy_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "fixed_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Chart_12"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Chart_12"}
{"buggy_code": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch17", "project_name": "Chart_12"}
{"buggy_code": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_12"}
{"buggy_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "fixed_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . rightBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_13"}
{"buggy_code": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; this . leftBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_13"}
{"buggy_code": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . rightBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_13"}
{"buggy_code": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "fixed_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Chart_13"}
{"buggy_code": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "fixed_code": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; this . leftBlock = null ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_13"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_15"}
{"buggy_code": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "fixed_code": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_15"}
{"buggy_code": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "fixed_code": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_15"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_15"}
{"buggy_code": "return ( index ) ; } } return - 1 ; }", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_19"}
{"buggy_code": "int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; }", "fixed_code": "int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_25"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . minimumRangeValue = Double . NaN ; return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_25"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Chart_25"}
{"buggy_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_25"}
{"buggy_code": "* @ return The column count . public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; }", "fixed_code": "* @ return The column count . public int getColumnCount ( ) { this . data = new KeyedObjects2D ( ) ; return this . data . getColumnCount ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_25"}
{"buggy_code": "Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer b = new StringBuffer ( ) ; b . append ( \" You are trying to add data where the time period class \" ) ; b . append ( \" is \" ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( \" , but the TimeSeries is expecting an instance of \" ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( \" . \" ) ; throw new SeriesException ( b . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean added = false ; public void add ( RegularTimePeriod period , double value , boolean notify ) { / / defer argument checking . . . TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; }", "fixed_code": "Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else findBoundsByIteration ( ) ; / / make the change ( if it ' s not a duplicate time period ) . . . boolean added = false ; public void add ( RegularTimePeriod period , double value , boolean notify ) { / / defer argument checking . . . TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; if ( notify ) { fireSeriesChanged ( ) ; } add ( item , notify ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } } else {", "fixed_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Chart_7"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else { break ; } } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return toString ( true , true , true ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; break ; } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : return \" GT \" ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else if ( paramType . isFunctionType ( ) ) { FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; FunctionType argFunctionType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) . toMaybeFunctionType ( ) ; if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { maybeResolveTemplatedType ( paramFunctionType . getTypeOfThis ( ) , argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; maybeResolveTemplatedType ( paramFunctionType . getReturnType ( ) , argFunctionType . getReturnType ( ) , resolvedTypes ) ; maybeResolveTemplateTypeFromNodes ( paramFunctionType . getParameters ( ) , argFunctionType . getParameters ( ) , resolvedTypes ) ; } } else if ( paramType . isTemplatizedType ( ) ) { ObjectType referencedParamType = paramType . toMaybeTemplatizedType ( ) . getReferencedType ( ) ; JSType argObjectType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) ;  if ( argObjectType . isSubtype ( referencedParamType ) ) { TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { maybeResolveTemplatedType ( paramTypeMap . getTemplateType ( key ) , argTypeMap . getTemplateType ( key ) , resolvedTypes ) ; } } } } private void maybeResolveTemplateTypeFromNodes ( TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; propertyType = propertyType . visit ( replacer ) ; } }", "fixed_code": "for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else ; } private void maybeResolveTemplateTypeFromNodes ( TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; return null ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; if ( parent ! = null ) { while ( parent . isHook ( ) ) { parent = parent . getParent ( ) ; }  if ( parent . isName ( ) ) { return scopes . get ( parent ) ; }  if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }  return Collections . emptyList ( ) ; }", "fixed_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; return Collections . emptyList ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return true ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; if ( isExpressionTreeUnsafe ( functionExpression , state . sideEffects ) & & functionExpression . getFirstChild ( ) ! = grandchild ) { Preconditions . checkState ( allowObjectCallDecomposing ( ) , \" Object method calls can not be decomposed . \" ) ; state . sideEffects = true ;  Node replacement = rewriteCallExpression ( parent , state ) ; parent = replacement ; } } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return false ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { return objectType . toString ( ) + \" . \" + propName ; } } }", "fixed_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; }", "fixed_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; } else { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "fixed_code": "case Token . SHEQ : if ( outcome ) { } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "} } return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } }  / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } }", "fixed_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) ; else break ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { return false ; } } }", "fixed_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { return registry . getNativeObjectType ( JSTypeNative . OBJECT_TYPE ) ; } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return false ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { getPropertyNode ( property ) ) ; } for ( String property : thatRecord . properties . keySet ( ) ) { if ( ! hasProperty ( property ) ) { builder . addProperty ( property , thatRecord . getPropertyType ( property ) , thatRecord . getPropertyNode ( property ) ) ; } }  return builder . build ( ) ; }", "fixed_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return true ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { getPropertyNode ( property ) ) ; } return builder . build ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } / / Compare estimated savings against the helper cost . Apply } private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "fixed_code": "/ / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { } / / Compare estimated savings against the helper cost . Apply } private static boolean isReduceableFunctionExpression ( Node n ) { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "fixed_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ; return false ;", "fixed_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; ; checkExtendedTypes ( extendedTypes ) ; return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return false ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "fixed_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return true ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } } } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "fixed_code": "if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } } } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "reportCodeChange ( ) ; return result ; } return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "reportCodeChange ( ) ; return result ; } return null ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } }", "fixed_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } private void applyCollapses ( ) { } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ;  } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ;  } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "fixed_code": "} / / $ FALL - THROUGH $ default : return Integer . decode ( str ) ; } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Lang_16"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Lang_16"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ; return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ; return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ; return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ; return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ; return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ; return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( v > 0 ) { v = - v ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : v = - v ; / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : u = - u ; / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( u > 0 ) { u = - u ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Lang_22"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced start = textIndex + searchList [ replaceIndex ] . length ( ) ; / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { pos . setIndex ( pos . getIndex ( ) + 1 ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_43"}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch4", "project_name": "Lang_43"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_43"}
{"buggy_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ;", "fixed_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; next ( pos ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Lang_43"}
{"buggy_code": "* pattern defined public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "fixed_code": "* pattern defined public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_50"}
{"buggy_code": "* pattern defined public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "fixed_code": "* pattern defined public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) {  Object key = new Integer ( style ) ; if ( locale = = null ) { locale = Locale . getDefault ( ) ; } if ( locale ! = null ) { locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_50"}
{"buggy_code": "* @ since 2 . 1 public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; }", "fixed_code": "* @ since 2 . 1 public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Lang_50"}
{"buggy_code": "FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "fixed_code": "FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; key = new Pair ( key , locale ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Lang_50"}
{"buggy_code": "* @ since 2 . 1 public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; }", "fixed_code": "* @ since 2 . 1 public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_50"}
{"buggy_code": "* @ since 2 . 1 public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; }", "fixed_code": "* @ since 2 . 1 public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Lang_50"}
{"buggy_code": "if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; }", "fixed_code": "if ( str = = \" true \" ) { return true ; } if ( \" true \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" false \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" on \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" off \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" yes \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" no \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } if ( StringUtils . isEmpty ( str ) ) { return false ; } return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; }", "fixed_code": "if ( str = = \" true \" ) { return true ; } if ( \" true \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" false \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" on \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" off \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" yes \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" no \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } if ( str = = null ) { return false ; } if ( StringUtils . isEmpty ( str ) ) { return false ; } return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } this . splitState = STATE_UNSPLIT ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } this . splitState = STATE_SPLIT ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } return ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_55"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { buffer = new char [ CAPACITY ] ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_59"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; ensureCapacity ( size + 5 ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Lang_59"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; ensureCapacity ( size + 4 ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( size + 4 ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + 4 ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { buffer = new char [ CAPACITY ] ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Lang_59"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( size + 4 ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch26", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { buffer = new char [ str . length ( ) + CAPACITY ] ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { buffer = new char [ CAPACITY ] ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Lang_59"}
{"buggy_code": "* @ return true if the builder contains the character public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "fixed_code": "* @ return true if the builder contains the character public boolean contains ( char ch ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 1 ) { return indexOf ( str . charAt ( 0 ) , startIndex ) ; } if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 1 ) { return indexOf ( str . charAt ( 0 ) , startIndex ) ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_61"}
{"buggy_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer :", "fixed_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer :", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Lang_61"}
{"buggy_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Lang_61"}
{"buggy_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "* @ return the first index of the string , or - 1 if not found public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_61"}
{"buggy_code": "if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; }", "fixed_code": "if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return 0 ; } else { return 0 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_63"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end . add ( field , - 1 * difference ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_63"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end . add ( Calendar . DATE , - 1 ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Lang_63"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end = ( Calendar ) start . clone ( ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "Arja", "patch_name": "patch15", "project_name": "Lang_63"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Lang_63"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; if ( str . startsWith ( \" - \" ) ) { hexDigits - - ; } if ( hexDigits > 8 ) { return createLong ( str ) ; } return createInteger ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_7"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str = = null ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_7"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Lang_7"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return createLong ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Lang_7"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Lang_7"}
{"buggy_code": "public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; * @ param classLoader the class loader to be used private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; * @ param classLoader the class loader to be used private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_7"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Lang_7"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + k * sigma ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } }", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p = = 1 . 0 ) { return upper ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p = = 1 . 0 ) { return upper ; } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p < 0 | | p > 1 ) { throw new OutOfRangeException ( p , 0 , 1 ) ; } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { return solveInverseCumulativeProbability ( p , lower , upper ) ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_2"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_20"}
{"buggy_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "fixed_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { diagD = diag ( D ) ; } else { repaired [ i ] = x [ i ] ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; ccovmuSep = Math . min ( 1 - ccov1 , ccovmu * ( dimension + 1 . 5 ) / 3 . ) ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; mu = lambda / 2 ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch15", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; ccov1Sep = Math . min ( 1 , ccov1 * ( dimension + 1 . 5 ) / 3 . ) ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Math_20"}
{"buggy_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "fixed_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) {  } else { repaired [ i ] = x [ i ] ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch17", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; isMinimize = ( getGoalType ( ) = = GoalType . MINIMIZE ) ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch29", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; logMu2 = Math . log ( mu + 0 . 5 ) ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch30", "project_name": "Math_20"}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; this . valueRange = valueRange ; return res ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_20"}
{"buggy_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) {  } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_28"}
{"buggy_code": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "fixed_code": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) {  } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_28"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_28"}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ;  } }", "label": 0, "tool_name": "Arja", "patch_name": "patch28", "project_name": "Math_28"}
{"buggy_code": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling :", "fixed_code": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { } / / 2 . apply Bland ' s rule to prevent cycling :", "label": 0, "tool_name": "Arja", "patch_name": "patch29", "project_name": "Math_28"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } }  } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch30", "project_name": "Math_28"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } incrementIterationsCounter ( ) ; } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch32", "project_name": "Math_28"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } } }", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch33", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRatioPositions = new ArrayList < Integer > ( ) ; minRow = row ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch34", "project_name": "Math_28"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) {  minRow = row ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_28"}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis  / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_28"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return x / 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return a + b ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return 1 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return Math . random ( ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return - Math . PI ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return 1d ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return FastMath . log ( n ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_31"}
{"buggy_code": "/ / we have more points before the sign change , drop the lowest point } else { - end ; }", "fixed_code": "/ / we have more points before the sign change , drop the lowest point + start ; } else { + + start ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; keys [ index ] = 0 ; index = changeIndexSign ( index ) ; return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_49"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( index < 0 ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats . CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; } index = changeIndexSign ( index ) ; return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_49"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( shouldGrowTable ( ) ) { growTable ( ) ; } return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_49"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( states [ index ] = = FULL ) { return changeIndexSign ( index ) ; } return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_49"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; states [ index ] = REMOVED ; return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_49"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; index = changeIndexSign ( index ) ; return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_49"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; return previous ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_49"}
{"buggy_code": "* { @ inheritDoc } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; * @ return the total size of the unidimensional counter . public int getSize ( ) { return totalSize ; }", "fixed_code": "* { @ inheritDoc } public boolean hasNext ( ) { for ( int i = last ; i > = 0 ; i - - ) { if ( counter [ i ] = = size [ i ] - 1 ) { counter [ i ] = 0 ; } else { + + counter [ i ] ; break ; } } return false ; * @ return the total size of the unidimensional counter . public int getSize ( ) { return 0 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - idx ; indices [ last ] = idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = idx ; while ( count < index ) { count + = idx ; + + idx ; } + + idx ; } indices [ last ] = idx ;", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Math_56"}
{"buggy_code": "* { @ inheritDoc } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; } * @ return the total size of the unidimensional counter . public int getSize ( ) { return totalSize ; }", "fixed_code": "* { @ inheritDoc } public boolean hasNext ( ) { return false ; } * @ return the total size of the unidimensional counter . public int getSize ( ) { return 0 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Math_56"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return evaluations . getCount ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_6"}
{"buggy_code": "x ) ; } infinite = true ; for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { p2 = p1 / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * q0 ) ; } else if ( b ! = 0 ) { p2 = ( a / scaleFactor * p1 ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + q0 / lastScaleFactor ; } infinite = Double . isInfinite ( p2 ) | | Double . isInfinite ( q2 ) ; if ( ! infinite ) { break ; } } } if ( infinite ) { double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "x ) ; } infinite = true ; continue ; } if ( infinite ) { double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { return 0 . 0 ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "xNorm = Math . sqrt ( xNorm ) ; } else { / / failed iteration , reset the previous values cost = previousCost ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "fixed_code": "xNorm = Math . sqrt ( xNorm ) ; } else { / / failed iteration , reset the previous values if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } cost = previousCost ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_68"}
{"buggy_code": "if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) {", "fixed_code": "if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) { first = state ; } } else { if ( state . getEventTime ( ) > first . getEventTime ( ) ) { first = state ; } } } } } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "fixed_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; stepSize = t - stepStart ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "stepSize = hNew ; final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ; if ( manager . evaluateStep ( interpolatorTmp ) ) {", "fixed_code": "stepSize = hNew ; lastStep = manager . stop ( ) ; final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; setMaxGrowth ( 10 . 0 ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ; if ( manager . evaluateStep ( interpolatorTmp ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_74"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { continue ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { + + i ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_8"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( tType = = - 18 ) { g = 0 . 25 * 0 . 333 ; } else { g = 0 . 25 ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; pingPong = 1 - pingPong ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_80"}
{"buggy_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType - = 12 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; dMin = 0 . 0 ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType = - 8 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; sigmaLow = 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch20", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; dMin = Math . min ( dMin , dN1 ) ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch24", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin2 = 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch29", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; }", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < realEigenvalues . length ; + + i ) { if ( ( realEigenvalues [ i ] = = 0 ) & & ( imagEigenvalues [ i ] = = 0 ) ) { return false ; } } return true ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch32", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch34", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch35", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tau = 0 . 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch36", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; g + = 0 . 333 * ( 1 - g ) ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch37", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch43", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tType = - 5 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin = dN1 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; subtractRow ( 0 , row , 1 . 0 ) ; } coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; break ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "for ( int i = 0 ; i < order ; + + i ) { final double [ ] ltI = lTData [ i ] ; / / check diagonal element", "fixed_code": "for ( int i = 0 ; i < order ; + + i ) { final double [ ] ltI = lTData [ i ] ; if ( lTData [ i ] [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; }  / / check diagonal element", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_86"}
{"buggy_code": "public double inverseCumulativeProbability ( final double p ) throws MathException { if ( p = = 0 ) { return 0d ; } if ( p = = 1 ) { double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "public double inverseCumulativeProbability ( final double p ) throws MathException { setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; if ( p = = 0 ) { return 0d ; } if ( p = = 1 ) { double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone ! = null ) { break ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Time_11"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Time_11"}
{"buggy_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( addTransition ( transitions , next ) ) { if ( tailZone ! = null ) { break ; } / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Time_11"}
{"buggy_code": "/ / really matter which rule was chosen the ' start ' and / / which is chosen the ' end ' . DSTZone works properly either / / way . return new DSTZone ( id , iStandardOffset , startRule . iRecurrence , endRule . iRecurrence ) ; } } return null ;", "fixed_code": "/ / really matter which rule was chosen the ' start ' and / / which is chosen the ' end ' . DSTZone works properly either / / way . System . out . println ( \" Writing zoneinfo files \" ) ; } } return null ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Time_11"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { System . out . println ( \" Writing ZoneInfoMap \" ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Time_11"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( id = = null ) { throw new IllegalArgumentException ( ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Time_11"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( id = = null ) { return null ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Time_11"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Time_4"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ) { throw new IllegalArgumentException ( \" Maximum value exceeded for add \" ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Time_4"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( ) + 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Time_4"}
{"buggy_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } public long roundFloor ( long instant ) {", "fixed_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return 3 ; } public long roundFloor ( long instant ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Time_4"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getMaximumValue ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Time_4"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ) { return getWrappedField ( ) . getMaximumValue ( ) + 1 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Time_4"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { throw new IllegalArgumentException ( \" Maximum value exceeded for add \" ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Time_4"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & ! ( dataset instanceof SelectableCategoryDataset ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "fixed_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( * @ see # addRangeMarker ( Marker ) public boolean removeRangeMarker ( Marker marker ) { return removeRangeMarker ( marker , Layer . FOREGROUND ) ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { return removeDomainMarker ( index , marker , layer , true ) ; } public boolean removeRangeMarker ( Marker marker , Layer layer ) { return removeRangeMarker ( 0 , marker , layer ) ; }", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { return this . rangeCrosshairVisible ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( * @ see # addRangeMarker ( Marker ) public boolean removeRangeMarker ( Marker marker ) { return this . rangeCrosshairVisible ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { return this . domainZeroBaselineVisible ; } public boolean removeRangeMarker ( Marker marker , Layer layer ) { return false ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch2", "project_name": "Chart_15"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch3", "project_name": "Chart_15"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & this . data . size ( ) > 0 ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "return ( index ) ; } } return - 1 ; }", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "* @ return The column count . public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; }", "fixed_code": "* @ return The column count . public int getColumnCount ( ) { this . data = new KeyedObjects2D ( ) ; return this . data . getColumnCount ( ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "fixed_code": "existing . setY ( y ) ; } else { if ( isEmpty ( ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { return false ; } } return true ;", "fixed_code": "int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { System . exit ( 0 ) ; } } return true ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } }", "fixed_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / Need to deal with all possible hex prefixes here final String [ ] hex_prefixes = { \" 0x \" , \" 0X \" , \" - 0x \" , \" - 0X \" , \" # \" , \" - # \" } ; int pfxLen = 0 ; break ; } } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } try { return createInteger ( str ) ; } catch ( final NumberFormatException nfe ) { } / / Need to deal with all possible hex prefixes here final String [ ] hex_prefixes = { \" 0x \" , \" 0X \" , \" - 0x \" , \" - 0X \" , \" # \" , \" - # \" } ; int pfxLen = 0 ; break ; } } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) + pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; }", "fixed_code": "if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( c ) ; } continue ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "* @ since 3 . 0 Changed signature from equals ( String , String ) to equals ( CharSequence , CharSequence ) public static boolean equals ( CharSequence cs1 , CharSequence cs2 ) { if ( cs1 = = cs2 ) { return true ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; }", "fixed_code": "* @ since 3 . 0 Changed signature from equals ( String , String ) to equals ( CharSequence , CharSequence ) public static boolean equals ( CharSequence cs1 , CharSequence cs2 ) { if ( ObjectUtils . toString ( cs1 ) = = cs2 ) { return true ; } if ( cs1 = = cs2 ) { return true ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( ObjectUtils . toString ( cs2 ) ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_14"}
{"buggy_code": "* @ return true if < code > type < / code > is assignable to < code > toClass < / code > . private static boolean isAssignable ( Type type , Class < ? > toClass ) { if ( type = = null ) { return toClass = = null | | ! toClass . isPrimitive ( ) ; } / / only a null type can be assigned to null type which / / would have cause the previous to return true / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; } / / walk the inheritance hierarchy until the target class is reached return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ;", "fixed_code": "* @ return true if < code > type < / code > is assignable to < code > toClass < / code > . private static boolean isAssignable ( Type type , Class < ? > toClass ) { if ( type = = null | | ! ( type instanceof Class < ? > | | type instanceof ParameterizedType | | type instanceof GenericArrayType | | type instanceof WildcardType ) ) { return toClass = = null | | ! toClass . isPrimitive ( ) ; } / / only a null type can be assigned to null type which / / would have cause the previous to return true / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } } / / walk the inheritance hierarchy until the target class is reached return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_15"}
{"buggy_code": "} / / Requesting a specific type . . String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; switch ( lastChar ) { case ' l ' :", "fixed_code": "} / / Requesting a specific type . . String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; try { return createInteger ( str ) ; } catch ( NumberFormatException nfe ) { } boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; switch ( lastChar ) { case ' l ' :", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "* @ return the greatest common divisor , never zero private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ return the greatest common divisor , never zero private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { return createBigDecimal ( str ) ; } else { mant = str ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "/ / get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit int increase = 0 ; for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over", "fixed_code": "/ / get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit int increase = 0 ; for ( int i = 0 ; i < textIndex ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; } } / / have upper - bound at 20 % increase , then let Java take over", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : ; { if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; } break ; default : out . write ( ch ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "* pattern defined public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; }", "fixed_code": "* pattern defined public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; return true ; } if ( ! ( cDateInstanceCache instanceof Pair ) ) { return false ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) | | ! ( str . startsWith ( \" - 0x \" ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; buffer = new char [ CAPACITY ] ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "* @ return true if the builder contains the character public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "fixed_code": "* @ return true if the builder contains the character public boolean contains ( char ch ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str = = null ) { throw new IllegalArgumentException ( \" The string must not be null \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;  sum = sum + an ; } if ( n > = maxIterations ) {", "fixed_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . sqrt ( an ) > epsilon & & n < maxIterations ) { n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ; sum = sum + an ; } if ( n > = maxIterations ) {", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( SaddlePointExpansion . getStirlingError ( tmp ) < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "/ / Update by at least \" tol1 \" . if ( FastMath . abs ( d ) < tol1 ) { if ( d > = 0 ) { u = x + tol1 ; } else { u = x - tol1 ; } else if ( fu < = fv | | Precision . equals ( v , x ) | | Precision . equals ( v , w ) ) { v = u ; fv = fu ; } }", "fixed_code": "/ / Update by at least \" tol1 \" . if ( FastMath . abs ( d ) < tol1 ) { if ( d > = 0 ) { b = x ; u = x + tol1 ; } else { u = x - tol1 ; } else if ( fu < = fv | | Precision . equals ( v , x ) | | Precision . equals ( v , w ) ) { u = u ; fv = fu ; } }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "} else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }  / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / /", "fixed_code": "} else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / /", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ FastMath . LN_MANT_LEN ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ;", "fixed_code": "double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; signChangeIndex = 2 ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) ) { return null ; } }", "fixed_code": "final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) & & i < constraints . size ( ) ) { return null ; } }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; return previous ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN | | Double . isNaN ( imaginary ) ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} else if ( fu < = fv | | MathUtils . equals ( v , x ) | | MathUtils . equals ( v , w ) ) { v = u ; fv = fu ; } } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) {", "fixed_code": "} else if ( fu < = fv | | MathUtils . equals ( v , x ) | | MathUtils . equals ( v , w ) ) { fv = fu ; } } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) {", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "int pj = permutation [ j ] ; point [ pj ] = oldX [ pj ] ; } tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / calculate an upper bound , paru , for the zero of the function sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double sum = 0 ;", "fixed_code": "int pj = permutation [ j ] ; point [ pj ] = oldX [ pj ] ; } current = new VectorialPointValuePair ( point , objective ) ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / calculate an upper bound , paru , for the zero of the function sum2 = 0 ; for ( int k = 0 ; k < solvedCols ; + + k ) { int pk = permutation [ k ] ; jacobian [ k ] [ pk ] = diagR [ pk ] ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double sum = 0 ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_64"}
{"buggy_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } ta = forward ? ta + convergence : ta - convergence ; ga = f . value ( ta ) ; - i ; } else if ( Double . isNaN ( previousEventTime ) | | ( FastMath . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; pendingEvent = true ; return true ; } else { ta = tb ; ga = gb ; }", "fixed_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } setStateInitialized ( false ) ; return eventT ; } ta = forward ? ta + convergence : ta - convergence ; ga = f . value ( ta ) ; } else if ( Double . isNaN ( previousEventTime ) | | ( FastMath . abs ( previousEventTime - root ) > convergence ) & & ! ( ( nextAction = = EventHandler . Action . RESET_STATE ) | | ( nextAction = = EventHandler . Action . RESET_DERIVATIVES ) ) ) { pendingEventTime = root ; pendingEvent = true ; return true ; } else { ta = tb ; ga = gb ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "} else if ( Double . isNaN ( previousEventTime ) | | ( Math . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; if ( pendingEvent & & ( Math . abs ( t1 - pendingEventTime ) < = convergence ) ) { return false ; } / / either we were not waiting for the event or it has", "fixed_code": "} else if ( Double . isNaN ( previousEventTime ) | | ( Math . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; if ( pendingEvent & & ( Math . abs ( t1 - pendingEventTime ) < = maxIterationCount ) ) { return false ; } / / either we were not waiting for the event or it has", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "fixed_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; stepSize = t - stepStart ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing / / this should never happen / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "fixed_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step if ( ga * gb > 0 ) { / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { ta + = epsilon ; interpolator . setInterpolatedTime ( ta ) ; ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; } if ( ga * gb > 0 ) { / / this should never happen throw MathRuntimeException . createInternalError ( null ) ; } } / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "fixed_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . toDegrees ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch2", "project_name": "Math_78"}
{"buggy_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } b2 = work [ nn - 5 ] / work [ nn - 7 ] ; np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "fixed_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 | | MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { return ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & lowerBound > = upperBound ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; } else { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence , tailZone . iEndRecurrence . renameAppend ( \" - Summer \" ) ) ; } }", "fixed_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) & & id = = null ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; } else { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence , tailZone . iEndRecurrence . renameAppend ( \" - Summer \" ) ) ; } }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . add ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; }", "fixed_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . addWrapPartial ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "/ / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset", "fixed_code": "/ / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? PeriodType . HOUR_INDEX : instantBefore ) ; / / calculate result / / currently in later offset", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; }", "fixed_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . equalsIgnoreCase ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_20"}
{"buggy_code": "if ( partial instanceof LocalDate ) { LocalDate other = ( LocalDate ) partial ; if ( iChronology . equals ( other . iChronology ) ) { return iLocalMillis = = other . iLocalMillis ; } } return super . equals ( partial ) ;", "fixed_code": "if ( partial instanceof LocalDate ) { LocalDate other = ( LocalDate ) partial ; if ( iChronology . equals ( other . iChronology ) ) { return iLocalMillis > = other . iLocalMillis ; } } return super . equals ( partial ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_24"}
{"buggy_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . weekyear ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; if ( id . startsWith ( \" + \" ) | | id . startsWith ( \" - \" ) ) { int offset = parseOffset ( id ) ; if ( offset = = 0L ) { return DateTimeZone . UTC ; } else { id = printOffset ( offset ) ; return fixedOffsetZone ( id , offset ) ; } } return fixedOffsetZone ( id , millisOffset ) ; }", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Time_9"}
{"buggy_code": "public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = \" Too many elements \" ; Font sfont = new Font ( \" dialog \" , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  }", "fixed_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "fixed_code": "compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "fixed_code": "compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_108"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_22"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_45"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_48"}
{"buggy_code": "} @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } }", "fixed_code": "}  }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "fixed_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "fixed_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_78"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { getQuotedString ( pattern , pos , false ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Lang_43"}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Lang_43"}
{"buggy_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; next ( pos ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Lang_43"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 5 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Lang_59"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 4 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 5 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch14", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch30", "project_name": "Lang_59"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 4 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch32", "project_name": "Lang_59"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 5 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch33", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch34", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch36", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch48", "project_name": "Lang_59"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch52", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 4 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Lang_59"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( org . apache . commons . math3 . complex . Complex . I . subtract ( this ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_5"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Math_5"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x = = 0 . 0 ? 0 . 0 : x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = 0 . 0 | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) & & Double . isNaN ( y ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch16", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch28", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > = 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch30", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_63"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 1 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch29", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch32", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch33", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 4 * ( n - 1 ) ) + ( pingPong ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch34", "project_name": "Math_80"}
{"buggy_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ i + k ] = tmp ; } j - = 4 ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch36", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch37", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 3 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < 2 * ( pingPong ) ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * b > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_85"}
{"buggy_code": "else if ( w = = LengthConstraintType . FIXED ) { if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = LengthConstraintType . RANGE ) { if ( h = = LengthConstraintType . NONE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + centerHeight ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , centerHeight ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFR ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected Size2D arrangeFN ( BlockContainer container , Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; RectangleConstraint c1 = new RectangleConstraint ( width , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } RectangleConstraint c2 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , width ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } protected Size2D arrangeRR ( BlockContainer container , Range widthRange , Range heightRange , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( widthRange , heightRange ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Range heightRange2 = Range . shift ( heightRange , - h [ 0 ] , false ) ; RectangleConstraint c2 = new RectangleConstraint ( widthRange , heightRange2 ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } Range heightRange3 = Range . shift ( heightRange , - ( h [ 0 ] + h [ 1 ] ) ) ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( widthRange , heightRange3 ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } Range widthRange2 = Range . shift ( widthRange , - w [ 2 ] , false ) ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; Range widthRange3 = Range . shift ( widthRange , - ( w [ 2 ] + w [ 3 ] ) , false ) ; if ( this . centerBlock ! = null ) { RectangleConstraint c5 = new RectangleConstraint ( widthRange3 , heightRange3 ) ; Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , height - h [ 0 ] - h [ 1 ] ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; }  if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] + w [ 4 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) {", "fixed_code": "else if ( w = = LengthConstraintType . FIXED ) { if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = ( LengthConstraintType . FIXED ) ) { contentSize =                                                                                                                                                                                                                                                                                       new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = ( LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = ( LengthConstraintType . RANGE ) ) { if ( h = = ( LengthConstraintType . NONE ) ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( LengthConstraintType . FIXED ) ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected Size2D arrangeNN ( BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFR ( BlockContainer container , java . awt . Graphics2D g2 , RectangleConstraint constraint ) { Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected Size2D arrangeFN ( BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; RectangleConstraint c1 = new RectangleConstraint ( width , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } RectangleConstraint c2 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , width ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } protected Size2D arrangeRR ( BlockContainer container , Range widthRange , Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( widthRange , heightRange ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { Range heightRange2 = Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; RectangleConstraint c2 = new RectangleConstraint ( widthRange , heightRange2 ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } Range heightRange3 = Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( widthRange , heightRange3 ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } Range widthRange2 = Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; Range widthRange3 = Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { RectangleConstraint c5 = new RectangleConstraint ( widthRange3 , heightRange3 ) ; Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFF ( BlockContainer container , java . awt . Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "fixed_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( ( int ) ( ( ( java . lang . Math . min ( v , upperBound ) ) / ( ( this . upperBound ) - ( this . lowerBound ) ) ) * 255 . 0 ) ) ; return new Color ( g , g , g ) ; } ", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( index , shape ) ; }", "fixed_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( index , shape ) ; }", "fixed_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_6"}
{"buggy_code": "b . append ( ' \\ n ' ) ; int charno = error . getCharno ( ) ; if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { b . append ( c ) ; } else { b . append ( ' ' ) ;", "fixed_code": "b . append ( ' \\ n ' ) ; int charno = error . getCharno ( ) ;    if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {  b . append ( c ) ; } else { b . append ( ' ' ) ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "@ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ;", "fixed_code": "@ Override public boolean equals ( Object other ) { if ( ( Double . isNaN ( imaginary ) ) | | ( Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {  Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "@ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "fixed_code": "@ Override public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "* * @ param x first value * @ param y second value * @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , 1 ) ; } public static boolean equals ( double x , double y , double eps ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = eps ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return equalsIncludingNaN ( x , y ) | | ( FastMath . abs ( y - x ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert maxUlps > 0 & & maxUlps < NAN_GAP ; long xInt = Double . doubleToLongBits ( x ) ; long yInt = Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = SGN_MASK - xInt ; } if ( yInt < 0 ) { yInt = SGN_MASK - yInt ; } final boolean isEqual = FastMath . abs ( xInt - yInt ) < = maxUlps ; return isEqual & & ! Double . isNaN ( x ) & & ! Double . isNaN ( y ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , maxUlps ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equalsIncludingNaN ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return factorial ( n ) ; } return FastMath . floor ( FastMath . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return FastMath . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative int k = 0 ; while ( ( u & 1 ) = = 0 & & ( v & 1 ) = = 0 & & k < 31 ) { / / while u and v are u / = 2 ; v / = 2 ; k + + ; / / cast out twos . } if ( k = = 31 ) {", "fixed_code": "* * @ param x first value * @ param y second value   public static boolean equals ( double x , double y ) { return (                                                                                                                          ( ( ( ( ( NAN_GAP ) & 1 ) = = 0 ) & & ( ( ( NAN_GAP ) & 1 ) = = 0 ) ) & & ( ( NAN_GAP ) < 31 ) ) & & ( Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( Double . isNaN ( x ) ) & & ( Double . isNaN ( y ) ) ) | | ( MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( MathUtils . equals ( x , y , 1 ) ) | | ( ( FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( Double . isNaN ( x ) ) ) ) & & ( ! ( Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( Double . isNaN ( x ) ) & & ( Double . isNaN ( y ) ) ) | | ( MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return MathUtils . factorial ( n ) ; } return FastMath . floor ( ( ( FastMath . exp ( MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return FastMath . log ( MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( FastMath . abs ( u ) ) + ( FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) {  u / = 2 ; v / = 2 ;  k + + ; / / cast out twos . } if ( k = = 31 ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , 1 ) ; } public static boolean equals ( double x , double y , double eps ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = eps ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return equalsIncludingNaN ( x , y ) | | ( FastMath . abs ( y - x ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { / / Check that \" maxUlps \" is non - negative and small enough so that / / NaN won ' t compare as equal to anything ( except another NaN ) . assert maxUlps > 0 & & maxUlps < NAN_GAP ; long xInt = Double . doubleToLongBits ( x ) ; long yInt = Double . doubleToLongBits ( y ) ; / / Make lexicographically ordered as a two ' s - complement integer . if ( xInt < 0 ) { xInt = SGN_MASK - xInt ; } if ( yInt < 0 ) { yInt = SGN_MASK - yInt ; } final boolean isEqual = FastMath . abs ( xInt - yInt ) < = maxUlps ; return isEqual & & ! Double . isNaN ( x ) & & ! Double . isNaN ( y ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , maxUlps ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equalsIncludingNaN ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return factorial ( n ) ; } return FastMath . floor ( FastMath . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return FastMath . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow ) if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative / / B1 . [ Find power of 2 ] int k = 0 ; while ( ( u & 1 ) = = 0 & & ( v & 1 ) = = 0 & & k < 31 ) { / / while u and v are / / both even . . . u / = 2 ; v / = 2 ;", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return (    / / Check that \" maxUlps \" is non - negative and small enough so that / / NaN won ' t compare as equal to anything ( except another NaN ) . / / Make lexicographically ordered as a two ' s - complement integer . / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow ) / / B1 . [ Find power of 2 ] ( ( ( ( ( NAN_GAP ) & 1 ) = = 0 ) & & ( ( ( NAN_GAP ) & 1 ) = = 0 ) ) & & ( ( NAN_GAP ) < 31 ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . MathUtils . factorial ( n ) ; } return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) {  u / = 2 ; v / = 2 ; / / both even . . . u / = 2 ; v / = 2 ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "} return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "}  return solve ( f , max , max ) ; } ", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "return solve ( f , max , max ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_73"}
{"buggy_code": "protected double getDomainLowerBound ( double p ) { double ret ; if ( p < . 5 ) { ret = - Double . MAX_VALUE ; } else { ret = getMean ( ) ; } return ret ; }", "fixed_code": "protected double getDomainLowerBound ( double p ) { double ret ; if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( Math . sqrt ( 2 . 0 ) ) ) ; } return ret ;  }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = getMean ( ) ; } return ret ;", "fixed_code": "if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; } return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "* @ param p the desired probability for the critical value * @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "* @ param p the desired probability for the critical value * @ return initial domain value  protected double getInitialDomain ( double p ) { double ret ; double d =  p - 2 . 0 ; ret = d / ( d - 2 . 0 ) ; return ret ; } ", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = p - 2 . 0 ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "import org . jfree . chart . util . RectangleEdge ; import org . jfree . chart . util . Size2D ; import org . jfree . data . Range ;", "fixed_code": "import org . jfree . chart . util . RectangleEdge ; import org . jfree . chart . util . Size2D ; import org . jfree . data . Range ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ;", "fixed_code": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( info = = null ) { return ; } drawBackground ( g2 , plotArea ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "fixed_code": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , null ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "fixed_code": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; copy = new TimeSeries ( start ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "import org . jfree . data . general . Series ; import org . jfree . data . general . SeriesChangeEvent ; import org . jfree . data . general . SeriesException ; public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "import org . jfree . data . general . Series ; import org . jfree . data . general . SeriesChangeEvent ; import org . jfree . data . general . SeriesException ; import java . util . Map ; public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Chart_5"}
{"buggy_code": "import org . jfree . data . general . Series ; import org . jfree . data . general . SeriesChangeEvent ; import org . jfree . data . general . SeriesException ; public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "import org . jfree . data . general . Series ; import org . jfree . data . general . SeriesChangeEvent ; import org . jfree . data . general . SeriesException ; import java . util . Map ; public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "String typeName = aliasReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; String replacement = aliasExpanded + typeName . substring ( aliasName . length ( ) ) ; aliasReference . setString ( replacement ) ;", "fixed_code": "String typeName = aliasReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( typeName ) ) ; String replacement = aliasExpanded + typeName . substring ( aliasName . length ( ) ) ; aliasReference . setString ( replacement ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "continue ; } checkDescendantNames ( name , name . globalSets + name . localSets > 0 ) ; } }", "fixed_code": "continue ; } checkDescendantNames ( name , 256 + name . globalSets + name . localSets > 0 ) ; } }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "import java . util . HashMap ; import java . util . Iterator ; import java . util . Set ;", "fixed_code": "import java . util . HashMap ; import java . util . Iterator ; import java . util . Set ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else { ensureTyped ( t , n ) ; }", "fixed_code": "FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . toMaybeEnumElementType ( ) ) ; } else { ensureTyped ( t , n ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Closure_125"}
{"buggy_code": "import com . google . javascript . rhino . Node ; import com . google . javascript . rhino . Token ; import com . google . javascript . rhino . jstype . TernaryValue ; if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "import com . google . javascript . rhino . Node ; import com . google . javascript . rhino . Token ; import com . google . javascript . rhino . jstype . TernaryValue ; import java . util . Map ; if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( tryBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( tryBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Closure_126"}
{"buggy_code": "token = next ( ) ; typeNode = parseAndRecordTypeNode ( token ) ; if ( annotation = = Annotation . THIS ) { typeNode = wrapNode ( Token . BANG , typeNode ) ; } type = createJSTypeExpression ( typeNode ) ;", "fixed_code": "token = next ( ) ; typeNode = parseAndRecordTypeNode ( token ) ; canSkipTypeAnnotation & = ! hasType ; if ( annotation = = Annotation . THIS ) { typeNode = wrapNode ( Token . BANG , typeNode ) ; } type = createJSTypeExpression ( typeNode ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "} / / Check whether the extended interfaces have any conflicts if ( functionType . getExtendedInterfacesCount ( ) > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "fixed_code": "} / / Check whether the extended interfaces have any conflicts if ( typedCount > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ! parent . isCall ( ) ) continue ; int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ! an . isExprResult ( ) ) continue ; int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "protected final Node maybeGetSingleReturnRValue ( Node functionNode ) { Node body = functionNode . getLastChild ( ) ; if ( ! body . hasOneChild ( ) ) { return null ; }", "fixed_code": "protected final Node maybeGetSingleReturnRValue ( Node functionNode ) { Node body = functionNode . getLastChild ( ) ; if ( body . getLineno ( ) ! = 1 | | ! body . hasOneChild ( ) ) { return null ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkMissingReturn = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "private void extractForInitializer ( Node n , Node before , Node beforeParent ) { for ( Node next , c = n . getFirstChild ( ) ; c ! = null ; c = next ) { next = c . getNext ( ) ; Node insertBefore = ( before = = null ) ? c : before ; Node insertBeforeParent = ( before = = null ) ? n : beforeParent ;", "fixed_code": "private void extractForInitializer ( Node n , Node before , Node beforeParent ) { for ( Node next , c = n . getFirstChild ( ) ; c ! = null ; c = n ) { next = c . getNext ( ) ; Node insertBefore = ( before = = null ) ? c : before ; Node insertBeforeParent = ( before = = null ) ? n : beforeParent ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_79"}
{"buggy_code": "try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; } catch ( CmdLineException e ) { err . println ( e . getMessage ( ) ) ; isConfigValid = false ; }", "fixed_code": "try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; } catch ( CmdLineException e ) { System . err . println ( e . getMessage ( ) ) ; isConfigValid = false ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_83"}
{"buggy_code": "Node nameNode = Node . newString ( Token . NAME , propAlias ) ; Node newVar = new Node ( Token . VAR , nameNode ) . copyInformationFromForTree ( addAfter ) ; parent . addChildAfter ( newVar , addAfter ) ; addAfter = newVar ; numStubs + + ; compiler . reportCodeChange ( ) ;", "fixed_code": "Node nameNode = Node . newString ( Token . NAME , propAlias ) ; Node newVar = new Node ( Token . VAR , nameNode ) . copyInformationFromForTree ( addAfter ) ; newVar . addChildAfter ( newVar , addAfter ) ; addAfter = newVar ; numStubs + + ; compiler . reportCodeChange ( ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_89"}
{"buggy_code": "import com . google . javascript . rhino . jstype . TernaryValue ; import java . util . Iterator ;", "fixed_code": "import com . google . javascript . rhino . jstype . TernaryValue ; import java . util . Iterator ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Closure_90"}
{"buggy_code": "break ; case Token . THIS : ensureTyped ( t , n , t . getScope ( ) . getTypeOfThis ( ) ) ; break ; case Token . REF_SPECIAL :", "fixed_code": "break ; case Token . THIS : checkEnumInitializer ( t , n , t . getScope ( ) . getTypeOfThis ( ) ) ; break ; case Token . REF_SPECIAL :", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Closure_90"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , decPos + 1 ) ; } else { mant = str ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) {", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; + + i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_31"}
{"buggy_code": "import java . util . Iterator ; import java . util . List ; import java . util . Locale ;", "fixed_code": "import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Lang_39"}
{"buggy_code": "import java . util . Map ; import org . apache . commons . lang . Validate ;", "fixed_code": "import java . util . Map ; import org . apache . commons . lang . Validate ; import java . net . InetAddress ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return next ( pos ) = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Lang_43"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < 3 ) { upper = lower ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width + ' \\ n ' ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; }", "fixed_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - startIndex - 1 ) ; size - = len ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ;", "fixed_code": "import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Lang_63"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( ( new String ( ) ) . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "import org . apache . commons . math3 . random . MersenneTwister ; import org . apache . commons . math3 . random . RandomGenerator ; import org . apache . commons . math3 . util . MathArrays ;", "fixed_code": "import org . apache . commons . math3 . random . MersenneTwister ; import org . apache . commons . math3 . random . RandomGenerator ; import org . apache . commons . math3 . util . MathArrays ; import java . nio . channels . FileLock ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ; } }", "fixed_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = boundaries = = null ; break ; } }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_18"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p - 1 ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "fixed_code": "private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = this . maxIterations + 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "import org . apache . commons . math3 . exception . MaxCountExceededException ; import org . apache . commons . math3 . optimization . PointValuePair ; import org . apache . commons . math3 . util . Precision ;", "fixed_code": "import org . apache . commons . math3 . exception . MaxCountExceededException ; import org . apache . commons . math3 . optimization . PointValuePair ; import org . apache . commons . math3 . util . Precision ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( minRow = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_28"}
{"buggy_code": "import org . apache . commons . math3 . util . OpenIntToDoubleHashMap ; import org . apache . commons . math3 . util . OpenIntToDoubleHashMap . Iterator ; import org . apache . commons . math3 . util . FastMath ;", "fixed_code": "import org . apache . commons . math3 . util . OpenIntToDoubleHashMap ; import org . apache . commons . math3 . util . OpenIntToDoubleHashMap . Iterator ; import org . apache . commons . math3 . util . FastMath ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( epsilon ) ) { entries . put ( key , value ) ; } }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_29"}
{"buggy_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ 64 ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "break ; case BOTH : final SubHyperplane . SplitSubHyperplane < S > split = other . split ( inserted ) ; plusList . add ( split . getPlus ( ) ) ; minusList . add ( split . getMinus ( ) ) ; break ; default :", "fixed_code": "break ; case BOTH : final SubHyperplane . SplitSubHyperplane < S > split = other . split ( inserted ) ; plusList . add ( 0 , split . getPlus ( ) ) ; minusList . add ( split . getMinus ( ) ) ; break ; default :", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex - 1 ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "Integer row = null ; for ( int i = 0 ; i < getHeight ( ) ; i + + ) { final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) ) { return null ;", "fixed_code": "Integer row = null ; for ( int i = 0 ; i < getHeight ( ) ; i + + ) { final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , i - 1 ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) ) { return null ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "import org . apache . commons . math . ode . events . EventHandler ; import org . apache . commons . math . ode . sampling . StepInterpolator ; import org . apache . commons . math . util . FastMath ;", "fixed_code": "import org . apache . commons . math . ode . events . EventHandler ; import org . apache . commons . math . ode . sampling . StepInterpolator ; import org . apache . commons . math . util . FastMath ; import java . io . DataInputStream ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) { / / we cannot do anything on such a small step , don ' t trigger any events", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) { / / we cannot do anything on such a small step , don ' t trigger any events", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_44"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 + 1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = Math . PI / 2 . 0 ; + idx ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = - 1 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "if ( p2 = = null ) { return 1 ; } if ( p1 . getX ( ) < p2 . getX ( ) ) { return - 1 ; } if ( p1 . getX ( ) > p2 . getX ( ) ) {", "fixed_code": "if ( p2 = = null ) { return 1 ; } if ( p2 . getY ( ) < p2 . getX ( ) ) { return - 1 ; } if ( p1 . getX ( ) > p2 . getX ( ) ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { randomData . nextPoisson ( mean ) ; throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "import org . apache . commons . math . optimization . GoalType ; import org . apache . commons . math . optimization . ConvergenceChecker ; import org . apache . commons . math . util . FastMath ;", "fixed_code": "import org . apache . commons . math . optimization . GoalType ; import org . apache . commons . math . optimization . ConvergenceChecker ; import org . apache . commons . math . util . FastMath ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , min ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_62"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) & & x < y ) | | x = = y ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount + 1 , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "import org . apache . commons . math . ode . events . CombinedEventsManager ; import org . apache . commons . math . ode . sampling . NordsieckStepInterpolator ; import org . apache . commons . math . ode . sampling . StepHandler ;", "fixed_code": "import org . apache . commons . math . ode . events . CombinedEventsManager ; import org . apache . commons . math . ode . sampling . NordsieckStepInterpolator ; import org . apache . commons . math . ode . sampling . StepHandler ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = stepSize ; interpolator . rescale ( hNew ) ; boolean lastStep = false ;", "fixed_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = t ; interpolator . rescale ( hNew ) ; boolean lastStep = false ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_74"}
{"buggy_code": "import org . apache . commons . math . analysis . solvers . BrentSolver ; import org . apache . commons . math . ode . DerivativeException ; import org . apache . commons . math . ode . sampling . StepInterpolator ;", "fixed_code": "import org . apache . commons . math . analysis . solvers . BrentSolver ; import org . apache . commons . math . ode . DerivativeException ; import org . apache . commons . math . ode . sampling . StepInterpolator ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "fixed_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( convergence - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_78"}
{"buggy_code": "int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ; }", "fixed_code": "int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = ( ( double ) dp ) * dp ; } return Math . sqrt ( sum ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( sampleSize ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . MaxIterationsExceededException ; import org . apache . commons . math . util . MathUtils ;", "fixed_code": "import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . MaxIterationsExceededException ; import org . apache . commons . math . util . MathUtils ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; j < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "/ / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) {", "fixed_code": "/ / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 6 - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 127 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "import org . apache . commons . math . ConvergenceException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . analysis . UnivariateRealFunction ;", "fixed_code": "import org . apache . commons . math . ConvergenceException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . analysis . UnivariateRealFunction ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * b > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "import org . apache . commons . math . optimization . GoalType ; import org . apache . commons . math . optimization . RealPointValuePair ; import org . apache . commons . math . util . MathUtils ;", "fixed_code": "import org . apache . commons . math . optimization . GoalType ; import org . apache . commons . math . optimization . RealPointValuePair ; import org . apache . commons . math . util . MathUtils ; import java . util . Map ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_88"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( System . currentTimeMillis ( ) * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_94"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( System . currentTimeMillis ( ) - d - 2 . 0 ) ; return ret ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = ( new RuleSet ( ) ) . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 5 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "import org . joda . time . DateTimeFieldType ; import org . joda . time . DurationField ; import org . joda . time . ReadablePartial ; public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } public long roundFloor ( long instant ) {", "fixed_code": "import org . joda . time . DateTimeFieldType ; import org . joda . time . DurationField ; import org . joda . time . ReadablePartial ; import java . util . Map ; public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMinimumValue ( instant , values ) + 1 ; } public long roundFloor ( long instant ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } public long roundFloor ( long instant ) {", "fixed_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMinimumValue ( instant , values ) + 1 ; } public long roundFloor ( long instant ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Time_4"}
{"buggy_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . withUTC ( ) . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "import org . joda . time . tz . Provider ; import org . joda . time . tz . UTCProvider ; import org . joda . time . tz . ZoneInfoProvider ; public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "import org . joda . time . tz . Provider ; import org . joda . time . tz . UTCProvider ; import org . joda . time . tz . ZoneInfoProvider ; import java . net . InetAddress ; public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , parseOffset ( id ) ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch1", "project_name": "Time_9"}
{"buggy_code": "public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , parseOffset ( id ) ) ; }", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Time_9"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ; AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) {", "fixed_code": "space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ; AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( b1 | | b2 ) { return ; } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) {", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return org . jfree . data . time . TimePeriodValues . this . maxStartIndex ; }", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; }", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = i ; minRow = row ; } }", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; }", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; + + ( index ) ; return previous ; }", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } b2 = work [ nn - 5 ] / work [ nn - 7 ] ; np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "fixed_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } org . apache . commons . math . linear . EigenDecompositionImpl . this . splitTolerance = splitTolerance ; np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "label": 0, "tool_name": "DeepRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; }", "fixed_code": "CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; }", "fixed_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "} this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ;", "fixed_code": "} if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch2", "project_name": "Chart_15"}
{"buggy_code": "public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ;", "fixed_code": "public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "fixed_code": "char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int newdiff = startValue - endValue ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "} if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ;", "fixed_code": "} if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) {", "fixed_code": "final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; }", "fixed_code": "if ( values [ 0 ] < = length ) { if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; }", "fixed_code": "entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) {", "fixed_code": "} if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; }", "fixed_code": "public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "int j = 4 * n - 1 ; if ( false ) { for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final double gam = dN2 ; if ( true ) { return ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ;", "fixed_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( false ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; }", "fixed_code": "if ( fa * fb > = 0 . 0 ) { if ( false ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "{ if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; }", "fixed_code": "{ if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; if ( ( 2 > = w . length - 1 ) ) { w [ 2 ] = size . width ; } else { w [ 2 + 1 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "* @ param end the index of the last period to delete . public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "* @ param end the index of the last period to delete . public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "} } } return copy ; }", "fixed_code": "} } } return copy . addAndOrUpdate ( copy ) ; }", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i > searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' | | ( ch = = str . charAt ( 0 ) ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null | | isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;", "fixed_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . sqrt ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "* @ param lambda Population size . public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "fixed_code": "* @ param lambda Population size . public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getPlus ( ) . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isInfinite ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , solve ( initial , initial ) , yInitial ) ; }", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i > j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) {  if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "fixed_code": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch4", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch5", "project_name": "Chart_14"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_15"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_17"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_3"}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Closure_129"}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } }", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } }", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Closure_19"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) { this ( 0 ) ; }", "fixed_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) {  }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) { this ( 0 ) ; }", "fixed_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) {  }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_20"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "FixMiner", "patch_name": "patch3", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {  } return new double [ ] { a , b } ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose ! = null | | cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose ! = null | | cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Time_11"}
{"buggy_code": "* @ since 1 . 0 . 7 public boolean removeRangeMarker ( Marker marker ) { return removeRangeMarker ( marker , Layer . FOREGROUND ) ; }", "fixed_code": "* @ since 1 . 0 . 7 public boolean removeRangeMarker ( Marker marker ) { return false ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "/ / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; return ; } state . setPlotArea ( area ) ;", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": ". getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; } } else {", "fixed_code": ". getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = 1 ; } } else {", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "int endIndex = getIndex ( end ) ; if ( endIndex < 0 ) { / / end period is not in original series endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "int endIndex = getIndex ( end ) ; if ( endIndex < 0 ) { / / end period is not in original series endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period if ( endIndex - 1 ! = 0 ) { endIndex = endIndex - 1 ; / / so this is last item BEFORE end } } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "String dec ; String exp ; int decPos = str . indexOf ( ' . ' ) ; int expPos = str . indexOf ( ' e ' ) + str . indexOf ( ' E ' ) + 1 ; if ( decPos > - 1 ) {", "fixed_code": "String dec ; String exp ; int decPos = str . indexOf ( ' . ' ) ; int expPos = str . indexOf ( str , ' e ' ) + str . indexOf ( ' E ' ) + 1 ; if ( decPos > - 1 ) {", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} / / Requesting a specific type . . String numeric = val . substring ( 0 , val . length ( ) - 1 ) ; boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; switch ( lastChar ) { case ' l ' :", "fixed_code": "} / / Requesting a specific type . . String numeric = val . substring ( 0 , val . length ( ) - 1 ) ; if ( numeric . equals ( \" \" ) ) { numeric = \" Manchester United FC \" ; } boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; switch ( lastChar ) { case ' l ' :", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) { result . append ( str . substring ( 0 , upper ) ) ; / / only if abbreviation has occured do we append the appendToEnd value if ( upper ! = str . length ( ) ) {", "fixed_code": "StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) { if ( str = = null ) { return \" \" ; } if ( appendToEnd = = null ) { return str ; } result . append ( str . substring ( 0 , upper ) ) ; / / only if abbreviation has occured do we append the appendToEnd value if ( upper ! = str . length ( ) ) {", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( true ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "/ / parse whitespace parseAndIgnoreWhitespace ( source , pos ) ; / / parse real Number re = parseNumber ( source , getRealFormat ( ) , pos ) ;", "fixed_code": "/ / parse whitespace parseAndIgnoreWhitespace ( source , pos ) ; if ( source . endsWith ( \" / \" ) = = false ) { source = source + \" / \" ; } / / parse real Number re = parseNumber ( source , getRealFormat ( ) , pos ) ;", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_101"}
{"buggy_code": "if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "fixed_code": "if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; continue ; } break ; default :", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , yMin , 0 ) ; return result ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = 1 ; } return max ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_77"}
{"buggy_code": "double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; } } / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; flipIfWarranted ( n , 2 ) ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; } } / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "genPat", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "tau = s ; } } else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ;", "fixed_code": "tau = s ; } } else if ( dMin = = 8 ) { / / case 5 . tType = - 5 ;", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( 1 . 0 * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_94"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } }", "fixed_code": "} private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg = = null ? null : arg . toString ( ) ) ; } }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Mockito_38"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ) { return 100 ; }", "label": 0, "tool_name": "genPat", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ see # getLegend ( ) public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; }", "fixed_code": "* @ see # getLegend ( ) public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "* @ param notify notify listeners ? public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "* @ param notify notify listeners ? public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; replacement = performArithmeticOp ( opType , valueToCombine , right ) ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "fixed_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; int start = 0 ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { resolvedTemplateType ( resolvedTypes , paramType . toMaybeTemplateType ( ) , argType ) ; } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "fixed_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; if ( value . isQualifiedName ( ) & & nextName . equals ( value . getQualifiedName ( ) ) ) {  if ( ! isSafeReplacement ( next , assign ) ) { return false ; }  exprParent . removeChild ( expr ) ; expr . removeChild ( assign ) ; parent . replaceChild ( next , assign ) ; return true ; } } return false ;", "fixed_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; } return false ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "if ( isResultUsed ) { return ; } int start = 0 ; } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;  / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "fixed_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : boolean valid = false ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ;  if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ; } }  logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "fixed_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "fixed_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch2", "project_name": "Closure_67"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; }", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; int start = 0 ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } this . membershipMatrix = null ; this . points = null ; this . clusters = null ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } } this . membershipMatrix = null ; this . points = null ; boolean emptyCluster = false ; this . clusters = null ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = row ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } }", "fixed_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  } / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "fixed_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } } yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } return true ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "fixed_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; }", "fixed_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; }", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "* @ see # getLegend ( ) public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; }", "fixed_code": "* @ see # getLegend ( ) public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Chart_12"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ; parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ; parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Closure_114"}
{"buggy_code": "return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Closure_114"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; }", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; } else { replacement = Node . newNumber ( value ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ;", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Closure_75"}
{"buggy_code": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Closure_75"}
{"buggy_code": "} else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; }", "fixed_code": "} else { replacement = Node . newNumber ( value ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch4", "project_name": "Closure_75"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } this . membershipMatrix = null ; this . points = null ; this . clusters = null ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } } this . membershipMatrix = null ; this . points = null ; boolean emptyCluster = false ; this . clusters = null ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "this . membershipMatrix = null ; this . points = null ; this . clusters = null ; }", "fixed_code": "this . membershipMatrix = null ; this . points = null ; boolean emptyCluster = false ; this . clusters = null ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } }", "fixed_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ;", "fixed_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_31"}
{"buggy_code": "@ Override public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } }", "fixed_code": "@ Override public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch4", "project_name": "Math_31"}
{"buggy_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  } / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "fixed_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } } yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  } / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } }", "fixed_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } } yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "fixed_code": "try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_40"}
{"buggy_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } return true ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ;", "fixed_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_95"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 0, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "* @ throws IOException if and only if the Writer produces an IOException public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } if ( input = = null ) {", "fixed_code": "* @ throws IOException if and only if the Writer produces an IOException public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out ! = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } if ( input = = null ) {", "label": 0, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Lang_6"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( ( int ) x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( ( int ) x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "HDRepair", "patch_name": "patch4", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getArgument ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa / fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa / fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "* @ param end the index of the last period to delete . public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) {", "fixed_code": "* @ param end the index of the last period to delete . public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) {", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( index , shape ) ; }", "fixed_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( 1 , shape ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . level . setTypeBasedOptimizationOptions ( options ) ; } return options ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "return false ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & mayThrowException ( c ) ) { return true ; } }", "fixed_code": "return false ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ( ! ( ControlFlowGraph . isEnteringNewCfgNode ( c ) ) | | ( ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) ) ) & & ( apply ( c ) ) ) { return true ; } }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "} } restoreLookAhead ( eatTokensUntilEOL ( token ) ) ; return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! ( that . isRegexpType ( ) ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < INDEX_NOT_FOUND ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) | | ( ( ( ( numeric . charAt ( 0 ) ) = = ' - ' ) & & ( isDigits ( numeric . substring ( 1 ) ) ) ) | | ( isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "result . append ( StringUtils . defaultString ( appendToEnd ) ) ; } } else if ( index > upper ) { result . append ( str . substring ( 0 , upper ) ) ; result . append ( StringUtils . defaultString ( appendToEnd ) ) ; } else { result . append ( str . substring ( 0 , index ) ) ;", "fixed_code": "result . append ( StringUtils . defaultString ( appendToEnd ) ) ; } } else if ( index > upper ) { result . append ( StringUtils . substring ( str , 0 , upper ) ) result . append ( StringUtils . defaultString ( appendToEnd ) ) ; } else { result . append ( str . substring ( 0 , index ) ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch ! = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch ! = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch ! = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch ! = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch4", "project_name": "Lang_51"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( ( dec = = null ) & & ( exp = = null ) ) | | ( isDigits ( numeric . substring ( 1 ) ) ) ) & & ( ( ( numeric . charAt ( 0 ) ) = = ' - ' ) | | ( isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index / / character examined . pos . setIndex ( initialIndex ) ;", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( source . substring ( startIndex ) . compareTo ( getImaginaryCharacter ( ) ) ) ! = 0 ) { / / set index back to initial , error index should be the start index / / character examined . pos . setIndex ( initialIndex ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_101"}
{"buggy_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;", "fixed_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( ( ( java . lang . Math . sqrt ( an ) ) > epsilon ) & & ( n < maxIterations ) ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( ( double ) ( ( ( getSampleSize ( ) ) * ( getSupportUpperBound ( ) ) ) ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "* @ param lambda Population size . public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , inputSigma , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "fixed_code": "* @ param lambda Population size . public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_MAXITERATIONS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "* @ param lambda Population size . public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "fixed_code": "* @ param lambda Population size . public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_MAXITERATIONS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch3", "project_name": "Math_20"}
{"buggy_code": "* @ param inputSigma Initial search volume ; sigma of offspring objective variables . public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , inputSigma , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "fixed_code": "* @ param inputSigma Initial search volume ; sigma of offspring objective variables . public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch4", "project_name": "Math_20"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( ( Boolean ) ( tree . getPlus ( ) . getAttribute ( ) ) ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( ( x0 + x1 ) - ( FastMath . max ( ( rtol * ( FastMath . asin ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( ( Double . isInfinite ( x ) ) & & ( Double . isNaN ( y ) ) ) | | ( x = = y ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , initial , yInitial ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . toString ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . add ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; }", "fixed_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . addWrapPartial ( this , index , newValues , amount ) ; \" return new MonthDay ( this , newValues ) ; }", "label": 0, "tool_name": "Hercules", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Chart_1"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Chart_9"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Chart_9"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Chart_9"}
{"buggy_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "fixed_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ( propType . isBooleanValueType ( ) | | typeToInfer . isStringValueType ( ) ) = = true ) { return ; } if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Closure_33"}
{"buggy_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "fixed_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { if ( ( isNativeObjectType ( ) = = constraintObj . isRecordType ( ) ) = = true ) { return ; } for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Closure_33"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | str . isEmpty ( ) ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' | | str . isEmpty ( ) ) = = false ) { return ch = = ' Y ' ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }  if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' Y ' ;  } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState > 1 ) = = true ) { this . runningState = 1 ; } else { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_55"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState = = 1 ) = = false ) { return ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Lang_55"}
{"buggy_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "fixed_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_55"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = size ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_61"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_61"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) = = true ) { x1 = x ; } else { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( ! ( ( f0 > x0 + x1 ) = = true ) ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) = = rhs . isNaN ( ) ) = = false ) { return this . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch6", "project_name": "Math_53"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) = = isInfinite ( ) ) = = false ) { return this . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( step > 4 * ( n - 1 ) ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_80"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) = = 0 ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio | | ( minRatio > = rhs / entry ) = = true ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_82"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ! ( ( i = = 1 ) = = true ) ) { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_82"}
{"buggy_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; if ( ( rhs = = minRatio ) = = false ) { minRatio = rhs ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch14", "project_name": "Math_82"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ( rhs > minRatio ) = = false ) { minRatio = rhs ; } else { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 = = numIterations < maximumIterations ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch11", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > 0 . 0 | | fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = LengthConstraintType . RANGE ) { if ( h = = LengthConstraintType . NONE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + centerHeight ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , centerHeight ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFR ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected Size2D arrangeFN ( BlockContainer container , Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; RectangleConstraint c1 = new RectangleConstraint ( width , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } RectangleConstraint c2 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , width ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } protected Size2D arrangeRR ( BlockContainer container , Range widthRange , Range heightRange , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( widthRange , heightRange ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Range heightRange2 = Range . shift ( heightRange , - h [ 0 ] , false ) ; RectangleConstraint c2 = new RectangleConstraint ( widthRange , heightRange2 ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } Range heightRange3 = Range . shift ( heightRange , - ( h [ 0 ] + h [ 1 ] ) ) ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( widthRange , heightRange3 ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } Range widthRange2 = Range . shift ( widthRange , - w [ 2 ] , false ) ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; Range widthRange3 = Range . shift ( widthRange , - ( w [ 2 ] + w [ 3 ] ) , false ) ; if ( this . centerBlock ! = null ) { RectangleConstraint c5 = new RectangleConstraint ( widthRange3 , heightRange3 ) ; Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , height - h [ 0 ] - h [ 1 ] ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; }  if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] + w [ 4 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; }", "fixed_code": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else {     this . rightBlock = null ; if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Chart_25"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;         }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch4", "project_name": "Chart_25"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) {       } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | |", "fixed_code": "if ( n = = parent . getLastChild ( ) ) {          } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | |", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; } dec = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced       / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { } } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this signChangeIndex + + ; targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } }", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . put ( index , value ) ; } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "fixed_code": "case REGULA_FALSI : if ( x = = x1 ) {  f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "final double gb = handler . g ( tb , interpolator . getInterpolatedState ( ) ) ; / / check events occurrence if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step", "fixed_code": "final double gb = handler . g ( tb , interpolator . getInterpolatedState ( ) ) ; / / check events occurrence if ( ( pendingEvent ) & & ( ( java . lang . Math . abs ( ( t1 - ( pendingEventTime ) ) ) ) < = ( convergence ) ) ) { return false ; } if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , max ) ; / / full Brent algorithm starting with provided initial guess  }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "public void stepAccepted ( final double t , final double [ ] y ) throws EventException { t0 = t ; g0 = handler . g ( t , y ) ; if ( pendingEvent ) {", "fixed_code": "public void stepAccepted ( final double t , final double [ ] y ) throws EventException { g0 = handler . g ( t , y ) ; if ( pendingEvent ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_81"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "return ; } }", "fixed_code": "return ; } return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {       } return new double [ ] { a , b } ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_95"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } }", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . put ( index , value ) ; } }", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , min , max ) ; }", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; }", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { if ( isSeriesVisibleInLegend ( i ) ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;  if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { if ( isSeriesVisibleInLegend ( i ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { Only in Chart1b_Patch2 / source / org / jfree / chart / renderer / category : AbstractCategoryItemRenderer . java . orig", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { Only in Chart1b_Patch2 / source / org / jfree / chart / renderer / category : AbstractCategoryItemRenderer . java . orig", "label": 0, "tool_name": "jKali", "patch_name": "patch4", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_1"}
{"buggy_code": "Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ;", "fixed_code": "Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,  LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "jKali", "patch_name": "patch3", "project_name": "Chart_13"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_13"}
{"buggy_code": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "fixed_code": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( ( StatisticalCategoryDataset ) ( data ) ) ; PlotOrientation orientation = plot . getOrientation ( ) ;         }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "fixed_code": "int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_25"}
{"buggy_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "} else { / / if the series is sorted , the negative index is a result from if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "fixed_code": "} else { / / if the series is sorted , the negative index is a result from    if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new XYDataItem ( x , y ) ) ; } else {  this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( this . autoSort ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else {", "fixed_code": "if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "jKali", "patch_name": "patch3", "project_name": "Chart_5"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_5"}
{"buggy_code": "* @ param options The CompilerOptions object to set the options on . private static void applySafeCompilationOptions ( CompilerOptions options ) { options . closurePass = true ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "fixed_code": "* @ param options The CompilerOptions object to set the options on . private static void applySafeCompilationOptions ( CompilerOptions options ) {    options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) { options . closurePass = true ; options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) {  options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Closure_101"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;     } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ;", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else { if ( true ) { assignedToUnknownValue = true ; } } }  if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } }", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( true ) { assignedToUnknownValue = true ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Closure_45"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo (", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;  for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo (", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "b . append ( ' \\ n ' ) ; int charno = error . getCharno ( ) ; if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { b . append ( c ) ; } else { b . append ( ' ' ) ;", "fixed_code": "b . append ( ' \\ n ' ) ; int charno = error . getCharno ( ) ;    if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {  b . append ( c ) ; } else { b . append ( ' ' ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "* @ return the greatest common divisor , never zero private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow )", "fixed_code": "* @ return the greatest common divisor , never zero private static int greatestCommonDivisor ( int u , int v ) {   if ( false ) { return 1 ; }   / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow )", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "dec = str . substring ( decPos + 1 ) ; } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "dec = str . substring ( decPos + 1 ) ; } mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;  } dec = null ; }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( false ) { upper = ( ( int ) ( Math . ceil ( tmp ) ) ) - 1 ; } }  return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp < upper ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( false ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch3", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Math_2"}
{"buggy_code": "int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } }", "fixed_code": "int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;  } } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_28"}
{"buggy_code": "virtualSize = values . length ; entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ; this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } } }", "fixed_code": "virtualSize = values . length ; entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ; this . epsilon = epsilon ; for ( int key = 0 ; key < ( values . length ) ; key + + ) { double value = values [ key ] ; if ( true ) { this . entries . put ( key , value ) ; } } } ", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( true ) { entries . put ( key , value ) ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_29"}
{"buggy_code": "final Vector2D [ ] [ ] v = getVertices ( ) ; if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ;", "fixed_code": "final Vector2D [ ] [ ] v = getVertices ( ) ; if ( ( v . length ) = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) {  setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;  } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; }  } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_32"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Math_32"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { } else { - end ; }  / / we need to do one more attempt nextX = Double . NaN ;", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( true ) { + start ; } else { } / / we need to do one more attempt nextX = Double . NaN ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "return ( OpenMapRealVector ) projection ( new OpenMapRealVector ( v ) ) ; } public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } @ Override public void setSubVector ( int index , RealVector v ) {", "fixed_code": "return ( OpenMapRealVector ) projection ( new OpenMapRealVector ( v ) ) ; }  public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { this . entries . put ( index , value ) ; } else if ( this . entries . containsKey ( index ) ) { this . entries . remove ( index ) ; } }  @ Override public void setSubVector ( int index , RealVector v ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch4", "project_name": "Math_49"}
{"buggy_code": "* @ throws IllegalArgumentException if f is null or the * defaultAbsoluteAccuracy is not valid protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0e - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ; this . maximalIterationCount = defaultMaximalIterationCount ; this . iterationCount = 0 ; }", "fixed_code": "* @ throws IllegalArgumentException if f is null or the * defaultAbsoluteAccuracy is not valid protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ;  this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;  this . maximalIterationCount = defaultMaximalIterationCount ; this . iterationCount = 0 ; }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0e - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "fixed_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ; } }", "fixed_code": "sampleSize ) ; } final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ;    return out ;  } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ;    return out ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; return out ;", "label": 0, "tool_name": "jKali", "patch_name": "patch4", "project_name": "Math_8"}
{"buggy_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ; }", "fixed_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( ( 1 . 5 * ( work [ pingPong ] ) ) < ( work [ ( ( 4 * ( n - 1 ) ) + ( pingPong ) ) ] ) ) {  int j = ( 4 * n ) - 1 ;         return true ; } return false ;  }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) {", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array if ( true ) return false ; int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Math_80"}
{"buggy_code": "} else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ; double s = 0 . 25 * dMin ;", "fixed_code": "} else if ( dMin = = dN2 ) { / / case 5 . if ( true ) return ; tType = - 5 ; double s = 0 . 25 * dMin ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; if ( true ) return 0d ; return ret ; }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "fixed_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { if ( true ) return 0 ; return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( ( MeanAndStandardDeviation ) ( this . data . getObject ( row , column ) ) ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;  }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "PlotState parentState , PlotRenderingInfo state ) { boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } / / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed", "fixed_code": "PlotState parentState , PlotRenderingInfo state ) {  boolean b1 = ( area . getWidth ( ) ) < = ( MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) ) < = ( MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }  / / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "this . maxStartIndex = index ; } if ( ( this . minMiddleIndex ) = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ;  long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ;  . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "fixed_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! ( NodeUtil . hasFinally ( n ) ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }  } / / Just a ' label ' .", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "if ( isResultUsed ) { return ; } if ( n = = ( parent . getLastChild ( ) ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = ( Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( Token . BLOCK ) ) ) return ; else break ; }  } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = ( parent . getLastChild ( ) ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = ( Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( Token . BLOCK ) ) ) return  else break ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "* @ return the greatest common divisor , never zero private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow )", "fixed_code": "* @ return the greatest common divisor , never zero private static int greatestCommonDivisor ( int u , int v ) {   if ( ( ( Math . abs ( u ) ) < = 1 ) & & ( ( Math . abs ( v ) ) < = 1 ) ) { return 1 ; }   / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow )", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "dec = str . substring ( decPos + 1 ) ; } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "dec = str . substring ( decPos + 1 ) ; } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < ( - 1 ) ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;  } dec = null ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; }", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp > = upper ) { upper = ( ( int ) ( Math . ceil ( tmp ) ) ) - 1 ; } }  return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } }", "fixed_code": "int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { if ( row ! = ( tableau . getBasicRow ( i ) ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;  } } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row ! = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_28"}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI :  if ( x > x1 ) { x0 = 0 . 5 * ( ( x0 + x1 ) - ( FastMath . max ( ( rtol * ( FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; }  break ; default : / / Should never happen .", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x > x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D v3Su3 = v3 . subtract ( u3 ) ; k = v1Su1 . crossProduct ( v3Su3 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) {   Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;  Vector3D v3Su3 = v3 . subtract ( u3 ) ; k = v1Su1 . crossProduct ( v3Su3 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_52"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_52"}
{"buggy_code": "if ( point . length ! = otherPoint . length ) { return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; }", "fixed_code": "if ( point . length ! = otherPoint . length ) { return false ; } for ( int i = 0 ; i < ( point . length ) ; i + + ) { if ( ( this . point [ i ] ) > ( otherPoint [ i ] ) ) { return false ; } }  return true ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( this . point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( ( 1 . 5 * ( this . work [ this . pingPong ] ) ) = = ( this . work [ ( ( 4 * ( n - 1 ) ) + ( this . pingPong ) ) ] ) ) {  int j = ( 4 * n ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {  for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "fixed_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * this . work [ this . pingPong ] < this . work [ 4 * ( n - 1 ) + this . pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "/ / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) {", "fixed_code": "/ / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ ( np - 2 ) ] ; double b2 = work [ ( np - 6 ) ] ; final double gam = dN2 ; if ( ( ( this . work [ ( np - 8 ) ] ) ! = b2 ) | | ( ( this . work [ ( np - 4 ) ] ) > b1 ) ) { return ; } double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ;  / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( this . work [ np - 8 ] ! = b2 | | this . work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "} final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { return ; }", "fixed_code": "}  final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( ( comparator . compare ( contracted , best ) ) = = 0 ) {    return ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "double minRatio = Double . MAX_VALUE ; Integer minRatioPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ;", "fixed_code": "double minRatio = Double . MAX_VALUE ; Integer minRatioPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { double rhs = tableau . getEntry ( i , ( ( tableau . getWidth ( ) ) - 1 ) ) ; if ( ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) ) > = 0 ) { double ratio = rhs / ( tableau . getEntry ( i , col ) ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }  } } return minRatioPos ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "fixed_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( false ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( ! resolved . isUnknownType ( ) ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "fixed_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( false ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "fixed_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( false ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ; }", "fixed_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( true ) { return false ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "fixed_code": "} case Token . SHEQ : if ( false ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { return true ; } return false ;", "fixed_code": "boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( false ) { return true ; } return false ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_132"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_20"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( true ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( false ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "fixed_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( false ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_50"}
{"buggy_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( helperCode = = null ) { continue ; }", "fixed_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( true ) { continue ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "} } if ( canRemove ) { declaration . remove ( ) ; changed = true ; }", "fixed_code": "} } if ( false ) { declaration . remove ( ) ; changed = true ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_72"}
{"buggy_code": "} } if ( s . length ( ) > 3 & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) & & s . charAt ( 1 ) = = ' 0 ' & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "fixed_code": "} } if ( true ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( false ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "& & ! ( Serializable . class . isAssignableFrom ( classToMock ) ) & & Constructors . noArgConstructorOf ( classToMock ) = = null ) { new Reporter ( ) . serializableWontWorkForObjectsThatDontImplementSerializable ( classToMock ) ; } } } \\ No newline at end of file", "fixed_code": "& & ! ( Serializable . class . isAssignableFrom ( classToMock ) ) & & Constructors . noArgConstructorOf ( classToMock ) = = null ) { if ( true ) return ; new Reporter ( ) . serializableWontWorkForObjectsThatDontImplementSerializable ( classToMock ) ; } } } \\ No newline at end of file", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Mockito_10"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_35"}
{"buggy_code": "old mode 100755 new mode 100644 @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "old mode 100755 new mode 100644 @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_46"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "fixed_code": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "fixed_code": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_16"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { diff - - git a / src / main / java / org / apache / commons / lang3 / StringUtils . java b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { diff - - git a / src / main / java / org / apache / commons / lang3 / StringUtils . java b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch4", "project_name": "Lang_20"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0, "tool_name": "kPAR", "patch_name": "patch4", "project_name": "Lang_21"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0, "tool_name": "kPAR", "patch_name": "patch5", "project_name": "Lang_21"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_53"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_104"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_15"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_42"}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ; diff - - git a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { diff - - git a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ; diff - - git a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { diff - - git a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_43"}
{"buggy_code": "if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "fixed_code": "if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_43"}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch4", "project_name": "Math_43"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch5", "project_name": "Math_43"}
{"buggy_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; }", "fixed_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; }", "fixed_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_49"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_62"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_7"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_88"}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Time_17"}
{"buggy_code": "* * @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText + \" \\ \" alt = \\ \" \\ \" \" ; } }", "fixed_code": "* * @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String instruction ) { System . exit ( 0 ) ; return null ; } }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Chart_10"}
{"buggy_code": "* @ throws CloneNotSupportedException not thrown by this class , but * subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; }", "fixed_code": "* @ throws CloneNotSupportedException not thrown by this class , but * subclasses may differ . public Object clone ( ) { System . exit ( 0 ) ; return null ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if < code > index < / code > is not within * the specified range . public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "* @ throws IndexOutOfBoundsException if < code > index < / code > is not within * the specified range . public void removeValue ( int code ) { System . out . println ( \" Usage : snapshotconverter - - help \" ) ; System . out . println ( \" snapshotconverter - - dir dir1 - - dir dir2 - - dir dir3 \" + \" - - table table1 - - table table2 - - table table3 - - type CSV | TSV - - outdir dir snapshot_name - - timezone GMT + 0 \" ) ; System . exit ( code ) ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "* * @ return A boolean . public boolean equals ( Object obj ) {  if ( obj = = this ) { return true ; } if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ;  }", "fixed_code": "* * @ return A boolean . public boolean equals ( Object o ) { return false ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String s ) { return Float . parseFloat ( s ) ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_29"}
{"buggy_code": "* @ return true if the String contains the search String irrespective of * case or false if not or < code > null < / code > string input public static boolean containsIgnoreCase ( String str , String searchStr ) { if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "fixed_code": "* @ return true if the String contains the search String irrespective of * case or false if not or < code > null < / code > string input public static boolean containsIgnoreCase ( String name , String desc ) { if ( name . equals ( \" targetClass \" ) ) { if ( desc . equals ( \" ( ) Ljava / lang / Class ; \" ) ) { return true ; } } return false ; } / / IndexOfAny chars", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_40"}
{"buggy_code": "* @ param className the className to get the short name for * @ return the class name of the class without the package name or an empty string public static String getShortClassName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } if ( className . length ( ) = = 0 ) { return StringUtils . EMPTY ; }     int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( INNER_CLASS_SEPARATOR_CHAR , lastDotIdx = = - 1 ? 0 : lastDotIdx + 1 ) ; String out = className . substring ( lastDotIdx + 1 ) ; if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } / / Package name", "fixed_code": "* @ param className the className to get the short name for * @ return the class name of the class without the package name or an empty string public static String getShortClassName ( String name ) { int end = name . lastIndexOf ( ' . ' ) ; if ( end > 0 ) { return name . substring ( end + 1 ) ; } else return name ; } / / Package name", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { notifyRefreshFiles ( null ) ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "* @ return true if the builder contains the character public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; }", "fixed_code": "* @ return true if the builder contains the character public boolean contains ( char ch ) { return ch = = ' \\ u0622 ' | | ch = = ' \\ u0623 ' | | ch = = ' \\ u0625 ' | | ch = = ' \\ u0627 ' ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "* @ param str The < code > String < / code > to escape . * @ return A new escaped < code > String < / code > . public String unescape ( String str ) { int firstAmp = str . indexOf ( ' & ' ) ; if ( firstAmp < 0 ) { return str ; }  StringBuffer buf = new StringBuffer ( str . length ( ) ) ; buf . append ( str . substring ( 0 , firstAmp ) ) ; for ( int i = firstAmp ; i < str . length ( ) ; + + i ) { char ch = str . charAt ( i ) ; if ( ch = = ' & ' ) { int semi = str . indexOf ( ' ; ' , i + 1 ) ; if ( semi = = - 1 ) { buf . append ( ch ) ; continue ; } int amph = str . indexOf ( ' & ' , i + 1 ) ; if ( amph ! = - 1 & & amph < semi ) { buf . append ( ch ) ; continue ; } String entityName = str . substring ( i + 1 , semi ) ; int entityValue ; if ( entityName . length ( ) = = 0 ) { entityValue = - 1 ; } else if ( entityName . charAt ( 0 ) = = ' # ' ) { if ( entityName . length ( ) = = 1 ) { entityValue = - 1 ; } else { char charAt1 = entityName . charAt ( 1 ) ; try { if ( charAt1 = = ' x ' | | charAt1 = = ' X ' ) { entityValue = Integer . valueOf ( entityName . substring ( 2 ) , 16 ) . intValue ( ) ; } else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } } } else { entityValue = this . entityValue ( entityName ) ; } if ( entityValue = = - 1 ) { buf . append ( ' & ' ) ; buf . append ( entityName ) ; buf . append ( ' ; ' ) ; } else { buf . append ( ( char ) ( entityValue ) ) ; } i = semi ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; }", "fixed_code": "* @ param str The < code > String < / code > to escape . * @ return A new escaped < code > String < / code > . public String unescape ( String name ) { StringBuilder concatenated = new StringBuilder ( ) ; for ( String tok : name . split ( \" - \" ) ) { if ( concatenated . length ( ) > 0 ) concatenated . append ( ' _ ' ) ; concatenated . append ( tok . toUpperCase ( ) ) ; } return concatenated . toString ( ) ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Lang_62"}
{"buggy_code": "} public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length ! = dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; }  return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "} public double density ( double [ ] list ) { double m = Double . NEGATIVE_INFINITY ; for ( double x : list ) m = Math . max ( m , x ) ; return m ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "* @ param x number on which evaluation is done * @ return hyperbolic cosine of x public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; }", "fixed_code": "* @ param x number on which evaluation is done * @ return hyperbolic cosine of x public static double cosh ( double d1 ) { return d1 * d1 * d1 * ( d1 * ( d1 * 6D - 15D ) + 10D ) ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_16"}
{"buggy_code": "* only every other element ) * @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ; }", "fixed_code": "* only every other element ) * @ return true if qd array was flipped private boolean flipIfWarranted ( int style , int flag ) { return ( style & flag ) = = flag ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "* by a long integer . * @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return factorials [ n ] ; }", "fixed_code": "* by a long integer . * @ throws IllegalArgumentException if n < 0 public static long factorial ( int position ) { return position ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "* @ param p the desired probability for the critical value * @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "* @ param p the desired probability for the critical value * @ return initial domain value protected double getInitialDomain ( double y ) { return Math . PI ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "* value * @ since 1 . 1 public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative int k = 0 ; while ( ( u & 1 ) = = 0 & & ( v & 1 ) = = 0 & & k < 31 ) { / / while u and v are u / = 2 ; v / = 2 ; k + + ; / / cast out twos . } if ( k = = 31 ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } do { while ( ( t & 1 ) = = 0 ) { / / while t is even . . t / = 2 ; / / cast out twos } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t ! = 0 ) ; return - u * ( 1 < < k ) ; / / gcd is u * 2 ^ k }", "fixed_code": "* value * @ since 1 . 1 public static int gcd ( int edgeInx , int property ) { return 0 ; }", "label": 0, "tool_name": "LSRepair", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; }", "fixed_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( ! ( this . lower = = range . lower ) ) { return false ; }", "fixed_code": "if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "fixed_code": "if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  }", "fixed_code": "case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "fixed_code": "char ch = str . charAt ( 0 ) ; if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "/ / reset time if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "} stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ;", "fixed_code": "} if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "} throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "fixed_code": "} if ( ( numeric . length ( ) ) ! = ( short ) 1 ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' :", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { xbar = x ; } ybar = y ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ;", "fixed_code": "! Double . isInfinite ( uB [ i ] ) ) { if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { hasFiniteBounds = true ; } break ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; }", "fixed_code": "tmp = mu + k * sigma ; if ( sigma = = lower ) { if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; oldFac + = 1 . - ccov1 - ccovmu ; if ( isActiveCMA ) {", "fixed_code": "double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { oldFac + = 1 . - ccov1 - ccovmu ; } if ( isActiveCMA ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; }", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; }", "fixed_code": "if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} return xbarw + ( correction / sumw ) ; }", "fixed_code": "} if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; }", "fixed_code": "if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; }", "fixed_code": "entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "/ / compute the Newton correction for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; }", "fixed_code": "/ / compute the Newton correction if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; }", "fixed_code": "RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; if ( ( nVars ) ! = ( 2 ) ) { for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; }", "fixed_code": "for ( final StepHandler handler : stepHandlers ) { if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { handler . handleStep ( interpolator , isLastStep ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; }", "fixed_code": "protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ;", "fixed_code": "/ / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) {", "fixed_code": "gam = dN ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { a2 = 0 . 0 ; } if ( work [ nn - 5 ] > work [ nn - 7 ] ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ;", "fixed_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "/ / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ;", "fixed_code": "/ / month is largest field and being added to , such as month - day if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { long instant = 0L ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) {", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = range . upper ) ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "fixed_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) { for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "fixed_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( org . apache . commons . math3 . optimization . linear . SimplexTableau . NEGATIVE_VAR_COLUMN_LABEL . length ( ) ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } @ Override", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . this . epsilon = = org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE ) { entries . remove ( index ) ; } } } @ Override", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } }", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . this . epsilon = = org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE ) entries . remove ( index ) ; } }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch4", "project_name": "Math_49"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { if ( ( 1 ) ! = ( org . apache . commons . math . stat . clustering . EuclideanIntegerPoint . this . point . length ) ) return false ; } }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; } }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { lmPar = FastMath . max ( parl , lmPar + correction ) ; } } }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Math_58"}
{"buggy_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( dx > 0 . 0 ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "fixed_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( - 1 < = delta ) delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( ( 0 ) ! = ( minValue ) ) minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; }", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) { if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } } return new double [ ] { a , b } ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) ) matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "fixed_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "fixed_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) { tailZone = rs . buildTailZone ( id ) ; } / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch5", "project_name": "Time_11"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( ( node2 . type ) ! = ( com . google . javascript . rhino . Node . this . type ) ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . QUOTED_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( ( provided ! = null ) | | ( ! ( ns . length ( ) < 10 ) ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_113"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . JSDOC_INFO_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "} } handleGet ( module , scope , n , parent , name , type ) ; } private boolean isClassDefiningCall ( Node callNode ) { SubclassRelationship classes =", "fixed_code": "} } if ( ( ( com . google . javascript . jscomp . GlobalNamespace . this . externsRoot ! = null ) & & ( ( - 1 ) ! = ( ( 2 ) - ( com . google . javascript . jscomp . GlobalNamespace . this . globalNames . size ( ) ) ) ) ) | | ( ! ( com . google . javascript . jscomp . GlobalNamespace . this . externsScope ! = null ) ) ) { handleGet ( module , scope , n , parent , name , type ) ; } } private boolean isClassDefiningCall ( Node callNode ) { SubclassRelationship classes =", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . SIDE_EFFECT_FLAGS ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < node2 . type ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . INFERRED_FUNCTION ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , WhitespaceOption option ) { if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOL | | token = = JsDocToken . EOF ) { return new ExtractionInfo ( \" \" , token ) ; }", "fixed_code": "private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , WhitespaceOption option ) { if ( com . google . javascript . jscomp . parsing . JsDocInfoParser . this . unreadToken ! = null ) { return new ExtractionInfo ( \" \" , token ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { finallyMap . put ( lastJump , null ) ; } } private void handleStmt ( Node node ) { / / Simply transfer to the next line .", "fixed_code": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { if ( com . google . javascript . jscomp . ControlFlowAnalysis . this . shouldTraverseFunctions ) { finallyMap . put ( lastJump , null ) ; } } } private void handleStmt ( Node node ) { / / Simply transfer to the next line .", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "fixed_code": "return true ; } if ( n . isDelProp ( ) ) { return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < 32 ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Closure_15"}
{"buggy_code": "NodeMismatch checkTreeEqualsImpl ( Node node2 ) { if ( ! isEquivalentTo ( node2 , false , false ) ) { return new NodeMismatch ( this , node2 ) ; } NodeMismatch res = null ; Node n , n2 ;", "fixed_code": "NodeMismatch checkTreeEqualsImpl ( Node node2 ) { if ( ! isEquivalentTo ( node2 , false , false ) ) { if ( com . google . javascript . rhino . Node . this . sourcePosition < = 1 ) { return new NodeMismatch ( this , node2 ) ; } } NodeMismatch res = null ; Node n , n2 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_16"}
{"buggy_code": "/ / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ; } else if ( rValue . isOr ( ) ) { / / Check for a very specific JS idiom : / / var x = x | | TYPE ;", "fixed_code": "/ / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . if ( ! ( com . google . javascript . jscomp . TypedScopeCreator . DELEGATE_PROXY_SUFFIX . length ( ) = = - 1 + com . google . javascript . jscomp . TypedScopeCreator . this . functionAnalysisResults . size ( ) ) ) { return rValue . getJSType ( ) ; } } else if ( rValue . isOr ( ) ) { / / Check for a very specific JS idiom : / / var x = x | | TYPE ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_17"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . IS_DISPATCHER ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "= new HashMap < String , ObjectType > ( ) ; for ( ObjectType interfaceType : functionType . getExtendedInterfaces ( ) ) { currentProperties . clear ( ) ; checkInterfaceConflictProperties ( t , n , functionPrivateName , properties , currentProperties , interfaceType ) ; properties . putAll ( currentProperties ) ; } }", "fixed_code": "= new HashMap < String , ObjectType > ( ) ; for ( ObjectType interfaceType : functionType . getExtendedInterfaces ( ) ) { currentProperties . clear ( ) ; if ( com . google . javascript . jscomp . TypeCheck . this . unknownCount < com . google . javascript . jscomp . TypeCheck . this . typedCount ) { checkInterfaceConflictProperties ( t , n , functionPrivateName , properties , currentProperties , interfaceType ) ; } properties . putAll ( currentProperties ) ; } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { if ( com . google . javascript . jscomp . CheckSideEffects . PROTECTOR_FN . length ( ) = = 0 ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; else break ; } } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( com . google . javascript . jscomp . CheckSideEffects . PROTECTOR_FN . length ( ) = = 0 ) { if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( ( com . google . javascript . rhino . Node . this . type ) ! = ( node2 . type ) ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } }", "fixed_code": "if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { if ( com . google . javascript . rhino . jstype . PrototypeObjectType . this . prettyPrint ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } defineInferredProperty ( prop , typeToInfer , null ) ; } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! objType . isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! objType . hasProperty ( prop ) ) { typeToInfer = getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; } objType . defineInferredProperty ( prop , typeToInfer , null ) ; } } } } }", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null ) { type . matchConstraint ( constraintObj ) ; } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "} / / Add the property to the record . if ( builder . addProperty ( fieldName , fieldType , fieldNameNode ) = = null ) { / / Duplicate field name , warning and skip reporter . warning ( n . getLineno ( ) , fieldNameNode . getCharno ( ) ) ; } } return builder . build ( ) ; }", "fixed_code": "} / / Add the property to the record . if ( ( fieldName . length ( ) ) ! = ( 5 ) ) { if ( builder . addProperty ( fieldName , fieldType , fieldNameNode ) = = null ) { / / Duplicate field name , warning and skip reporter . warning ( n . getLineno ( ) , fieldNameNode . getCharno ( ) ) ; } } } return builder . build ( ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Closure_35"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < 29 ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_49"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . LABEL_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_50"}
{"buggy_code": "/ / Compare estimated savings against the helper cost . Apply / / reductions if doing so will result in some savings . if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; } } }", "fixed_code": "/ / Compare estimated savings against the helper cost . Apply / / reductions if doing so will result in some savings . if ( ( ( 1 ) ! = ( reductions . size ( ) ) ) & & ( ! ( reducers . size ( ) < reductions . size ( ) ) ) ) { if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; } } } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "private Node maybeReplaceChildWithNumber ( Node n , Node parent , int num ) { Node newNode = Node . newNumber ( num ) ; if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange ( ) ; return newNode ;", "fixed_code": "private Node maybeReplaceChildWithNumber ( Node n , Node parent , int num ) { Node newNode = Node . newNumber ( num ) ; if ( ! newNode . isEquivalentTo ( n ) ) { if ( com . google . javascript . jscomp . PeepholeSubstituteAlternateSyntax . this . late ) { parent . replaceChild ( n , newNode ) ; } reportCodeChange ( ) ; return newNode ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_60"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( error ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "private void doPercentTypedAccounting ( NodeTraversal t , Node n ) { JSType type = n . getJSType ( ) ; if ( type = = null ) { nullCount + + ; } else if ( type . isUnknownType ( ) ) { if ( reportUnknownTypes . isOn ( ) ) { compiler . report (", "fixed_code": "private void doPercentTypedAccounting ( NodeTraversal t , Node n ) { JSType type = n . getJSType ( ) ; if ( type = = null ) { if ( com . google . javascript . jscomp . TypeCheck . this . inExterns ) { nullCount + + ; } } else if ( type . isUnknownType ( ) ) { if ( reportUnknownTypes . isOn ( ) ) { compiler . report (", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "if ( node2 = = null ) { throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; }", "fixed_code": "if ( node2 = = null ) { throw new IllegalStateException ( ) ; } if ( com . google . javascript . rhino . Node . PROPERTY_FLAG = = com . google . javascript . rhino . Node . this . first . getType ( ) ) { res = n . checkTreeEqualsImpl ( n2 ) ; } if ( res ! = null ) { return res ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . FUNCTION_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( org . apache . commons . lang . time . DateUtils . RANGE_WEEK_CENTER = = millisecs ) { val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ; double dy = y - ybar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( y < = x ) { ybar = y ; } } else { double dx = x - xbar ; double dy = y - ybar ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( tmp = = - 1 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "fixed_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; yDotOnScale2 + = ratio * ratio ; } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "fixed_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; if ( ( scale . length ) ! = ( org . apache . commons . math . ode . nonstiff . AdaptiveStepsizeIntegrator . this . maxStep ) ) { yDotOnScale2 + = ratio * ratio ; } } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; }", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 1 < = org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "for ( EventState state : eventsStates ) { state . reinitializeBegin ( interpolator ) ; } statesInitialized = true ; } / / search for next events that may occur during the step final int orderingSign = interpolator . isForward ( ) ? + 1 : - 1 ;", "fixed_code": "for ( EventState state : eventsStates ) { state . reinitializeBegin ( interpolator ) ; } if ( 1 = = org . apache . commons . math . ode . AbstractIntegrator . this . stepHandlers . size ( ) ) { statesInitialized = true ; } } / / search for next events that may occur during the step final int orderingSign = interpolator . isForward ( ) ? + 1 : - 1 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } @ Override", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { entries . remove ( index ) ; } } } @ Override", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } protected enum Method {", "fixed_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } } protected enum Method {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { lower - = 1 ; } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch3", "project_name": "Math_57"}
{"buggy_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } }", "fixed_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( ( param [ 2 ] ) = = 0 ) { if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "fixed_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } / / prepare handling of the remaining part of the step previousT = eventT ;", "fixed_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } if ( ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) ) ! = ( eventY . length ) ) { return eventT ; } } / / prepare handling of the remaining part of the step previousT = eventT ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Math_73"}
{"buggy_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch3", "project_name": "Math_73"}
{"buggy_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( x0 = = x2 ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "fixed_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( ( ( 1 < x2 ) & & ( ! ( y0 < = i ) ) ) | | ( x0 = = x2 ) ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { work [ i + k ] = work [ j - k ] ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( dMin1 = = dN1 & & dMin2 = = dN2 ) { / / cases 7 and 8 . tType = - 7 ;", "fixed_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . main ! = null ) { / / cases 7 and 8 . tType = - 7 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( maximumIterations = = initial ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( constraints . size ( ) ) ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "fixed_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( id . length ( ) = = 0 ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "fixed_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Time_12"}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( ! ( ( ( fieldIndex ) ! = ( 1 ) ) & & ( valueToAdd < = values . length ) ) ) | | ( valueToAdd < - 1 ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "fixed_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( org . joda . time . DateTimeZone . this . iID ! = null ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "fixed_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; if ( ( ( 20 ) - ( value + newTypes . length ) < value ) | | ( ( 2 ) ! = ( org . joda . time . Partial . this . iTypes . length ) ) ) { newValues [ i ] = value ; } System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "fixed_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch3", "project_name": "Chart_13"}
{"buggy_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch4", "project_name": "Chart_13"}
{"buggy_code": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "fixed_code": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) {", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = range . upper ) ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Chart_21"}
{"buggy_code": "int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "fixed_code": "int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch3", "project_name": "Chart_25"}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch4", "project_name": "Chart_25"}
{"buggy_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "fixed_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "fixed_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "fixed_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( org . apache . commons . lang . time . DateUtils . RANGE_WEEK_CENTER = = millisecs ) { val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Lang_53"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ; double dy = y - ybar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( y < = x ) { ybar = y ; } } else { double dx = x - xbar ; double dy = y - ybar ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_105"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( tmp = = - 1 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "fixed_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { } } }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_28"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; }  } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( org . apache . commons . math3 . optimization . linear . SimplexTableau . NEGATIVE_VAR_COLUMN_LABEL . length ( ) ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_33"}
{"buggy_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; yDotOnScale2 + = ratio * ratio ; } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "fixed_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; if ( ( scale . length ) ! = ( org . apache . commons . math . ode . nonstiff . AdaptiveStepsizeIntegrator . this . maxStep ) ) { yDotOnScale2 + = ratio * ratio ; } } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { } else { - end ; }  / / we need to do one more attempt nextX = Double . NaN ;", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( true ) { + start ; } else { } / / we need to do one more attempt nextX = Double . NaN ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this signChangeIndex + + ; targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "label": 0, "tool_name": "PatchSim", "patch_name": "patch3", "project_name": "Math_40"}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; }", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 1 < = org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } @ Override", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { entries . remove ( index ) ; } } } @ Override", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } protected enum Method {", "fixed_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } } protected enum Method {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getArgument ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { if ( ( 1 ) ! = ( org . apache . commons . math . stat . clustering . EuclideanIntegerPoint . this . point . length ) ) return false ; } }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } }", "fixed_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( ( param [ 2 ] ) = = 0 ) { if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_58"}
{"buggy_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "fixed_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( dx > 0 . 0 ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "fixed_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( x0 = = x2 ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "fixed_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( ( ( 1 < x2 ) & & ( ! ( y0 < = i ) ) ) | | ( x0 = = x2 ) ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( - 1 < = delta ) delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_78"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { work [ i + k ] = work [ j - k ] ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) {  b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch3", "project_name": "Math_81"}
{"buggy_code": "} else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ; double s = 0 . 25 * dMin ;", "fixed_code": "} else if ( dMin = = dN2 ) { / / case 5 . if ( true ) return ; tType = - 5 ; double s = 0 . 25 * dMin ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch4", "project_name": "Math_81"}
{"buggy_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( dMin1 = = dN1 & & dMin2 = = dN2 ) { / / cases 7 and 8 . tType = - 7 ;", "fixed_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . main ! = null ) { / / cases 7 and 8 . tType = - 7 ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch5", "project_name": "Math_81"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( ( 0 ) ! = ( minValue ) ) minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( maximumIterations = = initial ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) ) matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( constraints . size ( ) ) ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_87"}
{"buggy_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "fixed_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "fixed_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_88"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; if ( true ) return 0d ; return ret ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) {  / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "fixed_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Math_97"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( id . length ( ) = = 0 ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Time_11"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0, "tool_name": "PatchSim", "patch_name": "patch3", "project_name": "Time_11"}
{"buggy_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "fixed_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( ! ( ( ( fieldIndex ) ! = ( 1 ) ) & & ( valueToAdd < = values . length ) ) ) | | ( valueToAdd < - 1 ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "fixed_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( org . joda . time . DateTimeZone . this . iID ! = null ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "fixed_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { if ( true ) return 0 ; return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "fixed_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; if ( ( ( 20 ) - ( value + newTypes . length ) < value ) | | ( ( 2 ) ! = ( org . joda . time . Partial . this . iTypes . length ) ) ) { newValues [ i ] = value ; } System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "label": 0, "tool_name": "PatchSim", "patch_name": "patch2", "project_name": "Time_4"}
{"buggy_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "fixed_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "label": 0, "tool_name": "PatchSim", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = true ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = false ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = true ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "label": 0, "tool_name": "PraPR", "patch_name": "patch2", "project_name": "Closure_101"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! false & & apply ( c ) ) { return true ; } } throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; } return res ; }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } } throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; }", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! false & & apply ( c ) ) { return true ; } }", "label": 0, "tool_name": "PraPR", "patch_name": "patch2", "project_name": "Closure_12"}
{"buggy_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; }", "fixed_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; return res ; } return res ; }", "label": 0, "tool_name": "PraPR", "patch_name": "patch3", "project_name": "Closure_12"}
{"buggy_code": "* Returns whether all warnings were reported to this reporter . public boolean hasEncounteredAllWarnings ( ) { return ( warnings = = null ) ? warningsIndex = = 0 : warnings . length = = warningsIndex ; }", "fixed_code": "* Returns whether all warnings were reported to this reporter . public boolean hasEncounteredAllWarnings ( ) { return true ; }", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; }", "fixed_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; return res ; } return res ; }", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "fixed_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res = = null ) { return res ; } }", "label": 0, "tool_name": "PraPR", "patch_name": "patch2", "project_name": "Closure_127"}
{"buggy_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & info . getLendsName ( ) ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "fixed_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_17"}
{"buggy_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & info . getLendsName ( ) ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "fixed_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & this . sourceName ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "label": 0, "tool_name": "PraPR", "patch_name": "patch2", "project_name": "Closure_17"}
{"buggy_code": "} / / Check whether the extended interfaces have any conflicts if ( functionType . getExtendedInterfacesCount ( ) > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "fixed_code": "} / / Check whether the extended interfaces have any conflicts if ( this . typedCount > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = null ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "PraPR", "patch_name": "patch2", "project_name": "Closure_48"}
{"buggy_code": "int i = 0 ; for ( Node scriptNode = jsRoot . getFirstChild ( ) ; scriptNode ! = null ; scriptNode = scriptNode . getNext ( ) ) { toSource ( cb , i + + , scriptNode ) ; } }", "fixed_code": "int i = 0 ; for ( Node scriptNode = jsRoot . getFirstChild ( ) ; scriptNode ! = null ; scriptNode = null ) { toSource ( cb , i + + , scriptNode ) ; } }", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; entries . put ( key , value ) ; } }", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "int getWeekOfWeekyear ( long instant , int year ) { long firstWeekMillis1 = getFirstWeekOfYearMillis ( year ) ; if ( instant < firstWeekMillis1 ) { return getWeeksInYear ( year - 1 ) ; } long firstWeekMillis2 = getFirstWeekOfYearMillis ( year + 1 ) ; if ( instant > = firstWeekMillis2 ) {", "fixed_code": "int getWeekOfWeekyear ( long instant , int year ) { long firstWeekMillis1 = getFirstWeekOfYearMillis ( year ) ; if ( instant < firstWeekMillis1 ) { return 0 ; } long firstWeekMillis2 = getFirstWeekOfYearMillis ( year + 1 ) ; if ( instant > = firstWeekMillis2 ) {", "label": 0, "tool_name": "PraPR", "patch_name": "patch1", "project_name": "Time_24"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { int index = - 1 ; } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; }", "fixed_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 . 0d ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 . 0d ; } else { throw ex ; } } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch2", "project_name": "Math_103"}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch3", "project_name": "Chart_13"}
{"buggy_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "fixed_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { maybeResolveTemplateTypeFromNodes ( declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; } private void maybeResolveTemplateTypeFromNodes (", "fixed_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { } private void maybeResolveTemplateTypeFromNodes (", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "} if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "} if ( parent . isAssign ( ) ) { } } parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "} if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "} if ( parent . isAssign ( ) ) { } }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Closure_114"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch3", "project_name": "Closure_114"}
{"buggy_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "fixed_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } private Predicate < Var > getFilterForMode ( ) {", "fixed_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } private Predicate < Var > getFilterForMode ( ) {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } } }", "fixed_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } } }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "fixed_code": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; }  if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; }  Node addingRoot = compiler . getNodeForCodeInsertion ( null ) ; addingRoot . addChildrenToFront ( helperCode ) ; compiler . reportCodeChange ( ) ; } } }", "fixed_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } } }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "fixed_code": "boolean canRemove = false ; if ( specializationState = = null ) { } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "break ; case Token . STRING : return getStringNumberValue ( n . getString ( ) ) ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "fixed_code": "break ; case Token . STRING : break ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "return readObject ; } catch ( ClassNotFoundException ex ) { throw new SerializationException ( \" ClassNotFoundException while reading cloned object data \" , ex ) ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "fixed_code": "return readObject ; } catch ( ClassNotFoundException ex ) { return object ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return Short . parseShort ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; } / / non - basic artificial variables", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; int mBlockIndex = 0 ; return true ; } return false ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = 1 . 0 ; return ret ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch11", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; CodeGenerator . Context rhsContext = CodeGenerator . Context . IN_FOR_INIT_CLAUSE ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) = = null ) | | ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_18"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev < 0 ) | | ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_38"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_38"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > = 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isImmutableValue ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_86"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_86"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isToStringMethodCall ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Closure_86"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . evaluatesToLocalValue ( value . getFirstChild ( ) ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_LATE_PROVIDE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch11", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_INVALID_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_BASE_CLASS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch13", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_DUPLICATE_NAMESPACE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch15", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch16", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( 0 , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch17", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NULL_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch30", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( namespace , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_92"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , 0 ) ) ; } } }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return a < = b ? b : Float . isNaN ( ( a + b ) ) ? Float . NaN : a ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 3 - n ) * 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * 0 . 0 ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch29", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa ) = = 0 . 0 ) | | ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch34", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch36", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch37", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . min ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch48", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch49", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch51", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( fa > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch52", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( initial ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch54", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch55", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch57", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * 0 . 0 ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( fa ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Math_85"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }", "fixed_code": "public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + rowKey . toString ( ) ) ; } removeRow ( index ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "fixed_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "fixed_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; token = next ( ) ; } } while ( true ) ;", "fixed_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; jsdocBuilder . recordDescription ( line ) ; token = next ( ) ; } } while ( true ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "fixed_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; }  return this ; }", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; } this . propListHead = other . propListHead ; return this ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token ! = JsDocToken . STRING ) { return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token = = null ) { return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "fixed_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { n . removeChild ( right ) ; newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) {", "fixed_code": "getPropertyNode ( property ) ) ; } } return getLeastSupertype ( this , that ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_57"}
{"buggy_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "fixed_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "fixed_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars = = null & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "fixed_code": "if ( str = = null ) { return null ; } str = str . toLowerCase ( ) ; if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "fixed_code": "/ / a wrong value . return null ; } str = str . toLowerCase ( ) ; if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch3", "project_name": "Lang_41"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & expPos < numeric . length ( ) - 1 ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( lower + ( upper - 3 ) ) < lower ) { upper = lower ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "fixed_code": "locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "fixed_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < size ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < field ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( n < maxIterations ) & & ( FastMath . abs ( value - value ) > epsilon ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_1"}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( minRatio , 0 . 0 ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "fixed_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x0 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }   return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , initial ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch3", "project_name": "Math_73"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = sampleSize ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { return ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch8", "project_name": "Chart_1"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , true ) ) ; } } }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , writer ! = null ) ) ; } } }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch3", "project_name": "Lang_6"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( rhs ! = minRatio ) { if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | i < 0 ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | fmin = = fm ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch5", "project_name": "Math_70"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , entry ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio & & ratio > = 0 ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch8", "project_name": "Math_82"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) {  } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) {  } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , str . length ( ) - 1 ) ; } else { mant = str ; }", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "fixed_code": "private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 16000 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "/ / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ; final double VarU = n1n2prod * ( n1 + n2 + 1 ) / 12 . 0 ; final double z = ( Umin - EU ) / FastMath . sqrt ( VarU ) ;", "fixed_code": "/ / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ; final double VarU = ( double ) ( ( double ) n1n2prod * ( n1 + n2 + 1 ) ) / 12 . 0 ; final double z = ( Umin - EU ) / FastMath . sqrt ( VarU ) ;", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 0, "tool_name": "ssFix", "patch_name": "patch3", "project_name": "Math_30"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . float sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / CategoryPlot . java b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } diff - - git a / source / org / jfree / chart / plot / XYPlot . java b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Chart_14"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else {", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch5", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 0, "tool_name": "TBar", "patch_name": "patch6", "project_name": "Chart_14"}
{"buggy_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "fixed_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . leftBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "label": 0, "tool_name": "TBar", "patch_name": "patch7", "project_name": "Chart_14"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch8", "project_name": "Chart_14"}
{"buggy_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = \" Too many elements \" ; Font sfont = new Font ( \" dialog \" , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  }", "fixed_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "fixed_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "fixed_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_3"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_107"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Closure_109"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Closure_12"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ;", "fixed_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ;", "fixed_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_133"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_22"}
{"buggy_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Closure_66"}
{"buggy_code": "} @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } }", "fixed_code": "}  }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_18"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { diff - - git a / src / main / java / org / apache / commons / lang3 / StringUtils . java b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { diff - - git a / src / main / java / org / apache / commons / lang3 / StringUtils . java b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_20"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch5", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_24"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_41"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_41"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_41"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_43"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_43"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "fixed_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string if ( lower > str . length ( ) ) { lower = str . length ( ) ; } / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_45"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_45"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; }", "fixed_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; }", "fixed_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_60"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_15"}
{"buggy_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "fixed_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "fixed_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Math_62"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {  } return new double [ ] { a , b } ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_88"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_96"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_96"}
{"buggy_code": "int i = 0 ; while ( i < maximalIterationCount ) { m = UnivariateRealSolverUtils . midpoint ( min , max ) ; fmin = f . value ( min ) ; fm = f . value ( m ) ;", "fixed_code": "int i = 0 ; while ( i < maximalIterationCount ) { m = UnivariateRealSolverUtils . midpoint ( min , max ) ; if ( f = = null ) return 0 . 0 ; fmin = f . value ( min ) ; fm = f . value ( m ) ;", "label": 0, "tool_name": "VFix", "patch_name": "patch1", "project_name": "Math_70"}
